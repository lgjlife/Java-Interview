<span id="menu"></span>
<!-- TOC -->

- [1. 数据结构绪论](#1-数据结构绪论)
- [2. 算法](#2-算法)
- [3. 线性表](#3-线性表)
- [4. 栈和队列](#4-栈和队列)
- [5. 字符串](#5-字符串)
    - [5.1. KMP算法](#51-kmp算法)
- [6. 树](#6-树)
    - [6.1. 树的基本知识](#61-树的基本知识)
    - [6.2. 常见树结构比较](#62-常见树结构比较)
    - [6.3. 二叉树](#63-二叉树)
    - [6.4. 平衡二叉树](#64-平衡二叉树)
    - [6.5. B树](#65-b树)
    - [6.6. B+树](#66-b树)
    - [6.7. 红黑树](#67-红黑树)
    - [6.8. 跳表](#68-跳表)
- [7. 图](#7-图)
- [8. 查找](#8-查找)
    - [8.1. 散列表](#81-散列表)
    - [8.2. 跳表](#82-跳表)
- [9. 排序算法](#9-排序算法)
    - [9.1. 基本概念](#91-基本概念)
    - [9.2. 冒泡排序 Bubble Sort](#92-冒泡排序-bubble-sort)
    - [9.3. 简单选择排序 Simple Selection Sort](#93-简单选择排序-simple-selection-sort)
    - [9.4. 直接插入排序 Straight Insertion Sort](#94-直接插入排序-straight-insertion-sort)
    - [9.5. 希尔排序 Shell Sort](#95-希尔排序-shell-sort)
    - [9.6. 堆排序](#96-堆排序)
    - [9.7. 归并排序](#97-归并排序)
    - [9.8. 快速排序 QuickSort](#98-快速排序-quicksort)
    - [9.9. 总结](#99-总结)
- [10. 算法精选](#10-算法精选)
    - [10.1. 链表](#101-链表)
        - [10.1.1. 如何反转一个单链表](#1011-如何反转一个单链表)
        - [10.1.2. 判断链表中是否有环](#1012-判断链表中是否有环)
    - [10.2. 堆栈，队列](#102-堆栈队列)
        - [10.2.1. 判断括号字符串是否有效](#1021-判断括号字符串是否有效)
        - [10.2.2. 用栈实现队列](#1022-用栈实现队列)
        - [10.2.3. 用队列实现栈](#1023-用队列实现栈)
    - [10.3. 优先队列](#103-优先队列)
        - [10.3.1. 返回数据流中的第K大元素](#1031-返回数据流中的第k大元素)
        - [10.3.2. 返回滑动窗口中的最大值](#1032-返回滑动窗口中的最大值)
    - [10.4. 哈希表](#104-哈希表)
        - [10.4.1. 判断有效的字母异位词](#1041-判断有效的字母异位词)
        - [10.4.2. 找出数组中和为目标值的两个数，三个数，四个数](#1042-找出数组中和为目标值的两个数三个数四个数)
    - [10.5. 树](#105-树)
        - [10.5.1. 验证二叉搜索树](#1051-验证二叉搜索树)
        - [10.5.2. 二叉树的最近公共祖先](#1052-二叉树的最近公共祖先)
        - [10.5.3. 二叉搜索树的最近公共祖先](#1053-二叉搜索树的最近公共祖先)
    - [10.6. 分治递归](#106-分治递归)
        - [10.6.1. 实现计算x的n次幂函数](#1061-实现计算x的n次幂函数)
        - [10.6.2. 找出数组中出现次数大于n/2的元素](#1062-找出数组中出现次数大于n2的元素)
    - [10.7. 贪心算法](#107-贪心算法)
        - [10.7.1. 计算买股票的最佳时机](#1071-计算买股票的最佳时机)
    - [10.8. 广度优先搜索／深度优先搜索](#108-广度优先搜索／深度优先搜索)
        - [10.8.1. 二叉树层次遍历](#1081-二叉树层次遍历)
        - [10.8.2. 二叉树最大深度](#1082-二叉树最大深度)
        - [10.8.3. 二叉树最小深度](#1083-二叉树最小深度)
        - [10.8.4. 生成所有可能的有效括号组合](#1084-生成所有可能的有效括号组合)
    - [10.9. 剪枝](#109-剪枝)
        - [10.9.1. 如何使Ｎ皇后彼此之间不能相互攻击](#1091-如何使ｎ皇后彼此之间不能相互攻击)
        - [10.9.2. 判断数独是否有效](#1092-判断数独是否有效)
        - [10.9.3. 解决数独问题](#1093-解决数独问题)
    - [10.10. 二分查找](#1010-二分查找)
        - [10.10.1. 实现一个求解平方根的函数](#10101-实现一个求解平方根的函数)
    - [10.11. 字典树](#1011-字典树)
        - [10.11.1. 二维网格中的单词搜索问题](#10111-二维网格中的单词搜索问题)
        - [10.11.2. 实现一个字典树](#10112-实现一个字典树)
    - [10.12. 位运算](#1012-位运算)
        - [10.12.1. 二进制数中的比特位统计问题](#10121-二进制数中的比特位统计问题)
        - [10.12.2. 判断一个数是否为2的幂次方](#10122-判断一个数是否为2的幂次方)
        - [10.12.3. N皇后问题的另一种解法](#10123-n皇后问题的另一种解法)
    - [10.13. 动态规划](#1013-动态规划)
        - [10.13.1. 爬楼梯问题](#10131-爬楼梯问题)
        - [10.13.2. 三角形的最小路径和](#10132-三角形的最小路径和)
        - [10.13.3. 乘积最大子序列](#10133-乘积最大子序列)
        - [10.13.4. 用动态规划解决买卖股票问题](#10134-用动态规划解决买卖股票问题)
        - [10.13.5. 最长上升子序列](#10135-最长上升子序列)
        - [10.13.6. 不同面值硬笔的对换问题](#10136-不同面值硬笔的对换问题)
        - [10.13.7. 计算最短逻辑距离问题](#10137-计算最短逻辑距离问题)
    - [10.14. 并查集](#1014-并查集)
        - [10.14.1. 二维网格中小岛数量统计](#10141-二维网格中小岛数量统计)
        - [10.14.2. 计算矩阵中的朋友圈总数](#10142-计算矩阵中的朋友圈总数)
    - [10.15. LRU缓存](#1015-lru缓存)
        - [10.15.1. 设计一个LRU缓存](#10151-设计一个lru缓存)
    - [10.16. 布隆过滤器](#1016-布隆过滤器)
- [11. LeetCode](#11-leetcode)
    - [11.1. 数组](#111-数组)
        - [11.1.1. 简单](#1111-简单)
            - [11.1.1.1. 题目1:两数之和](#11111-题目1两数之和)
            - [11.1.1.2. 题目26 RemoveDuplicates](#11112-题目26-removeduplicates)
        - [11.1.2. 中等](#1112-中等)
        - [11.1.3. 困难](#1113-困难)
    - [11.2. 动态规划](#112-动态规划)
        - [11.2.1. 简单](#1121-简单)
        - [11.2.2. 中等](#1122-中等)
        - [11.2.3. 困难](#1123-困难)
    - [11.3. 数学](#113-数学)
        - [11.3.1. 简单](#1131-简单)
        - [11.3.2. 中等](#1132-中等)
        - [11.3.3. 困难](#1133-困难)
    - [11.4. 字符串](#114-字符串)
        - [11.4.1. 简单](#1141-简单)
            - [11.4.1.1. 题目13:字母转换数字](#11411-题目13字母转换数字)
            - [11.4.1.2. 题目67:二进制字符串相加](#11412-题目67二进制字符串相加)
        - [11.4.2. 中等](#1142-中等)
        - [11.4.3. 困难](#1143-困难)
    - [11.5. 树](#115-树)
        - [11.5.1. 简单](#1151-简单)
        - [11.5.2. 中等](#1152-中等)
        - [11.5.3. 困难](#1153-困难)
    - [11.6. 哈希表](#116-哈希表)
        - [11.6.1. 简单](#1161-简单)
        - [11.6.2. 中等](#1162-中等)
        - [11.6.3. 困难](#1163-困难)
    - [11.7. 深度优先搜索](#117-深度优先搜索)
        - [11.7.1. 简单](#1171-简单)
        - [11.7.2. 中等](#1172-中等)
        - [11.7.3. 困难](#1173-困难)
    - [11.8. 二分查找](#118-二分查找)
        - [11.8.1. 简单](#1181-简单)
        - [11.8.2. 中等](#1182-中等)
        - [11.8.3. 困难](#1183-困难)
    - [11.9. 贪心算法](#119-贪心算法)
        - [11.9.1. 简单](#1191-简单)
        - [11.9.2. 中等](#1192-中等)
        - [11.9.3. 困难](#1193-困难)
    - [11.10. 广度优先算法](#1110-广度优先算法)
        - [11.10.1. 简单](#11101-简单)
        - [11.10.2. 中等](#11102-中等)
        - [11.10.3. 困难](#11103-困难)
    - [11.11. 双指针](#1111-双指针)
        - [11.11.1. 简单](#11111-简单)
        - [11.11.2. 中等](#11112-中等)
        - [11.11.3. 困难](#11113-困难)
    - [11.12. 栈](#1112-栈)
        - [11.12.1. 简单](#11121-简单)
        - [11.12.2. 中等](#11122-中等)
        - [11.12.3. 困难](#11123-困难)
    - [11.13. 回溯算法](#1113-回溯算法)
        - [11.13.1. 简单](#11131-简单)
        - [11.13.2. 中等](#11132-中等)
        - [11.13.3. 困难](#11133-困难)
    - [11.14. 设计](#1114-设计)
        - [11.14.1. 简单](#11141-简单)
        - [11.14.2. 中等](#11142-中等)
            - [11.14.2.1. 题目146:LRU缓存机制](#111421-题目146lru缓存机制)
        - [11.14.3. 困难](#11143-困难)
    - [11.15. 位运算](#1115-位运算)
        - [11.15.1. 简单](#11151-简单)
            - [11.15.1.1. 题目136:只出现一次的数字](#111511-题目136只出现一次的数字)
            - [11.15.1.2. 题目169:多数元素](#111512-题目169多数元素)
            - [11.15.1.3. 题目191:位1的个数](#111513-题目191位1的个数)
            - [11.15.1.4. 题目389:找不同](#111514-题目389找不同)
            - [11.15.1.5. 插入](#111515-插入)
            - [11.15.1.6. 整数转换](#111516-整数转换)
            - [11.15.1.7. 消失的数字](#111517-消失的数字)
        - [11.15.2. 中等](#11152-中等)
        - [11.15.3. 困难](#11153-困难)
    - [11.16. 排序](#1116-排序)
        - [11.16.1. 简单](#11161-简单)
        - [11.16.2. 中等](#11162-中等)
        - [11.16.3. 困难](#11163-困难)
    - [11.17. 图](#1117-图)
        - [11.17.1. 简单](#11171-简单)
        - [11.17.2. 中等](#11172-中等)
        - [11.17.3. 困难](#11173-困难)
    - [11.18. 链表](#1118-链表)
        - [11.18.1. 简单](#11181-简单)
            - [11.18.1.1. 题目21:合并有序链表](#111811-题目21合并有序链表)
            - [11.18.1.2. 题目0202:返回倒数第 k 个节点](#111812-题目0202返回倒数第-k-个节点)
            - [11.18.1.3. 题目0207:链表相交](#111813-题目0207链表相交)
        - [11.18.2. 中等](#11182-中等)
        - [11.18.3. 困难](#11183-困难)
    - [11.19. 堆](#1119-堆)
        - [11.19.1. 简单](#11191-简单)
        - [11.19.2. 中等](#11192-中等)
        - [11.19.3. 困难](#11193-困难)
    - [11.20. 并查集](#1120-并查集)
        - [11.20.1. 简单](#11201-简单)
        - [11.20.2. 中等](#11202-中等)
        - [11.20.3. 困难](#11203-困难)
    - [11.21. Ｓliding Window](#1121-ｓliding-window)
        - [11.21.1. 简单](#11211-简单)
        - [11.21.2. 中等](#11212-中等)
        - [11.21.3. 困难](#11213-困难)
    - [11.22. 分治算法](#1122-分治算法)
        - [11.22.1. 简单](#11221-简单)
        - [11.22.2. 中等](#11222-中等)
        - [11.22.3. 困难](#11223-困难)
    - [11.23. 字典树](#1123-字典树)
        - [11.23.1. 简单](#11231-简单)
        - [11.23.2. 中等](#11232-中等)
        - [11.23.3. 困难](#11233-困难)
    - [11.24. 递归](#1124-递归)
        - [11.24.1. 简单](#11241-简单)
        - [11.24.2. 中等](#11242-中等)
        - [11.24.3. 困难](#11243-困难)
    - [11.25. 线段树](#1125-线段树)
        - [11.25.1. 简单](#11251-简单)
        - [11.25.2. 中等](#11252-中等)
        - [11.25.3. 困难](#11253-困难)
    - [11.26. Ordered Map](#1126-ordered-map)
        - [11.26.1. 简单](#11261-简单)
        - [11.26.2. 中等](#11262-中等)
        - [11.26.3. 困难](#11263-困难)
    - [11.27. 队列](#1127-队列)
        - [11.27.1. 简单](#11271-简单)
        - [11.27.2. 中等](#11272-中等)
        - [11.27.3. 困难](#11273-困难)
    - [11.28. 极小化极大](#1128-极小化极大)
        - [11.28.1. 简单](#11281-简单)
        - [11.28.2. 中等](#11282-中等)
        - [11.28.3. 困难](#11283-困难)
    - [11.29. 树状数组](#1129-树状数组)
        - [11.29.1. 简单](#11291-简单)
        - [11.29.2. 中等](#11292-中等)
        - [11.29.3. 困难](#11293-困难)
    - [11.30. Line　Ｓweep](#1130-line　ｓweep)
        - [11.30.1. 简单](#11301-简单)
        - [11.30.2. 中等](#11302-中等)
        - [11.30.3. 困难](#11303-困难)
    - [11.31. Random](#1131-random)
        - [11.31.1. 简单](#11311-简单)
        - [11.31.2. 中等](#11312-中等)
        - [11.31.3. 困难](#11313-困难)
    - [11.32. 拓扑排序](#1132-拓扑排序)
        - [11.32.1. 简单](#11321-简单)
        - [11.32.2. 中等](#11322-中等)
        - [11.32.3. 困难](#11323-困难)
    - [11.33. 脑筋急转弯](#1133-脑筋急转弯)
        - [11.33.1. 简单](#11331-简单)
        - [11.33.2. 中等](#11332-中等)
        - [11.33.3. 困难](#11333-困难)
    - [11.34. 几何](#1134-几何)
        - [11.34.1. 简单](#11341-简单)
        - [11.34.2. 中等](#11342-中等)
        - [11.34.3. 困难](#11343-困难)
    - [11.35. 二叉搜索树](#1135-二叉搜索树)
        - [11.35.1. 简单](#11351-简单)
        - [11.35.2. 中等](#11352-中等)
        - [11.35.3. 困难](#11353-困难)
    - [11.36. Rejection Sampling](#1136-rejection-sampling)
        - [11.36.1. 简单](#11361-简单)
        - [11.36.2. 中等](#11362-中等)
        - [11.36.3. 困难](#11363-困难)
    - [11.37. 蓄水池搜样](#1137-蓄水池搜样)
        - [11.37.1. 简单](#11371-简单)
        - [11.37.2. 中等](#11372-中等)
        - [11.37.3. 困难](#11373-困难)
    - [11.38. 记忆化](#1138-记忆化)
        - [11.38.1. 简单](#11381-简单)
        - [11.38.2. 中等](#11382-中等)
        - [11.38.3. 困难](#11383-困难)

<!-- /TOC -->

# 1. 数据结构绪论
<a href="#menu" >目录</a>

* 数据结构
    * 是相互之间存在一种或者多种的特定关系的数据集合

* 逻辑结构
    * 是指数据对象中数据元素之间的相互关系
    * 分类
        * 集合结构
        * 线性结构
        * 树形结构
        * 图形结构
    * 物理结构
        * 是指数据的逻辑结构在计算机中的存储形式
        * 顺序存储结构
            * 地址连续
        * 链式存储结构
            * 地址不一定连续
# 2. 算法
<a href="#menu" >目录</a>

* 算法
    * 算法是解决特定问题的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作
* 算法特性
    * 输入输出
        * 算法具有零个或者多个输入
        * 算法至少有一个或者多个输出
    * 有穷性
        * 指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且一个步骤在可接受的时间内完成
    * 确定性
        * 算法的每一个步骤都具有确定的含义，不会出现二义性
    * 可行性
        * 算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限的次数完成

* 算法设计要求
    * 正确性
        * 算法至少应该具有输入，输出和加工处理无歧义性，能够正确反映问题的需求，能够得到问题的正确答案
    * 可读性
        * 算法设计的另一个目的是为了便于阅读，理解和交流
    * 健壮性
        * 当输入数据不合法时，算法也能作出相关处理，而不是产生异常或者莫名奇妙的结果
    * 时间效率高和存储量低
* 算法效率的度量方法
    * 事后统计
        * 比如通过测试运行时间进行对比
    * 事前分析估算  
        * 决定因素
            * 算法采用的策略
            * 编译产生的代码质量
            * 问题的输入和输出
            * 机器执行指令的速度

* 推导大O阶方法
    * 用常数1取代运行时间中的所有加法常数
    * 在修改后的运行次数函数中，只保留最高阶
    * 如果高阶项存在且不是1,则去除与这个项相乘的常数，得到的结果就是大O阶

* 大O阶分类
    * 常数阶: O(1)
    * 线性阶: O(n)
    * 对数阶: O(log2^n)
    * 平方阶: O(n^2)
    * 立方阶: O(n^3)
![算法时间复杂度](pic/算法/基本概念/算法时间复杂度.png)

算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。如果采用二分法,那么就会以2为底数,三分法就会以3为底数,其他亦然。

* 对算法的分析，一种是计算所有情况的平均值，这种计算方法称为平均时间复杂度。另一种是计算最坏情况下的时间复杂度，这种称为最坏时间复杂度。


# 3. 线性表
<a href="#menu" >目录</a>

* 线性表顺序存储结构
    * 用一段地址连续的存储单元依次存储线性表的数据元素
    * 优点
        * 无需为表示表中元素之间的逻辑关系而增加额外的存储空间 
        * 可以快速地存取表中任意位置的元素 
    * 缺点
        * 插入和删除需要移动大量的元素
        * 当线性表长度变化比较大时，难以确定存储空间的容量
        * 造成存储空间的碎片
* 线性表链式存储结构
    * 用一组任意存储单元存储线性表中的元素，这些存储单元可以是连续的，也可以是不连续的
    * 链式存储结构除存储元素本身的信息外，还需要存储指向其他元素的地址的信息
    * 优点
        * 添加，删除不需要移动大量的元素
        * 不需要预先分配存储空间，用多少分配多少。
    * 缺点
        * 不能O（1）读取或者设置任意位置的元素

**单向链表**

![单向链表](pic/算法/链表/单向链表.png)

**双向链表**

![双向链表](pic/算法/链表/双向链表.png)

**循环链表**

![循环链表](pic/算法/链表/循环链表.png)

# 4. 栈和队列
<a href="#menu" >目录</a>

* 栈 stack
    * 基本概念 
        * 限定仅在表尾进行插入和删除操作的线性表
        * 栈的两端分别为栈底和栈顶
        * 栈的插入操作，叫做进栈。也称压栈，入栈
        * 栈的删除操作，叫做出栈/弹栈
    * 栈的基本方法：
        * empty()  如果栈为空返回true，否则返回false  
        * size()   返回栈中元素的个数  
        * pop()    删除栈顶元素但不返回其值  
        * top()    返回栈顶的元素，但不删除该元素  
        * push()   在栈顶压入新元素  

* 队列 queue
    * 只允许在一端进行插入操作，而在另一端进行删除操作的线性表
    * 队列是一种先进先出(First In First Out)的线性表(FIFO) ,允许插入的一端称为队尾，允许删除的一端称为队头。
    * 队列的基本方法：
        * q.empty()    如果队列为空返回true，否则返回false  
        * size()       返回队列中元素的个数  
        * pop()        删除队列首元素但不返回其值  
        * front()      返回队首元素的值，但不删除该元素  
        * push()       在队尾压入新元素  
        * back()       返回队列尾元素的值，但不删除该元素
# 5. 字符串
<a href="#menu" >目录</a>


## 5.1. KMP算法
<a href="#menu" >目录</a>



# 6. 树
<a href="#menu" >目录</a>

## 6.1. 树的基本知识
<a href="#menu" >目录</a>

* 树: 树是n（n>=0）个节点的有限集，n=０称为空树，在任意一棵非空的树中，有且仅有一个根节点(root).其余节点构成的结构称为子树.子树之间不会相交，但某些结构例外，比如b+树，叶子节点是通过链表相连
* 度:　节点拥有的直接子树数目
* 节点分类
    * 根节点
    * 内部节点
    * 叶子节点／端节点
* 节点之间的关系
    * 节点得到子树的根称为该节点的孩子(child).该节点称为孩子节点的双亲。同一个双亲之间的孩子称为兄弟节点
* 节点的层次level
    * 节点的层次从根开始，根为第一层，根的孩子称为第二层，以此类推。树中节点的最大层次称为树的深度(depth)或者高度
* 有序树和无序树，如果每个子树以及整体上看，从左到右都是有序的，那么称为有序树

计算机科学中的树
* 二叉树	
    * ▪ 二叉树 ▪ 二叉查找树	▪ 笛卡尔树	▪ Top tree ▪ T树			
* 自平衡二叉查找树	
    * ▪ AA树	▪ AVL树	▪ 红黑树 ▪ 伸展树 ▪ 树堆	▪ 节点大小平衡树		
* B树	
    * ▪ B树	▪ B+树	▪ B*树	▪ Bx树 ▪ UB树	▪ 2-3树	▪ 2-3-4树	▪ (a,b)-树 ▪ Dancing tree	▪ H树		
* Trie	
    * ▪ 前缀树	▪ 后缀树	▪ 基数树  ▪ 空间划分树	▪ 四叉树	▪ 八叉树	▪ k-d树	▪ vp-树 ▪ R树	▪ R*树	▪ R+树	▪ X树 ▪ M树	▪ 线段树	▪ 希尔伯特R树	▪ 优先R树
* 非二叉树	
    * ▪ Exponential tree	▪ Fusion tree	▪ 区间树	▪ PQ tree ▪ Range tree	▪ SPQR tree	▪ Van Emde Boas tree	
* 其他类型	
    * ▪ 堆	▪ 散列树	▪ Finger tree	▪ Metric tree ▪ Cover tree	▪ BK-tree	▪ Doubly-chained tree	▪ iDistance▪ Link-cut tree	▪ 树状数组		


![树的的深度](pic/算法/树/树的的深度.png)

## 6.2. 常见树结构比较
<a href="#menu" >目录</a>

* AVL树:最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树
* 红黑树:平衡二叉树，广泛用在C++的STL中。map和set都是用红黑树实现的。我们熟悉的STL的map容器底层是RBtree,当然指的不是unordered_map,后者是hash。
* B/B+树用在磁盘文件组织 数据索引和数据库索引
* Trie树 字典树，用在统计和排序大量字符串

**AVL**

是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。

平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。我们可以推出AVL树适合用于插入删除次数比较少，但查找多的情况。

**红黑树**

平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。

* 应用
    * STL
    * epoll在内核中的实现，用红黑树管理事件块
    * nginx中，用红黑树管理timer等
    * Java的TreeMap实现
    * 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块

**B和B+**

特点是一样的，是多路查找树，一般用于数据库系统中，因为它们分支多层数少，磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以要有效的减少磁盘IO次数避免磁盘频繁的查找,y一个节点就是一页的数据，这样可以一次性读取大量的磁盘中的数据。B+树是B树的变种树，有n棵子树的节点中含有n个关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子节点。是为文件系统而生的。

主要用在文件系统以及数据库中做索引等，比如Mysql：B-Tree Index

**trie 树**

又名单词查找树，一种树形结构，常用来操作字符串。它是不同字符串的相同前缀只保存一份。相对直接保存字符串肯定是节省空间的，但是它保存大量字符串时会很耗费内存（是内存）。

一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示还有比如IP选路，也是前缀匹配，一定程度会用到trie

**跳表**

Redis中就使用跳表，而不是红黑树来存储管理其中的元素（应该说的是一级元素-直接的Key,里面的value应该是有不同的数据结构）。

首先，跳表是skiplist？不是ziplist。ziplist在redis中是一个非常省内存的链表（代价是性能略低），所以在hash元素的个数很少（比如只有几十个），
那么用这个结构来存储则可以在性能损失很小的情况下节约很多内存（redis是内存数据库啊，能省还是要省的）。好这个问题清楚了。

Redis作者描述的使用跳表的原因:
* 跳表的一个缺点是耗内存（因为要重复分层存节点），但是作者也说了，可以调参数来降低内存消耗，和那些平衡树结构达到差不多。
* redis经查有范围操作，这样利用跳表里面的双向链表，可以方便地操作。另外还有缓存区域化（cache locality）不会比平衡树差。
* 实现简单。zrank操作能够到O(log(N)).

在server端，对并发和性能有要求的情况下，如何选择合适的数据结构（这里是跳跃表和红黑树）。
如果单纯比较性能，跳跃表和红黑树可以说相差不大，但是加上并发的环境就不一样了，
如果要更新数据，跳跃表需要更新的部分就比较少，锁的东西也就比较少，所以不同线程争锁的代价就相对少了，
而红黑树有个平衡的过程，牵涉到大量的节点，争锁的代价也就相对较高了。性能也就不如前者了。
在并发环境下skiplist有另外一个优势，红黑树在插入和删除的时候可能需要做一些rebalance的操作，这样的操作可能会涉及到整个树的其他部分，
而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。

## 6.3. 二叉树
<a href="#menu" >目录</a>

* 二叉树特点
    * 每个节点最多两颗子树
    * 左右子树是有顺序的
    * 即使某节点只有一棵子树，也要区分左子树和右子树
* 特殊二叉树
    * 斜二叉树: 从根节点开始，整个树结构只有左子树或者右子树，这种结构查找最慢。最好不要出现
    * 满二叉树: 所有节点都有左右子树，且所有的叶子节点是在同一层。这种查找效率最高
* 二叉树性质
    * 性质1：非空二叉树中的叶子结点的数量等于双分支结点（度为2的结点）的数量加1.
    * 性质2：二叉树的第i层上最多有2^(i-1)(i>=1)个节点。
        * 第1层是根节点，只有一个节点，2^(1-1)=1
        * 第2层是2个节点，2^(2-1)=2
        * 第3层是4个节点，2^(３-1)=４
    * 性质3：高度（或深度）为i的二叉树最多有2^(i-1)(i>=1)个节点。也可以认为高度为i的二叉树有2^(i-1)个结点，那么该二叉树为满二叉树。
    
* 二叉树遍历
    * 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。
    * 前序遍历：根结点 ---> 左子树 ---> 右子树
    * 中序遍历：左子树---> 根结点 ---> 右子树
    * 后序遍历：左子树 ---> 右子树 ---> 根结点
    * 层次遍历：仅仅需按层次遍历就可以
    
![二叉树](pic/算法/树/二叉树.png)
* 前序遍历：50  25  12  35  30  40  75  65  85
* 中序遍历：12  25  30  35  40  50  65  75  85  
* 后序遍历：12  30  40  35  25  65  85  75  50
* 层次遍历：50  25  75  12  35  65  85  30  40

**创建二叉树**

二叉树的节点包括数据，左子树的指针，右子树的指针。
```java
public class BinaryTree {

    private Node root ;
    private class Node{

        private int data;
        private Node left;
        private Node right;

        public Node(int data){
            this.data = data;
        }
    }

    public void insertData(int data){
        if(root == null){
            root = new Node(data);
            return;
        }
        Node temp =  root;
        while(true){
            if(data < temp.data ){
                if(temp.left == null){
                    temp.left = new Node(data);
                    return;
                }
                else {
                    temp =temp.left;
                }
            }
            else if(data >= temp.data ){
                if(temp.right == null){
                    temp.right = new Node(data);
                    return;
                }
                else {
                    temp =temp.right;
                }
            }
        }

    }
}

```

**前序遍历**

递归版本
```java
public void preOrderTraverse1(Node node){
    if (node == null) return;
    System.out.print(node.data + "  "  );
    preOrderTraverse1(node.left);
    preOrderTraverse1(node.right);
}
```

非递归版本

依据前序遍历的顺序，优先訪问根结点。然后在訪问左子树和右子树。所以。对于随意结点node。第一部分即直接訪问之，之后在推断左子树是否为空，不为空时即反复上面的步骤，直到其为空。若为空。则须要訪问右子树。注意。在訪问过左孩子之后。须要反过来訪问其右孩子。所以，须要栈这样的数据结构的支持。对于随意一个结点node，详细过程例如以下：
* 訪问之，并把结点node入栈。当前结点置为左孩子；
* 推断结点node是否为空，若为空。则取出栈顶结点并出栈，将右孩子置为当前结点；否则反复a)步直到当前结点为空或者栈为空（能够发现栈中的结点就是为了訪问右孩子才存储的）

```java
//前序便利－－非递归方式
public void preOrderTraverse2(Node node){

    if (node == null) return;

    Stack<Node> stack = new Stack<>();
    Node temp = node;

    while(temp != null || !stack.isEmpty()){

        if (temp != null){
            System.out.print(temp.data + "  ");
            stack.push(temp);
            temp = temp.left;
        }
        else {
            //
            Node node1  =  stack.pop();
            temp = node1.right;
        }
    }
}
```
**中序遍历** 
递归版本
```java
public void inOrderTraverse1(Node node){
    if (node == null) return;
    inOrderTraverse1(node.left);
    System.out.print(node.data + "  "  );
    inOrderTraverse1(node.right);
}
```
非递归版本
```java
//中序便利－－非递归方式
public void inOrderTraverse2(Node node){

    Stack<Node> stack = new Stack<>();
    Node temp = node;

    while(temp != null || !stack.isEmpty()){

        if (temp != null){

            stack.push(temp);
            temp = temp.left;
        }
        else {
            //
            Node node1  =  stack.pop();
            System.out.print(node1.data + "  ");
            temp = node1.right;
        }
    }
}
```

**后序遍历** 
递归版本
```java
public void postOrderTraverse1(Node node){
    if (node == null) return;
    postOrderTraverse1(node.left);
    postOrderTraverse1(node.right);
    System.out.print(node.data + "  "  );
}
```
**层次遍历** 

层次遍历的代码比較简单。仅仅须要一个队列就可以。先在队列中增加根结点。之后对于随意一个结点来说。在其出队列的时候，訪问之。同一时候假设左孩子和右孩子有不为空的入队列。

```java
public void  levelTraverse(Node node){

    if (node == null) return;
    LinkedList<Node> nodes = new LinkedList<>();

    nodes.add(node);

    while(!nodes.isEmpty()){
　　　　　//获取队尾数据
        Node temp = nodes.poll();
        System.out.print(temp.data + "  ");
        //向队头添加
        if(temp.left != null){
            nodes.add(temp.left);
        }
        if(temp.right != null){
            nodes.add(temp.right);
        }
    }
}
```

## 6.4. 平衡二叉树
<a href="#menu" >目录</a>

平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多.

平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。



## 6.5. B树
<a href="#menu" >目录</a>

是一种多路搜索树（并不是二叉的）：
* 定义任意非叶子结点最多只有M个儿子；且M>2；
* 根结点的儿子数为[2, M]；
* 除根结点以外的非叶子结点的儿子数为[M/2, M]；
* 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
* 非叶子结点的关键字个数=指向儿子的指针个数-1；
* 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
* 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
* 所有叶子结点位于同一层；

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B-树的特性：
* 关键字集合分布在整颗树中；
* 任何一个关键字出现且只出现在一个结点中；
* 搜索有可能在非叶子结点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找；
* 自动层次控制；

由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

* 度数：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。
* 阶数：（Order）阶定义为一个节点的子节点数目的最大值。（自带最大值属性）

**B树的插入**

B树的插入是指插入一条记录，如果B树已存在需要插入的键值时，用新的值替换旧的值；若B树不存在这个值时，则是在叶子结点进行插入操作。对高度为h的m阶B树，新结点一般插第h层。通过检索可以确定关键码应插入的位置，

* 若该结点中关键码个数小于等于m-1，则直接插入就可
* 若该结点中关键码个数等于m-1，则将引起结点的分裂，以中间的关键码为界将结点一分为二，产生了一个新的结点，并将中间关键码插入到父结点中；

重复上述过程，最坏情况一直分裂到根结点， 建立一个新的根结点，整个B树就增加一层。

下面以5阶B树举例，根据B树的定义，结点最多有4个值，最少有2个值。

* 在空树插入39，此时就有一个值，根结点也是叶子结点

![B树插入1](pic/算法/树/B树插入1.png)

* 继续插入22，97和41值，根结点变为4个值，符合要求

![B树插入2](pic/算法/树/B树插入2.png)

* 插入53值

![B树插入3](pic/算法/树/B树插入3.png)

* 插入之后发现超过结点最多只有4个值，所以要以中间值进行分开，分开后当前结点要指向父结点，分裂之后，发现符合要求

![B树插入4](pic/算法/树/B树插入4.png)

* 插入13，21，40，同样造成分裂，

![B树插入5](pic/算法/树/B树插入5.png)

* 紧接着插入30，27，33，36，24，34，35

![B树插入6](pic/算法/树/B树插入6.png)

* 将26再次插入进去

![B树插入7](pic/算法/树/B树插入7.png)

* 发现有5个值，超过B树的定义，需要以27为中心分裂，27进军父结点

![B树插入8](pic/算法/树/B树插入8.png)

* 发现父结点也超过4个，再次分裂

![B树插入9](pic/算法/树/B树插入9.png)

* 最后插入17，28，29，31，32的记录

![B树插入10](pic/算法/树/B树插入10.png)

**B树的删除**

B树删除：首先要查找该值是否在B树中存在，如果存在，判断该元素是否存在左右孩子结点，如果有，则上移孩子结点中的相近结点（左孩子最右边的结点或者有孩子最左边的结点）到父结点中，然后根据移动之后的情况；如果没有，进行直接删除；如果不存在对应的值，则删除失败。
* 如果当前要删除的值位于非叶子结点，则用后继值覆盖要删除的值，再用后继值所在的分支删除该后继值。（该后继值必须位于叶子结点上）
* 该结点值个数不小于Math.ceil(m/2)-1（取上线函数），结束删除操作，否则下一步
* 如果兄弟结点值个数大于Math.ceil(m/2)-1，则父结点中下移到该结点，兄弟的一个值上移，删除操作结束。

将父结点的key下移与当前的结点和他的兄弟姐妹结点key合并，形成一个新的结点，有些结点可能有左兄弟，也有右兄弟，我们可以任意选择一个兄弟结点即可。

下面以5阶B树举例进行删除，根据B树的定义，结点最多有4个值，最少有2个值

* 原始状态

![B树删除1](pic/算法/树/B树删除1.png)

* 在上面的B树删除21，删除之后结点个数大于等于2，所以删除结束

![B树删除2](pic/算法/树/B树删除2.png)

* 删除27之后为

![B树删除3](pic/算法/树/B树删除3.png)

27处于非叶子结点，用27的后继替换。也即是28替换27，然后在右孩子结点删除28，如上。

发现删除，当前叶子结点的记录的个数已经小于2，而兄弟结点中有3个记录我们可以从兄弟结点中借取一个key，父结点中的28就下移，兄弟结点中的26就上移,删除结束，结果如下

![B树删除4](pic/算法/树/B树删除4.png)

* 删除32
![B树删除5](pic/算法/树/B树删除5.png)


删除之后发现，当前结点中有key，而兄弟都有两个key，所以只能让父结点的30下移到和孩子一起合并，成为新的结点，并指向父结点，经拆封发现符合要求

![B树删除6](pic/算法/树/B树删除6.png)



## 6.6. B+树
<a href="#menu" >目录</a>

B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

B+树是B-树的变体，也是一种多路搜索树：
* 其定义基本与B-树同
* 非叶子结点的子树指针与关键字个数相同；
* 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
* 为所有叶子结点增加一个链指针；
* 所有关键字都在叶子结点出现；

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

B+的特性：
* 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
* 不可能在非叶子结点命中；
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
* 更适合文件索引系统；

**为什么说B+树比B树更适合做操作系统的数据库索引和文件索引？**
* B+树的磁盘读写的代价更低.B+树内部结点没有指向关键字具体信息的指针，这样内部结点相对B树更小。
* B+树的查询更加的稳定.因为非终端结点并不是最终指向文件内容的结点，仅仅是作为叶子结点中关键字的索引。这样所有的关键字的查找都会走一条从根结点到叶子结点的路径。所有的关键字查询长度都是相同的，查询效率相当。

**B+树插入**

* 若为空树，直接插入，此时也就是根结点
* 对于叶子结点：根据key找叶子结点，对叶子结点进行插入操作。插入后，如果当前结点key的个数不大于m-1，则插入就结束。反之将这个叶子结点分成左右两个叶子结点进行操作，左叶子结点包含了前m/2个记录，右结点包含剩下的记录key，将第m/2+1个记录的key进位到父结点中（父结点必须是索引类型结点），进位到父结点中的key左孩子指针向左结点,右孩子指针向右结点。
* 针对索引结点：如果当前结点key的个数小于等于m-1，插入结束。反之将这个索引类型结点分成两个索引结点，左索引结点包含前(m-1)/2个数据，右结点包含m-(m-1)/2个数据，然后将第m/2个key父结点中，进位到父结点的key左孩子指向左结点, 父结点的key右孩子指向右结点。

下面以5阶B+树举例进行插入，根据B+树的定义，结点最多有4个值，最少有2个值。

* 空树插入5，8，10，15

![B+树插入1](pic/算法/树/B+树插入1.png)

* 插入16
 
![B+树插入2](pic/算法/树/B+树插入2.png)

* 超过了最大值4，所以分裂，以中间为准

![B+树插入3](pic/算法/树/B+树插入3.png)

* 插入17，18
![B+树插入4](pic/算法/树/B+树插入4.png)

* 结点的关键字等于5，大于4，进行分裂。

![B+树插入5](pic/算法/树/B+树插入5.png)
符合条件，插入完成。

 

**B+树删除**

![B+树删除1](pic/算法/树/B+树删除1.png)

下面以5阶B+树举例进行删除，根据B+树的定义，结点最多有4个值，最少有2个值。

* 下面是初始状态

![B+树删除2](pic/算法/树/B+树删除2.png)


* 删除22，删除后个数为2，删除结束

![B+树删除3](pic/算法/树/B+树删除3.png)

* 删除15，结果如下：

![B+树删除4](pic/算法/树/B+树删除4.png)

删除之后，只有一个值，而兄弟有三个值，所以从兄弟结点借一个关键字，并更新索引结点

![B+树删除5](pic/算法/树/B+树删除5.png)

* 删除7

![B+树删除6](pic/算法/树/B+树删除6.png)



 

## 6.7. 红黑树
<a href="#menu" >目录</a>

红黑树结构复杂，但它的操作能够保证在最坏情况下的运行时间。可以在O(logn)时间内完成查找，插入和删除操作。相对AVL(自平衡二叉查找树)牺牲了部分平衡性以换取插入、删除操作时少量的旋转操作，整体性能优于AVL树。

* 红黑树（RBT）的定义：它或者是一颗空树，或者是具有一下性质的二叉查找树：
    * 1.节点非红即黑。
    * 2.根节点是黑色。
    * 3.所有NULL结点称为叶子节点，且认为颜色为黑。
    * 4.所有红节点的子节点都为黑色，即不存在连续的红节点。
    * 5.从任一节点到其叶子节点的所有路径上都包含相同数目的黑节点（包括叶子节点）。

![红黑树整体结构](pic/算法/树/红黑树整体结构.png)




## 6.8. 跳表
<a href="#menu" >目录</a>

对数据结构中的数据常见的操作有：查找、插入、删除。有序数组的二分查找操作速度很快，但是插入、删除操作很耗时，并且对内存要求很苛刻。那么有什么数据结构能够做到查找、插入、删除操作速度都很快而且对内存要求不高呢？——答案是：跳表。

跳表是什么？即：把有序链表改造位支持“二分查找”算法，这种链表叫做跳表。 跳表的二分查找算法其实是一种“类似二分查找算法”。

跳表是一个各方面性能都比较优秀的“动态数据结构”。可以进行快速的插入、删除、查找操作。代码实现也不复杂。甚至能替代“红黑树”。时间复杂度：O(logn)，空间复杂度：O(n)。

redis缓存数据库的有序集合(SortedSet)用的就是跳表实现。

![跳表](pic/算法/树/跳表.png)

如图所示，跳表的结构是分层，第一层存储全部数据，第二层抽取部分数据组成一个数据结构，第三层再从第二层中的数据抽取一部分数据。以此类推。

当搜索80时，搜索的顺序：
* 先搜索顶层4，80大于70，且该层的最大数据是70，因此往下一层搜索
* 搜索第三层，80在70和90之间，因此继续往下层搜索
* 搜索第二层，80在70和90之间，因此继续往下层搜索
* 搜索第一层，往右搜索就能搜索到80，搜索结束

这种搜索方式相比顺序查找效率高。

# 7. 图
<a href="#menu" >目录</a>



# 8. 查找
<a href="#menu" >目录</a>


## 8.1. 散列表

<a href="#menu" >目录</a>

* 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key).查找时，根据这个确定的对应关系找到给定值key的映射f(key).
* 这种对应关系f为散列函数(哈希函数)。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或者哈希表。关键字对应的记录存储位置称为散列地址
* 存储位置=f(关键字)
* 散列冲突
    * f（key1） = f(key2),同一个关键字的计算的位置一样
* 散列函数要求
    * 计算简单，可以提高效率
    * 散列地址分布均匀，分布越均匀，散列冲突出现的概率越小
* 散列方法
    * 直接定址法
        * f(key) = a  * key + b
    * 数字分析法
    * 平方取中法
    * 折叠法
    * 除留余数法
    * 随机数法
* 解决散列冲突的方法
    * 开放定址法: 一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入
    * 再散列函数法: 冲突时更换新的散列函数
    * 链地址法: 如果发生冲突，桶位置上是一个链表结构，链表存储冲突的元素，缺点是查找时需要遍历链表
    * 公共溢出区法: 为所有冲突的关键字位置建立一个公共的溢出区来存放。查找时先在基表里面查找，找不到再到公共溢出区顺序查找

* 查找性能分析
    * 取决因素
        * 散列函数是否均匀，越均匀发生散列冲突概率越小
        * 处理散列冲突的方法
        * 散列表的装填因子
            * 装填因子=实际的元素数量/总数量，装填因子越大，散列冲突的概率越大

## 8.2. 跳表
<a href="#menu" >目录</a>

# 9. 排序算法
<a href="#menu" >目录</a>

## 9.1. 基本概念

* 内排序
    * 待排序的所有记录全部放置在内存中
* 外排序
    * 由于记录太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行
* 影响排序性能
    * 时间性能
    * 辅助空间
    * 算法的复杂性

## 9.2. 冒泡排序 Bubble Sort
<a href="#menu" >目录</a>

* 基本思路:两两比较相邻的数据，如果反序则交换，直到没有反序为止。

![](pic/算法/排序/冒泡排序.png)


```java
 //普通交换排序，不符合两两相邻比较
    public static int[] sort(int[] arr){

        for (int i = 0; i < arr.length-1; i++) {
            for (int j = i+1; j < arr.length; j++) {
                if(arr[i] <= arr[j]){
                    swap(arr, i, j);
                }
            }
        }
        return arr;
    }
    //冒泡排序
    public static int[] sort1(int[] arr){

        for (int i = 0; i < arr.length; i++) {
            for (int j = arr.length-1; j > i; j--) {
                if(arr[j-1] >= arr[j]){
                    swap(arr, j-1, j);
                }
            }
        }
        return arr;
    }
    //优化
    public static int[] sort2(int[] arr){

        boolean flag = true;
        for (int i = 0; i < arr.length && flag == true; i++) {            
            flag = false;
            for (int j = arr.length-1; j > i; j--) {
                if(arr[j-1] >= arr[j]){
                    swap(arr, j-1, j);
                    flag = true;
                }
            }
        }
        return arr;
    }
    public static void swap(int[] arr,int i , int j){        
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```
* 时间复杂度: f(n) = 1 + 2 + 3 + n = (n-1)* n /2 ,因此时间复杂度是O（n^2）。

## 9.3. 简单选择排序 Simple Selection Sort
<a href="#menu" >目录</a>

* 思路： 通过n-1次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<= i <= n）个记录作交换。就是循环一次找出当前最小值的坐标，然后将最小值和i位置进行交换。

时间复杂度是O（n^2）。相比与冒泡排序，减少了交换的次数。
```java
public static int[] sort(int[] arr){

        int min = 0;
        for (int i = 0; i < arr.length-1; i++) {
            min = i;
            for (int j = i+1; j < arr.length; j++) {
                 if(arr[j] < arr[min]){
                     min = j;
                 }
            }
            if(min != i){
                swap(arr, i, min);
            }
        }
        return arr;
    }
    public static void swap(int[] arr,int i , int j){
        
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;

    }
```
## 9.4. 直接插入排序 Straight Insertion Sort
<a href="#menu" >目录</a>

将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表
```
[8,2,4,5,1] 
第一次比较8和2,2比8小，2拿出来，8往后移动，2插入原来8的位置0,变成[2,8,4,5,1]，然后i++
第二次比较8和4,4比8小，4拿出来，8往后移动，由于4比2大，不会继续往前比较，4插入原来8的位置1,变成[2,4,8,5,1]，然后i++
```
基本有序的情况下，为O（n），平均情况下时间复杂度也是O(n^2)
```java
public static int[] sort(int[] arr){

        for (int i = 0; i < arr.length-1; i++) {
            if(arr[i] > arr[i+1]){
                int j=i+1;
                int data = arr[j];
                while(  (j > 0) && (arr[j-1]> data)){
                    arr[j] = arr[j-1];
                    j--;
                }            
                arr[j] = data;
            }
        }
        return arr;
    }
```


## 9.5. 希尔排序 Shell Sort
<a href="#menu" >目录</a>

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。

希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。

**代码实现**
```java
void shell_sort1(int a[], int n)
{
    int i,j,gap;

    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
        {
            for (j = i + gap; j < n; j += gap) 
            {
                // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
                if (a[j] < a[j - gap])
                {
                    int tmp = a[j];
                    int k = j - gap;
                    while (k >= 0 && a[k] > tmp)
                    {
                        a[k + gap] = a[k];
                        k -= gap;
                    }
                    a[k + gap] = tmp;
                }
            }
        }

    }
}
```

在上面的希尔排序中，首先要选取步长gap的值。选取了gap之后，就将数列分成了gap个组，对于每一个组都执行直接插入排序。在排序完所有的组之后，将gap的值减半；继续对数列进行分组，然后进行排序。重复这样的操作，直到gap<0为止。此时，数列也就是有序的了。

为了便于观察，我们将希尔排序中的直接插入排序独立出来，得到代码(二)。
```java
/*
 * 对希尔排序中的单个组进行排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组总的长度
 *     i -- 组的起始位置
 *     gap -- 组的步长
 *
 *  组是"从i开始，将相隔gap长度的数都取出"所组成的！
 */
void group_sort(int a[], int n, int i,int gap)
{
    int j;

    for (j = i + gap; j < n; j += gap) 
    {
        // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
        if (a[j] < a[j - gap])
        {
            int tmp = a[j];
            int k = j - gap;
            while (k >= 0 && a[k] > tmp)
            {
                a[k + gap] = a[k];
                k -= gap;
            }
            a[k + gap] = tmp;
        }
    }
}

/*
 * 希尔排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void shell_sort2(int a[], int n)
{
    int i,gap;

    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
            group_sort(a, n, i, gap);
    }
}

```
下面以数列{80,30,60,40,20,10,50,70}为例，演示它的希尔排序过程。

第1趟：(gap=4)
![希尔排序示意图1](pic/算法/排序/希尔排序示意图1.jpg)
当gap=4时,意味着将数列分为4个组： {80,20},{30,10},{60,50},{40,70}。 对应数列： {80,30,60,40,20,10,50,70}
对这4个组分别进行排序，排序结果： {20,80},{10,30},{50,60},{40,70}。 对应数列： {20,10,50,40,80,30,60,70}

第2趟：(gap=2)
![希尔排序示意图2](pic/算法/排序/希尔排序示意图2.jpg)
当gap=2时,意味着将数列分为2个组：{20,50,80,60}, {10,40,30,70}。 对应数列： {20,10,50,40,80,30,60,70}

* 注意
    * {20,50,80,60}实际上有两个有序的数列{20,80}和{50,60}组成。
    * {10,40,30,70}实际上有两个有序的数列{10,30}和{40,70}组成。
     
对这2个组分别进行排序，排序结果：{20,50,60,80}, {10,30,40,70}。 对应数列： {20,10,50,30,60,40,80,70}
 
第3趟：(gap=1)
![希尔排序示意图3](pic/算法/排序/希尔排序示意图3.jpg)
当gap=1时,意味着将数列分为1个组：{20,10,50,30,60,40,80,70}

注意：{20,10,50,30,60,40,80,70}实际上有两个有序的数列{20,50,60,80}和{10,30,40,70}组成。
对这1个组分别进行排序，排序结果：{10,20,30,40,50,60,70,80}

**分析**

最佳情况：T(n) = O(nlogn)。最坏情况：T(n) = O(n)。平均情况：T(n) = O(nlogn)。

希尔排序时间复杂度：
希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3/2)。

希尔排序稳定性
希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！


## 9.6. 堆排序
<a href="#menu" >目录</a>

## 9.7. 归并排序
<a href="#menu" >目录</a>

## 9.8. 快速排序 QuickSort
<a href="#menu" >目录</a>

* 基本思想
    * 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分进行排序，以达到整个序列有序的目的
    


## 9.9. 总结
<a href="#menu" >目录</a>

|排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
|---|---|---|---|---|---|
|冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|简单选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|稳定|
|直接插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|希尔排序|O(nlogn^2)~O(n^2)|O(n)|O(n^2)|O(1)|不稳定|
|堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定|
|归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|稳定|
|快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(logn  ~ O(n))|不稳定|

# 10. 算法精选
<a href="#menu" >目录</a>

## 10.1. 链表
<a href="#menu" >目录</a>

### 10.1.1. 如何反转一个单链表
<a href="#menu" >目录</a>

### 10.1.2. 判断链表中是否有环
<a href="#menu" >目录</a>

## 10.2. 堆栈，队列
<a href="#menu" >目录</a>

### 10.2.1. 判断括号字符串是否有效
<a href="#menu" >目录</a>

### 10.2.2. 用栈实现队列
<a href="#menu" >目录</a>

### 10.2.3. 用队列实现栈
<a href="#menu" >目录</a>

## 10.3. 优先队列
<a href="#menu" >目录</a>

### 10.3.1. 返回数据流中的第K大元素
### 10.3.2. 返回滑动窗口中的最大值

## 10.4. 哈希表
<a href="#menu" >目录</a>

### 10.4.1. 判断有效的字母异位词
### 10.4.2. 找出数组中和为目标值的两个数，三个数，四个数

## 10.5. 树
<a href="#menu" >目录</a>

### 10.5.1. 验证二叉搜索树
### 10.5.2. 二叉树的最近公共祖先
### 10.5.3. 二叉搜索树的最近公共祖先

## 10.6. 分治递归
<a href="#menu" >目录</a>

### 10.6.1. 实现计算x的n次幂函数
### 10.6.2. 找出数组中出现次数大于n/2的元素

## 10.7. 贪心算法
<a href="#menu" >目录</a>

### 10.7.1. 计算买股票的最佳时机

## 10.8. 广度优先搜索／深度优先搜索
<a href="#menu" >目录</a>

### 10.8.1. 二叉树层次遍历
### 10.8.2. 二叉树最大深度
### 10.8.3. 二叉树最小深度
### 10.8.4. 生成所有可能的有效括号组合

## 10.9. 剪枝
<a href="#menu" >目录</a>

### 10.9.1. 如何使Ｎ皇后彼此之间不能相互攻击
### 10.9.2. 判断数独是否有效
### 10.9.3. 解决数独问题

## 10.10. 二分查找
<a href="#menu" >目录</a>

### 10.10.1. 实现一个求解平方根的函数

## 10.11. 字典树
<a href="#menu" >目录</a>

### 10.11.1. 二维网格中的单词搜索问题
### 10.11.2. 实现一个字典树

## 10.12. 位运算
<a href="#menu" >目录</a>

### 10.12.1. 二进制数中的比特位统计问题
### 10.12.2. 判断一个数是否为2的幂次方
### 10.12.3. N皇后问题的另一种解法

## 10.13. 动态规划
<a href="#menu" >目录</a>

### 10.13.1. 爬楼梯问题
### 10.13.2. 三角形的最小路径和
### 10.13.3. 乘积最大子序列
### 10.13.4. 用动态规划解决买卖股票问题
### 10.13.5. 最长上升子序列
### 10.13.6. 不同面值硬笔的对换问题
### 10.13.7. 计算最短逻辑距离问题

## 10.14. 并查集
<a href="#menu" >目录</a>

### 10.14.1. 二维网格中小岛数量统计
### 10.14.2. 计算矩阵中的朋友圈总数

## 10.15. LRU缓存
<a href="#menu" >目录</a>

### 10.15.1. 设计一个LRU缓存

## 10.16. 布隆过滤器
<a href="#menu" >目录</a>


# 11. LeetCode

## 11.1. 数组
<a href="#menu" >目录</a>

### 11.1.1. 简单

<a href="#menu" >目录</a>

#### 11.1.1.1. 题目1:两数之和

```java
/**
 * 两数之和
 * 给定一个数组和一个目标值,返回和为目标值的两个数的数组位置
 * example: 
 *  Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1]

 */
public class Code1{
    class Solution {
        public int[] twoSum1(int[] nums, int target) { 
            int volume =1<<15; //1000 0000 0000 0000
            int bitMode = volume-1;//011111111111 
            int [] result =new int[volume];
            for (int i=0;i<nums.length;i++){
                int c = (target - nums[i]) & bitMode;
                System.out.println(c +  "  " + Integer.toBinaryString(c));
                if (result[c]!=0){
                    return new int[]{result[c]-1,i};
                }
                result[nums[i] & bitMode]=i+1;
            }
            return null;
        }
        //常规方法 慢
        public int[] twoSum(int[] nums, int target) {
            if(nums.length < 2){
                return  new int[]{};
            }
            int max = nums.length-1;
            for(int i  = 0; i < max;i++){
                int diff = target - nums[i];
                for(int index = i+1 ; index < nums.length ; index++){
                    if(diff == nums[index]){
                        return new int[]{i,index};
                    }    
                }
            }       
            return  new int[]{};
        } 
    }
}
```
#### 11.1.1.2. 题目26 RemoveDuplicates

```java
package leetcode.array;
/**
 * 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。
示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4.你不需要考虑数组中超出新长度后面的元素。
 */
class RemoveDuplicatesSolution {
    public int removeDuplicates(int[] nums) {
        int left = 0;
        int right = 1;
        if(nums == null )return  0;
        while(right < nums.length){
            //相同
            if(nums[left] !=  nums[right]){
                nums[++left]=nums[right];
            }
            right++;
        }
        return left+1;
    }
}

```
### 11.1.2. 中等
<a href="#menu" >目录</a>

### 11.1.3. 困难
<a href="#menu" >目录</a>

## 11.2. 动态规划
<a href="#menu" >目录</a>

### 11.2.1. 简单
<a href="#menu" >目录</a>

### 11.2.2. 中等
<a href="#menu" >目录</a>

### 11.2.3. 困难
<a href="#menu" >目录</a>

## 11.3. 数学
<a href="#menu" >目录</a>

### 11.3.1. 简单
<a href="#menu" >目录</a>

### 11.3.2. 中等
<a href="#menu" >目录</a>

### 11.3.3. 困难
<a href="#menu" >目录</a>

## 11.4. 字符串
<a href="#menu" >目录</a>

### 11.4.1. 简单
<a href="#menu" >目录</a>

#### 11.4.1.1. 题目13:字母转换数字

```java
/**
 * 罗马数字转整数
 * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I（1） 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X（10） 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C（100） 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:
输入: "III"
输出: 3

示例 2:
输入: "IV"
输出: 4

示例 3:
输入: "IX"
输出: 9

示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.

 */
class Solution {
    //I， V， X， L，C，D 和 M。
    public int romanToInt(String s) {

        char dst[]  = new char[s.length()];
        s.getChars(0, s.length(), dst, 0);

        int result = 0;
        int preNum = getValue(dst[0]);
        int index = 1;
        //从高位依次比较相邻的字母，一样或者前比后大的相加，前比后小的相减
        while(index < dst.length){            
            int num = getValue(dst[index]);
            result +=  (preNum >= num)?preNum:-preNum;
            preNum = num;
            index++;
        }
        result += preNum;
        return result;
    }

    private int getValue(char ch) {
        switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0;
        }
    }
}
```

#### 11.4.1.2. 题目67:二进制字符串相加

```java

/**
 * 给你两个二进制字符串，返回它们的和（用二进制表示） 输入为 非空 字符串且只包含数字 1 和 0。

示例 1:
输入: a = "11", b = "1"
输出: "100"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
 
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

 */
class Code67Solution {

    public String addBinary(String a, String b) {     

        int aIndex = a.length()-1;
        int bIndex = b.length()-1;

        int aVal = 0;
        int bVal = 0;
        int flag = 0;

        StringBuilder stringBuilder = new StringBuilder();
        while((aIndex >= 0) && (bIndex >= 0)){
            aVal = a.charAt(aIndex--)=='1'?1:0;
            bVal = b.charAt(bIndex--)=='1'?1:0; 
            int val = aVal+bVal+flag;
            stringBuilder.append(val%2==1?1:0);
            flag = val >>1;
        }
        //超出长度处理
        //a的长度较长
        if(aIndex >= 0){
            while(aIndex >= 0){
                aVal = a.charAt(aIndex--)=='1'?1:0;
                int val = aVal+flag;
                stringBuilder.append(val%2==1?1:0);
                flag = val >>1; 
            }
        }
        //b的长度较长
        else if(bIndex >= 0){
            while(bIndex >= 0){
                bVal = b.charAt(bIndex--)=='1'?1:0;
                int val = bVal+flag;
                stringBuilder.append(val%2==1?1:0);
                flag = val >>1; 
            }
        }
        //最高位还有进位
        if (flag == 1) {
            stringBuilder.append('1');
        } 

        return stringBuilder.reverse().toString();
    }

}
```
### 11.4.2. 中等
<a href="#menu" >目录</a>

### 11.4.3. 困难
<a href="#menu" >目录</a>

## 11.5. 树
<a href="#menu" >目录</a>

### 11.5.1. 简单
<a href="#menu" >目录</a>

### 11.5.2. 中等
<a href="#menu" >目录</a>

### 11.5.3. 困难
<a href="#menu" >目录</a>

## 11.6. 哈希表
<a href="#menu" >目录</a>

### 11.6.1. 简单
<a href="#menu" >目录</a>

### 11.6.2. 中等
<a href="#menu" >目录</a>

### 11.6.3. 困难
<a href="#menu" >目录</a>

## 11.7. 深度优先搜索
<a href="#menu" >目录</a>

### 11.7.1. 简单
<a href="#menu" >目录</a>

### 11.7.2. 中等
<a href="#menu" >目录</a>

### 11.7.3. 困难
<a href="#menu" >目录</a>

## 11.8. 二分查找
<a href="#menu" >目录</a>

### 11.8.1. 简单
<a href="#menu" >目录</a>

### 11.8.2. 中等
<a href="#menu" >目录</a>

### 11.8.3. 困难
<a href="#menu" >目录</a>

## 11.9. 贪心算法
<a href="#menu" >目录</a>

### 11.9.1. 简单
<a href="#menu" >目录</a>

### 11.9.2. 中等
<a href="#menu" >目录</a>

### 11.9.3. 困难
<a href="#menu" >目录</a>

## 11.10. 广度优先算法
<a href="#menu" >目录</a>

### 11.10.1. 简单
<a href="#menu" >目录</a>

### 11.10.2. 中等
<a href="#menu" >目录</a>

### 11.10.3. 困难
<a href="#menu" >目录</a>

## 11.11. 双指针
<a href="#menu" >目录</a>

### 11.11.1. 简单
<a href="#menu" >目录</a>

### 11.11.2. 中等
<a href="#menu" >目录</a>

### 11.11.3. 困难
<a href="#menu" >目录</a>

## 11.12. 栈
<a href="#menu" >目录</a>

### 11.12.1. 简单
<a href="#menu" >目录</a>

### 11.12.2. 中等
<a href="#menu" >目录</a>

### 11.12.3. 困难
<a href="#menu" >目录</a>

## 11.13. 回溯算法
<a href="#menu" >目录</a>

### 11.13.1. 简单
<a href="#menu" >目录</a>

### 11.13.2. 中等
<a href="#menu" >目录</a>

### 11.13.3. 困难
<a href="#menu" >目录</a>

## 11.14. 设计
<a href="#menu" >目录</a>

### 11.14.1. 简单
<a href="#menu" >目录</a>

### 11.14.2. 中等
<a href="#menu" >目录</a>

#### 11.14.2.1. 题目146:LRU缓存机制
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？
```java

/*
* 

* */
/*
* 方式１：　直接使用LinkedHashMap的removeEldestEntry实现，注意初始化时的accessOrder需要为true.当添加元素时，如果removeEldestEntry返回true,则删除队尾数据
* 　　mybatis中的lru缓存也是使用这种方式
* */
class LRUCache {

    private int cap;

    private LinkedHashMap<Integer,Integer> cache;

    public LRUCache(int cap){
        this.cap = cap;

        this.cache = new  LinkedHashMap<Integer,Integer>(cap,0.75f,true){
            @Override
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return this.size() > cap;
            }
        };
    }

    public int get(int key){
        Integer result =  this.cache.get(key);
        return result==null?-1:result;
    }
    public void put(int key, int val){
        this.cache.put(key,val);
    }
}
/**
 * 方式２: 自行实现双链表，数据存储在hashmap中，hashmap最优情况下可以实现O(1)读写。
*/
//运行18ms
class LRUCache1 {

    private class  Node{
        int key ;
        int value;
        Node next;
        Node pre;

        public Node(){}
        public Node(int key,int value){
            this.key = key;
            this.value = value;
        }

    }
    //热数据在head,冷数据在tail,超出大小删除tail数据
    //队头队尾并不存储有效数据
    private Node head ;
    private Node tail;
    //最大容量
    private int cap;
    //当前实际数据量
    private int size;
    private HashMap<Integer,Node> cache = new HashMap<>();

    public LRUCache1(int  cap){
        this.cap = cap;
        this.size  = 0;

        head = new Node();
        tail = new Node();

        head.next = tail;
        tail.pre = head;
    }

    public int get(int key){
        Node result = this.cache.get(key);
        //不存在，返回-1
        if(result == null){
            return -1;
        }
        //存在，移到队头
        moveToHead(result);
        return result.value;
    }
    public void put(int key, int val){

        Node node = this.cache.get(key);
        if(node == null){
            //数据不存在
            node = new Node(key,val);
            //添加到队头
            addToHead(node);
            //添加到缓存
            this.cache.put(key,node);
            size++;
            if(size > cap){
                //超出则移除
               Node removeNode =  removeFromTail();
               this.cache.remove(removeNode.key);
               size--;
            }

        }
        else {
            //数据存在
            node.value = val;
            moveToHead(node);
        }
    }

    //移动到队头
    private void moveToHead(Node node){
        removeNode(node);
        addToHead(node);
    }
    //删除元素
    private void removeNode(Node node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }
    //添加新元素到队头
    private void addToHead(Node node){
        node.next = head.next;
        node.next.pre = node;
        head.next = node;
        node.pre =  head;
    }
    //删除队尾元素
    private Node removeFromTail(){
        Node removeNode = tail.pre;
        removeNode(removeNode);
        return  removeNode;
    }
}

```


### 11.14.3. 困难
<a href="#menu" >目录</a>

## 11.15. 位运算
<a href="#menu" >目录</a>

### 11.15.1. 简单
<a href="#menu" >目录</a>

#### 11.15.1.1. 题目136:只出现一次的数字
<a href="#menu" >目录</a>

思路: a^a = 0;所有数字只出现一次的只有一个，剩下的都是出现两次，那么将所有元素异或的值就是单独的值
```java
/**
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
输入: [2,2,1]
输出: 1
示例 2:
输入: [4,1,2,1,2]
输出: 4
 */
class SingleNumberSolution {
    public int singleNumber(int[] nums) {
        //注意这里的初始化，不能为0，必须为数组中的元素
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            result ^= nums[i];
        }
        return result;
    }
}
```

#### 11.15.1.2. 题目169:多数元素
<a href="#menu" >目录</a>

```java
/**
 * 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素  你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1:
输入: [3,2,3]
输出: 3
示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2

解决思路:
摩尔投票法：
多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素，那么多数元素的数量一定大于其他元素的总数量
 3 x x 3 3
 3 3 3 x x
 这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。
 */

class MajorityElementSolution {
    public int majorityElement(int[] nums) {
       
        int count = 1;
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if(result == nums[i]){
                count++;
            }
            else if(--count == 0){
                result = nums[i];
                count = 1;
            }
        }
        return result;
    }
}
```
#### 11.15.1.3. 题目191:位1的个数
<a href="#menu" >目录</a>

这里需要注意，java中>>>和>>的区别
```
>> :右移运算符，num >> 1,相当于num除以2
>>>:无符号右移，忽略符号位，空位都以0补齐
```
由于有可能输入为负值，最高为符号位为1的情况，因此应该使用>>>
```java
/**
 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数
 */
 class HammingWeightSolution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n !=0){
            count += (n & 0x01);
            n = n>>>1;
        }
        return count;
    }
}
```
#### 11.15.1.4. 题目389:找不同
<a href="#menu" >目录</a>

```java
/**
 * 给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。
示例:
输入：
s = "abcd"
t = "abcde"
输出：
e
解释：
'e' 是那个被添加的字母。

解题思路: 同一个数异或为0，两个字符串中只有一个字符是单独的，因此其他字符异或之后为0，所有字符异或之后的值就是多出来的字符
        先把字符串转换成byte数组，再进行异或
 */
class FindTheDifferenceSolution {
    public char findTheDifference(String s, String t) {
        byte[] sByte = s.getBytes();
        byte[] tByte = t.getBytes();

        int minLen = sByte.length < tByte.length? sByte.length:tByte.length;
        int data = 0;
        for (int i = 0; i < minLen; i++) {
            data ^= sByte[i]^tByte[i];
        }
        if(minLen != sByte.length ){
            data ^= sByte[sByte.length-1];
        }
        else{
            data ^= tByte[tByte.length-1];
        }

        return (char)data;
    }
}

```

#### 11.15.1.5. 插入
<a href="#menu" >目录</a>

```java
/**
 * 插入。给定两个32位的整数N与M，以及表示比特位置的i与j。编写一种方法，将M插入N，使得M从N的第j位开始，到第i位结束。
 * 假定从j位到i位足以容纳M，也即若M = 10 011，那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。

示例1:

 输入：N = 10000000000, M = 10011, i = 2, j = 6
 输出：N = 10001001100
示例2:

 输入： N = 0, M = 11111, i = 0, j = 4
 输出：N = 11111

 解答思路:
 知识点：
num = 0b11101;
设置num第3位为0： num &= ~(1<<3); --> 0b11001
设置num第2位为1: num |= (1<<2); --> 0b11111

注意点：如果区间的长度[i,j]超过M的长度，剩余的要补0

 */
class InsertBitsSolution {
    public int insertBits(int N, int M, int i, int j) {
        while((i<=j)){
            int bit  = (M&0x01);
            N = (bit== 0)?N&(~(1<< i)):N|(1<< i);        
            M >>= 1;
            i++;
        }
        return N;
    }
}
```
#### 11.15.1.6. 整数转换
<a href="#menu" >目录</a>

```java
/**
 * 整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

示例1:

 输入：A = 29 （或者0b11101）, B = 15（或者0b01111）
 输出：2

 */
class ConvertIntegerSolution {
    public int convertInteger(int A, int B) {
        int result = 0;
        int data = A^B;
        while(data != 0){
            result += data&0x01;
            data >>>=1;            
        }
        return result;
    }
}
```
#### 11.15.1.7. 消失的数字
<a href="#menu" >目录</a>

```java
/**
 * 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
 * 
 * 思路： 同数值异或为0， 这个数组的值为0-n,也就是多出来的值被n替代
 * 
 * 原本数组: [0,1,2,3]
 * 实际数组: [0,4,2,3] ,可以看出所求的没有出现的数字是1
 * 以上所有数据全部异或= 1^4; 
 * 4即为数组的长度n
 * result = 1^4^n  = 1^4^4= 1.
 */

class MissingNumberSolution {
    public int missingNumber(int[] nums) {
        int result = 0;
        
        for (int i = 0; i < nums.length; i++) {
            result ^= i;
            result ^= nums[i];
        }
        result ^= nums.length;
        return result;
    }
}
```
### 11.15.2. 中等
<a href="#menu" >目录</a>

### 11.15.3. 困难
<a href="#menu" >目录</a>

## 11.16. 排序
<a href="#menu" >目录</a>

### 11.16.1. 简单
<a href="#menu" >目录</a>



### 11.16.2. 中等
<a href="#menu" >目录</a>

### 11.16.3. 困难
<a href="#menu" >目录</a>

## 11.17. 图
<a href="#menu" >目录</a>

### 11.17.1. 简单
<a href="#menu" >目录</a>

### 11.17.2. 中等
<a href="#menu" >目录</a>

### 11.17.3. 困难
<a href="#menu" >目录</a>

## 11.18. 链表
<a href="#menu" >目录</a>

### 11.18.1. 简单
<a href="#menu" >目录</a>

#### 11.18.1.1. 题目21:合并有序链表
```java

//常规方法

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

    if(l1 == null){
        return l2;
    }
    if(l2 == null){
        return l1;
    }
    ListNode temp = new ListNode(0);
    ListNode tail = temp ;

    while( l1!= null && l2 != null){
        if(l1.val < l2.val){
            tail.next = l1;
            l1 = l1.next;
        }
        else if(l1.val >= l2.val){
            tail.next = l2;
            l2 = l2.next;
        }

        tail = tail.next;
    }
    tail.next = l1==null?l2:l1;
    return temp.next;
}
//使用递归
public ListNode mergeTwoLists1(ListNode l1, ListNode l2) {

    if(l1 == null){
        return l2;
    }
    if(l2 == null){
        return l1;
    }
    if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next,l2);
        return l1;
    }
    else {
        l2.next =  mergeTwoLists(l1,l2.next);
        return l2;
    }
}
```
#### 11.18.1.2. 题目0202:返回倒数第 k 个节点
<a href="#menu" >目录</a>

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。输入： 1->2->3->4->5 和 k = 2

```java
//方式１：两次遍历
//先求出总长度length,再从头遍历length-k
public int kthToLast(ListNode head, int k) {
    int  length = 0;
    //任意赋值
    int diff = -1;
    ListNode temp = head;
    while(diff != 0){
        if(temp != null){
            temp = temp.next;
            length++;
            if(diff != - 1){
                diff--;
            }
        }
        else{
            diff = length-k;
            temp = head;
        }
    }
    return temp.val;
}
//方式2：快慢指针
//快指针先走k位置，慢指针再走，快指针走到尾节点时，慢指针就处于倒数k位置
public int kthToLast1(ListNode head, int k) {
    int step = 0;
    ListNode temp1 = head;
    ListNode temp2 = head;
    while(temp1 != null){
        temp1  = temp1.next;
        step++;
        if(step > k){
            temp2  = temp2.next;
        }
    }
    return temp2.val;
}
```
#### 11.18.1.3. 题目0207:链表相交
```java
/**
 * 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
 * 
 * 解决:双指针法,
 * 　链表A:  A---D---Ｃ
 * 　链表B:  B---D---C
 * 　两个链表假如有相交节点Ｄ，每条链的头结点先走完自己的链表长度,然后回头走另外的一条链表,那么两结点一定为相交于D点。
 * 　Ａ的走法: A->D->C->B->D ,走过的路程　AD+DC+BD,
 * 　Ｂ的走法: B->D->C->A->D ,走过的路程　BD+DC+AD,
 * 　两个走过的距离相同，必定相交与节点Ｄ。
 * 　如果第二次仍然走到尾节点，那么说明不存在相交节点，返回null
 */
class GetIntersectionNodeSolution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode listA = headA;
        ListNode listB = headB;

        int flag = 0;

        while(listA!=listB){
            if(listA != null){
                listA  =listA.next;
            }
            else{
                listA = headB;
                flag++;
            }

            if(listB != null){
                listB  =listB.next;
            }
            else{
                listB = headA;
                flag++;
            }
            if(flag > 2){
                return null;
            }
        }
        return listA;
    }
}
```

### 11.18.2. 中等
<a href="#menu" >目录</a>

### 11.18.3. 困难
<a href="#menu" >目录</a>

## 11.19. 堆
<a href="#menu" >目录</a>

### 11.19.1. 简单
<a href="#menu" >目录</a>

### 11.19.2. 中等
<a href="#menu" >目录</a>

### 11.19.3. 困难
<a href="#menu" >目录</a>

## 11.20. 并查集
<a href="#menu" >目录</a>

### 11.20.1. 简单
<a href="#menu" >目录</a>

### 11.20.2. 中等
<a href="#menu" >目录</a>

### 11.20.3. 困难
<a href="#menu" >目录</a>

## 11.21. Ｓliding Window
<a href="#menu" >目录</a>

### 11.21.1. 简单
<a href="#menu" >目录</a>

### 11.21.2. 中等
<a href="#menu" >目录</a>

### 11.21.3. 困难
<a href="#menu" >目录</a>

## 11.22. 分治算法
<a href="#menu" >目录</a>

### 11.22.1. 简单
<a href="#menu" >目录</a>

### 11.22.2. 中等
<a href="#menu" >目录</a>

### 11.22.3. 困难
<a href="#menu" >目录</a>

## 11.23. 字典树
<a href="#menu" >目录</a>

### 11.23.1. 简单
<a href="#menu" >目录</a>

### 11.23.2. 中等
<a href="#menu" >目录</a>

### 11.23.3. 困难
<a href="#menu" >目录</a>

## 11.24. 递归
<a href="#menu" >目录</a>

### 11.24.1. 简单
<a href="#menu" >目录</a>

### 11.24.2. 中等
<a href="#menu" >目录</a>

### 11.24.3. 困难
<a href="#menu" >目录</a>

## 11.25. 线段树
<a href="#menu" >目录</a>

### 11.25.1. 简单
<a href="#menu" >目录</a>

### 11.25.2. 中等
<a href="#menu" >目录</a>

### 11.25.3. 困难
<a href="#menu" >目录</a>

## 11.26. Ordered Map
<a href="#menu" >目录</a>

### 11.26.1. 简单
<a href="#menu" >目录</a>

### 11.26.2. 中等
<a href="#menu" >目录</a>

### 11.26.3. 困难
<a href="#menu" >目录</a>

## 11.27. 队列
<a href="#menu" >目录</a>

### 11.27.1. 简单
<a href="#menu" >目录</a>

### 11.27.2. 中等
<a href="#menu" >目录</a>

### 11.27.3. 困难
<a href="#menu" >目录</a>

## 11.28. 极小化极大
<a href="#menu" >目录</a>

### 11.28.1. 简单
<a href="#menu" >目录</a>

### 11.28.2. 中等
<a href="#menu" >目录</a>

### 11.28.3. 困难
<a href="#menu" >目录</a>

## 11.29. 树状数组
<a href="#menu" >目录</a>

### 11.29.1. 简单
<a href="#menu" >目录</a>

### 11.29.2. 中等
<a href="#menu" >目录</a>

### 11.29.3. 困难
<a href="#menu" >目录</a>

## 11.30. Line　Ｓweep
<a href="#menu" >目录</a>

### 11.30.1. 简单
<a href="#menu" >目录</a>

### 11.30.2. 中等
<a href="#menu" >目录</a>

### 11.30.3. 困难
<a href="#menu" >目录</a>

## 11.31. Random
<a href="#menu" >目录</a>

### 11.31.1. 简单
<a href="#menu" >目录</a>

### 11.31.2. 中等
<a href="#menu" >目录</a>

**470	用 Rand7() 实现 Rand10()**	

已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

* 示例 1:
```
输入: 1
输出: [7]
```
* 示例 2:
```
输入: 2
输出: [8,4]
```
* 示例 3:
```
输入: 3
输出: [8,1,10]
```

* 提示:
    * rand7 已定义。
    * 传入参数: n 表示 rand10 的调用次数。
* 进阶:
    * rand7()调用次数的 期望值 是多少 ?
    * 你能否尽量少调用 rand7() ?

* 解决思路
这是一道概率题 计算两个rand7()和的个位，两个数用a b表示，即( rand7() + rand7() ) % 10

枚举如下：
```
	a	1	2	3	4	5	6	7
b								
1		2	3	4	5	6	7	8
2		3	4	5	6	7	8	9
3		4	5	6	7	8	9	0
4		5	6	7	8	9	0	1
5		6	7	8	9	0	1	2
6		7	8	9	0	1	2	3
7		8	9	0	1	2	3	4

```
去掉右上角的
```  
6	7	8
7	8	9
8	9	0 
```
后

每个数字的出现次数为4次，0-9的概率相同

所以程序思路就很明了,当结果扫到右上角的时候进行递归调用，直到输出其他结果
```
    a=rand7();  b=rand7();
 if(a>4&&b<4)  return rand10();
 else          return (a+b)%10+1;
```

平均调用2.45次rand7()
(
PS:解释一下为什么是2.45............拉开看
分布列如下：调用次数为1次，P=40/49；2次P=(9/49)*(40/49);    3次P=(9/49)^2*(40/49); ............N次 P=(9/49)^（n-1）*(40/49)；
平均调用次数为期望==（次数*概率）求和==1*40/49+2*(9/49)*(40/49)+(9/49)^2*(40/49)+...............+n*(9/49)^（n-1）*(40/49);
求出后结果为2*49/40=2.45
)


**478	在圆内随机生成点**

给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。

说明:

输入值和输出值都将是浮点数。
圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
圆周上的点也认为是在圆中。
randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。
示例 1：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
示例 2：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-random-point-in-a-circle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**497	非重叠矩形中的随机点**

给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。

* 提示：
```
整数点是具有整数坐标的点。
矩形周边上的点包含在矩形覆盖的空间中。
第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。
每个矩形的长度和宽度不超过 2000。
1 <= rects.length <= 100
pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。
pick 最多被调用10000次。
```

* 示例 1：

```
输入: 
["Solution","pick","pick","pick"]
[[[[1,1,5,5]]],[],[],[]]
输出: 
[null,[4,1],[4,1],[3,3]]
```
* 示例 2：
```
输入: 
["Solution","pick","pick","pick","pick","pick"]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]
```

* 输入语法的说明：
输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。



**519	随机翻转矩阵**

题中给出一个 n 行 n 列的二维矩阵 (n_rows,n_cols)，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。

注意:

1.1 <= n_rows, n_cols <= 10000

2. 0 <= row.id < n_rows 并且 0 <= col.id < n_cols

3.当矩阵中没有值为 0 时，不可以调用 flip 函数

4.调用 flip 和 reset 函数的次数加起来不会超过 1000 次

示例 1：

输入: 
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
输出: [null,[0,1],[1,2],[1,0],[1,1]]
示例 2：

输入: 
["Solution","flip","flip","reset","flip"]
[[1,2],[],[],[],[]]
输出: [null,[0,0],[0,1],null,[0,0]]
输入语法解释：

输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip 和 reset 没有参数，参数总会以列表形式给出，哪怕该列表为空


**528	按权重随机选择**	

给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。

说明:

1 <= w.length <= 10000
1 <= w[i] <= 10^5
pickIndex 将被调用不超过 10000 次
示例1:

输入: 
["Solution","pickIndex"]
[[[1]],[]]
输出: [null,0]
示例2:

输入: 
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出: [null,0,1,1,1,0]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。


### 11.31.3. 困难
<a href="#menu" >目录</a>

**710	黑名单中的随机数**	

给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。

对它进行优化使其尽量少调用系统方法 Math.random() 。

* 提示:
```
1 <= N <= 1000000000
0 <= B.length < min(100000, N)
[0, N) 不包含 N，详细参见 interval notation 。
```
* 示例 1:
输入: 
```
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
输出: [null,0,0,0]
```

* 示例 2:
输入:
``` 
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
输出: [null,1,1,1]
```
* 示例 3:
输入: 
```
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]
```
* 示例 4:

输入: 

```
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
输出: [null,1,3,1]
```

* 输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表

* 解决思路

正常情况下 如果随机了一个数 这个数在黑名单中 那么需要重新随机一个数; 问题是 怎么能够减少随机的次数

换句话说：如何处理能够在随机到黑名单中的值时 仍然能够将这个黑名单值转化为正常值

思路: 在[0,N)中有b个黑名单值， 我们可以在[0,N-b)的范围内取随机数
假设在【0，N-b】内有x个黑名单值 那么在[N-b,N)肯定有x个白名单值(非黑名单)

把这x个黑名单 和x个白名单一一对应 可以用map

那么 当取随机数r时 如果这个r在黑名单中 我们可以不需要再次进行取随机数 只要取map中r对应的白名单值就可以了

* 代码

```java
class Solution {
public:
	int nowSize;//修改后的N
	unordered_map<int, int> hashMap;//映射hash表
	Solution(int N, vector<int>& blacklist) {
		int blacklistSize = blacklist.size();
		nowSize = N - blacklistSize;
		int startNum = nowSize;//扫描在[N - blacklistSize, N)中非黑名单中的数据
		set<int> mySet(blacklist.begin(), blacklist.end());
		auto it = mySet.begin();//扫描黑名单中在[0, N - blacklistSize)的数据
		while (it != mySet.end() && *it < nowSize) {
			while (mySet.find(startNum) != mySet.end()) {
				++startNum;
			}
            //将在[0, N - blacklistSize)中的黑名单的数据一一映射到[N - blacklistSize, N)中非黑名单中的数据
			hashMap[*(it++)] = startNum++;
		}
	}

	int pick() {
		int randNum = rand() % nowSize;//随机生成[0, N - blacklistSize)
		if (hashMap.count(randNum)) {
            //如果randNum在hash表中，说明它是黑名单中的数据，需要修改为它映射的数据
			return hashMap[randNum];
		}
		else {
            //否则直接返回
			return randNum;
		}
	}
};
```

**710**
## 11.32. 拓扑排序
<a href="#menu" >目录</a>

### 11.32.1. 简单
<a href="#menu" >目录</a>

### 11.32.2. 中等
<a href="#menu" >目录</a>

### 11.32.3. 困难
<a href="#menu" >目录</a>

## 11.33. 脑筋急转弯
<a href="#menu" >目录</a>

### 11.33.1. 简单
<a href="#menu" >目录</a>

### 11.33.2. 中等
<a href="#menu" >目录</a>

### 11.33.3. 困难
<a href="#menu" >目录</a>

## 11.34. 几何
<a href="#menu" >目录</a>

### 11.34.1. 简单
<a href="#menu" >目录</a>

### 11.34.2. 中等
<a href="#menu" >目录</a>

### 11.34.3. 困难
<a href="#menu" >目录</a>

## 11.35. 二叉搜索树
<a href="#menu" >目录</a>

### 11.35.1. 简单
<a href="#menu" >目录</a>

### 11.35.2. 中等
<a href="#menu" >目录</a>

### 11.35.3. 困难
<a href="#menu" >目录</a>

## 11.36. Rejection Sampling
<a href="#menu" >目录</a>

### 11.36.1. 简单
<a href="#menu" >目录</a>

### 11.36.2. 中等
<a href="#menu" >目录</a>

### 11.36.3. 困难
<a href="#menu" >目录</a>

## 11.37. 蓄水池搜样
<a href="#menu" >目录</a>

### 11.37.1. 简单
<a href="#menu" >目录</a>

### 11.37.2. 中等
<a href="#menu" >目录</a>

### 11.37.3. 困难
<a href="#menu" >目录</a>

## 11.38. 记忆化
<a href="#menu" >目录</a>

### 11.38.1. 简单
<a href="#menu" >目录</a>

### 11.38.2. 中等
<a href="#menu" >目录</a>

### 11.38.3. 困难
<a href="#menu" >目录</a>


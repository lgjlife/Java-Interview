<span id="menu"></span>
<!-- TOC -->

- [1. 数据结构绪论](#1-数据结构绪论)
- [2. 算法](#2-算法)
- [3. 线性表](#3-线性表)
- [4. 栈和队列](#4-栈和队列)
- [5. 字符串](#5-字符串)
- [6. 树](#6-树)
- [7. 图](#7-图)
- [8. 其他数据结构](#8-其他数据结构)
    - [8.1. 跳表](#81-跳表)
- [9. 查找](#9-查找)
- [10. 排序算法](#10-排序算法)
- [11. LeetCode](#11-leetcode)
    - [11.1. 数组](#111-数组)
        - [11.1.1. 简单](#1111-简单)
            - [11.1.1.1. 题目1:两数之和](#11111-题目1两数之和)
        - [11.1.2. 中等](#1112-中等)
        - [11.1.3. 困难](#1113-困难)
    - [11.2. 动态规划](#112-动态规划)
        - [11.2.1. 简单](#1121-简单)
        - [11.2.2. 中等](#1122-中等)
        - [11.2.3. 困难](#1123-困难)
    - [11.3. 数学](#113-数学)
        - [11.3.1. 简单](#1131-简单)
        - [11.3.2. 中等](#1132-中等)
        - [11.3.3. 困难](#1133-困难)
    - [11.4. 字符串](#114-字符串)
        - [11.4.1. 简单](#1141-简单)
        - [11.4.2. 中等](#1142-中等)
        - [11.4.3. 困难](#1143-困难)
    - [11.5. 树](#115-树)
        - [11.5.1. 简单](#1151-简单)
        - [11.5.2. 中等](#1152-中等)
        - [11.5.3. 困难](#1153-困难)
    - [11.6. 哈希表](#116-哈希表)
        - [11.6.1. 简单](#1161-简单)
        - [11.6.2. 中等](#1162-中等)
        - [11.6.3. 困难](#1163-困难)
    - [11.7. 深度优先搜索](#117-深度优先搜索)
        - [11.7.1. 简单](#1171-简单)
        - [11.7.2. 中等](#1172-中等)
        - [11.7.3. 困难](#1173-困难)
    - [11.8. 二分查找](#118-二分查找)
        - [11.8.1. 简单](#1181-简单)
        - [11.8.2. 中等](#1182-中等)
        - [11.8.3. 困难](#1183-困难)
    - [11.9. 贪心算法](#119-贪心算法)
        - [11.9.1. 简单](#1191-简单)
        - [11.9.2. 中等](#1192-中等)
        - [11.9.3. 困难](#1193-困难)
    - [11.10. 广度优先算法](#1110-广度优先算法)
        - [11.10.1. 简单](#11101-简单)
        - [11.10.2. 中等](#11102-中等)
        - [11.10.3. 困难](#11103-困难)
    - [11.11. 双指针](#1111-双指针)
        - [11.11.1. 简单](#11111-简单)
        - [11.11.2. 中等](#11112-中等)
        - [11.11.3. 困难](#11113-困难)
    - [11.12. 栈](#1112-栈)
        - [11.12.1. 简单](#11121-简单)
        - [11.12.2. 中等](#11122-中等)
        - [11.12.3. 困难](#11123-困难)
    - [11.13. 回溯算法](#1113-回溯算法)
        - [11.13.1. 简单](#11131-简单)
        - [11.13.2. 中等](#11132-中等)
        - [11.13.3. 困难](#11133-困难)
    - [11.14. 设计](#1114-设计)
        - [11.14.1. 简单](#11141-简单)
        - [11.14.2. 中等](#11142-中等)
        - [11.14.3. 困难](#11143-困难)
    - [11.15. 位运算](#1115-位运算)
        - [11.15.1. 简单](#11151-简单)
        - [11.15.2. 中等](#11152-中等)
        - [11.15.3. 困难](#11153-困难)
    - [11.16. 排序](#1116-排序)
        - [11.16.1. 简单](#11161-简单)
        - [11.16.2. 中等](#11162-中等)
        - [11.16.3. 困难](#11163-困难)
    - [11.17. 图](#1117-图)
        - [11.17.1. 简单](#11171-简单)
        - [11.17.2. 中等](#11172-中等)
        - [11.17.3. 困难](#11173-困难)
    - [11.18. 链表](#1118-链表)
        - [11.18.1. 简单](#11181-简单)
        - [11.18.2. 中等](#11182-中等)
        - [11.18.3. 困难](#11183-困难)
    - [11.19. 堆](#1119-堆)
        - [11.19.1. 简单](#11191-简单)
        - [11.19.2. 中等](#11192-中等)
        - [11.19.3. 困难](#11193-困难)
    - [11.20. 并查集](#1120-并查集)
        - [11.20.1. 简单](#11201-简单)
        - [11.20.2. 中等](#11202-中等)
        - [11.20.3. 困难](#11203-困难)
    - [11.21. Ｓliding Window](#1121-ｓliding-window)
        - [11.21.1. 简单](#11211-简单)
        - [11.21.2. 中等](#11212-中等)
        - [11.21.3. 困难](#11213-困难)
    - [11.22. 分治算法](#1122-分治算法)
        - [11.22.1. 简单](#11221-简单)
        - [11.22.2. 中等](#11222-中等)
        - [11.22.3. 困难](#11223-困难)
    - [11.23. 字典树](#1123-字典树)
        - [11.23.1. 简单](#11231-简单)
        - [11.23.2. 中等](#11232-中等)
        - [11.23.3. 困难](#11233-困难)
    - [11.24. 递归](#1124-递归)
        - [11.24.1. 简单](#11241-简单)
        - [11.24.2. 中等](#11242-中等)
        - [11.24.3. 困难](#11243-困难)
    - [11.25. 线段树](#1125-线段树)
        - [11.25.1. 简单](#11251-简单)
        - [11.25.2. 中等](#11252-中等)
        - [11.25.3. 困难](#11253-困难)
    - [11.26. Ordered Map](#1126-ordered-map)
        - [11.26.1. 简单](#11261-简单)
        - [11.26.2. 中等](#11262-中等)
        - [11.26.3. 困难](#11263-困难)
    - [11.27. 队列](#1127-队列)
        - [11.27.1. 简单](#11271-简单)
        - [11.27.2. 中等](#11272-中等)
        - [11.27.3. 困难](#11273-困难)
    - [11.28. 极小化极大](#1128-极小化极大)
        - [11.28.1. 简单](#11281-简单)
        - [11.28.2. 中等](#11282-中等)
        - [11.28.3. 困难](#11283-困难)
    - [11.29. 树状数组](#1129-树状数组)
        - [11.29.1. 简单](#11291-简单)
        - [11.29.2. 中等](#11292-中等)
        - [11.29.3. 困难](#11293-困难)
    - [11.30. Line　Ｓweep](#1130-line　ｓweep)
        - [11.30.1. 简单](#11301-简单)
        - [11.30.2. 中等](#11302-中等)
        - [11.30.3. 困难](#11303-困难)
    - [11.31. Random](#1131-random)
        - [11.31.1. 简单](#11311-简单)
        - [11.31.2. 中等](#11312-中等)
        - [11.31.3. 困难](#11313-困难)
    - [11.32. 拓扑排序](#1132-拓扑排序)
        - [11.32.1. 简单](#11321-简单)
        - [11.32.2. 中等](#11322-中等)
        - [11.32.3. 困难](#11323-困难)
    - [11.33. 脑筋急转弯](#1133-脑筋急转弯)
        - [11.33.1. 简单](#11331-简单)
        - [11.33.2. 中等](#11332-中等)
        - [11.33.3. 困难](#11333-困难)
    - [11.34. 几何](#1134-几何)
        - [11.34.1. 简单](#11341-简单)
        - [11.34.2. 中等](#11342-中等)
        - [11.34.3. 困难](#11343-困难)
    - [11.35. 二叉搜索树](#1135-二叉搜索树)
        - [11.35.1. 简单](#11351-简单)
        - [11.35.2. 中等](#11352-中等)
        - [11.35.3. 困难](#11353-困难)
    - [11.36. Rejection Sampling](#1136-rejection-sampling)
        - [11.36.1. 简单](#11361-简单)
        - [11.36.2. 中等](#11362-中等)
        - [11.36.3. 困难](#11363-困难)
    - [11.37. 蓄水池搜样](#1137-蓄水池搜样)
        - [11.37.1. 简单](#11371-简单)
        - [11.37.2. 中等](#11372-中等)
        - [11.37.3. 困难](#11373-困难)
    - [11.38. 记忆化](#1138-记忆化)
        - [11.38.1. 简单](#11381-简单)
        - [11.38.2. 中等](#11382-中等)
        - [11.38.3. 困难](#11383-困难)

<!-- /TOC -->

# 1. 数据结构绪论
<a href="#menu" >目录</a>

# 2. 算法
<a href="#menu" >目录</a>

# 3. 线性表
<a href="#menu" >目录</a>

# 4. 栈和队列
<a href="#menu" >目录</a>

# 5. 字符串
<a href="#menu" >目录</a>

# 6. 树
<a href="#menu" >目录</a>

# 7. 图
<a href="#menu" >目录</a>

# 8. 其他数据结构
<a href="#menu" >目录</a>

## 8.1. 跳表
<a href="#menu" >目录</a>

# 9. 查找
<a href="#menu" >目录</a>



# 10. 排序算法
<a href="#menu" >目录</a>

# 11. LeetCode

## 11.1. 数组
<a href="#menu" >目录</a>

### 11.1.1. 简单

<a href="#menu" >目录</a>

#### 11.1.1.1. 题目1:两数之和

```java
/**
 * 两数之和
 * 给定一个数组和一个目标值,返回和为目标值的两个数的数组位置
 * example: 
 *  Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1]

 */
public class Code1{
    class Solution {
        public int[] twoSum1(int[] nums, int target) { 
            int volume =1<<15; //1000 0000 0000 0000
            int bitMode = volume-1;//011111111111 
            int [] result =new int[volume];
            for (int i=0;i<nums.length;i++){
                int c = (target - nums[i]) & bitMode;
                System.out.println(c +  "  " + Integer.toBinaryString(c));
                if (result[c]!=0){
                    return new int[]{result[c]-1,i};
                }
                result[nums[i] & bitMode]=i+1;
            }
            return null;
        }
        //常规方法 慢
        public int[] twoSum(int[] nums, int target) {
            if(nums.length < 2){
                return  new int[]{};
            }
            int max = nums.length-1;
            for(int i  = 0; i < max;i++){
                int diff = target - nums[i];
                for(int index = i+1 ; index < nums.length ; index++){
                    if(diff == nums[index]){
                        return new int[]{i,index};
                    }    
                }
            }       
            return  new int[]{};
        } 
    }
}
```

### 11.1.2. 中等
<a href="#menu" >目录</a>

### 11.1.3. 困难
<a href="#menu" >目录</a>

## 11.2. 动态规划
<a href="#menu" >目录</a>

### 11.2.1. 简单
<a href="#menu" >目录</a>

### 11.2.2. 中等
<a href="#menu" >目录</a>

### 11.2.3. 困难
<a href="#menu" >目录</a>

## 11.3. 数学
<a href="#menu" >目录</a>

### 11.3.1. 简单
<a href="#menu" >目录</a>

### 11.3.2. 中等
<a href="#menu" >目录</a>

### 11.3.3. 困难
<a href="#menu" >目录</a>

## 11.4. 字符串
<a href="#menu" >目录</a>

### 11.4.1. 简单
<a href="#menu" >目录</a>

### 11.4.2. 中等
<a href="#menu" >目录</a>

### 11.4.3. 困难
<a href="#menu" >目录</a>

## 11.5. 树
<a href="#menu" >目录</a>

### 11.5.1. 简单
<a href="#menu" >目录</a>

### 11.5.2. 中等
<a href="#menu" >目录</a>

### 11.5.3. 困难
<a href="#menu" >目录</a>

## 11.6. 哈希表
<a href="#menu" >目录</a>

### 11.6.1. 简单
<a href="#menu" >目录</a>

### 11.6.2. 中等
<a href="#menu" >目录</a>

### 11.6.3. 困难
<a href="#menu" >目录</a>

## 11.7. 深度优先搜索
<a href="#menu" >目录</a>

### 11.7.1. 简单
<a href="#menu" >目录</a>

### 11.7.2. 中等
<a href="#menu" >目录</a>

### 11.7.3. 困难
<a href="#menu" >目录</a>

## 11.8. 二分查找
<a href="#menu" >目录</a>

### 11.8.1. 简单
<a href="#menu" >目录</a>

### 11.8.2. 中等
<a href="#menu" >目录</a>

### 11.8.3. 困难
<a href="#menu" >目录</a>

## 11.9. 贪心算法
<a href="#menu" >目录</a>

### 11.9.1. 简单
<a href="#menu" >目录</a>

### 11.9.2. 中等
<a href="#menu" >目录</a>

### 11.9.3. 困难
<a href="#menu" >目录</a>

## 11.10. 广度优先算法
<a href="#menu" >目录</a>

### 11.10.1. 简单
<a href="#menu" >目录</a>

### 11.10.2. 中等
<a href="#menu" >目录</a>

### 11.10.3. 困难
<a href="#menu" >目录</a>

## 11.11. 双指针
<a href="#menu" >目录</a>

### 11.11.1. 简单
<a href="#menu" >目录</a>

### 11.11.2. 中等
<a href="#menu" >目录</a>

### 11.11.3. 困难
<a href="#menu" >目录</a>

## 11.12. 栈
<a href="#menu" >目录</a>

### 11.12.1. 简单
<a href="#menu" >目录</a>

### 11.12.2. 中等
<a href="#menu" >目录</a>

### 11.12.3. 困难
<a href="#menu" >目录</a>

## 11.13. 回溯算法
<a href="#menu" >目录</a>

### 11.13.1. 简单
<a href="#menu" >目录</a>

### 11.13.2. 中等
<a href="#menu" >目录</a>

### 11.13.3. 困难
<a href="#menu" >目录</a>

## 11.14. 设计
<a href="#menu" >目录</a>

### 11.14.1. 简单
<a href="#menu" >目录</a>

### 11.14.2. 中等
<a href="#menu" >目录</a>

### 11.14.3. 困难
<a href="#menu" >目录</a>

## 11.15. 位运算
<a href="#menu" >目录</a>

### 11.15.1. 简单
<a href="#menu" >目录</a>

### 11.15.2. 中等
<a href="#menu" >目录</a>

### 11.15.3. 困难
<a href="#menu" >目录</a>

## 11.16. 排序
<a href="#menu" >目录</a>

### 11.16.1. 简单
<a href="#menu" >目录</a>

### 11.16.2. 中等
<a href="#menu" >目录</a>

### 11.16.3. 困难
<a href="#menu" >目录</a>

## 11.17. 图
<a href="#menu" >目录</a>

### 11.17.1. 简单
<a href="#menu" >目录</a>

### 11.17.2. 中等
<a href="#menu" >目录</a>

### 11.17.3. 困难
<a href="#menu" >目录</a>

## 11.18. 链表
<a href="#menu" >目录</a>

### 11.18.1. 简单
<a href="#menu" >目录</a>

### 11.18.2. 中等
<a href="#menu" >目录</a>

### 11.18.3. 困难
<a href="#menu" >目录</a>

## 11.19. 堆
<a href="#menu" >目录</a>

### 11.19.1. 简单
<a href="#menu" >目录</a>

### 11.19.2. 中等
<a href="#menu" >目录</a>

### 11.19.3. 困难
<a href="#menu" >目录</a>

## 11.20. 并查集
<a href="#menu" >目录</a>

### 11.20.1. 简单
<a href="#menu" >目录</a>

### 11.20.2. 中等
<a href="#menu" >目录</a>

### 11.20.3. 困难
<a href="#menu" >目录</a>

## 11.21. Ｓliding Window
<a href="#menu" >目录</a>

### 11.21.1. 简单
<a href="#menu" >目录</a>

### 11.21.2. 中等
<a href="#menu" >目录</a>

### 11.21.3. 困难
<a href="#menu" >目录</a>

## 11.22. 分治算法
<a href="#menu" >目录</a>

### 11.22.1. 简单
<a href="#menu" >目录</a>

### 11.22.2. 中等
<a href="#menu" >目录</a>

### 11.22.3. 困难
<a href="#menu" >目录</a>

## 11.23. 字典树
<a href="#menu" >目录</a>

### 11.23.1. 简单
<a href="#menu" >目录</a>

### 11.23.2. 中等
<a href="#menu" >目录</a>

### 11.23.3. 困难
<a href="#menu" >目录</a>

## 11.24. 递归
<a href="#menu" >目录</a>

### 11.24.1. 简单
<a href="#menu" >目录</a>

### 11.24.2. 中等
<a href="#menu" >目录</a>

### 11.24.3. 困难
<a href="#menu" >目录</a>

## 11.25. 线段树
<a href="#menu" >目录</a>

### 11.25.1. 简单
<a href="#menu" >目录</a>

### 11.25.2. 中等
<a href="#menu" >目录</a>

### 11.25.3. 困难
<a href="#menu" >目录</a>

## 11.26. Ordered Map
<a href="#menu" >目录</a>

### 11.26.1. 简单
<a href="#menu" >目录</a>

### 11.26.2. 中等
<a href="#menu" >目录</a>

### 11.26.3. 困难
<a href="#menu" >目录</a>

## 11.27. 队列
<a href="#menu" >目录</a>

### 11.27.1. 简单
<a href="#menu" >目录</a>

### 11.27.2. 中等
<a href="#menu" >目录</a>

### 11.27.3. 困难
<a href="#menu" >目录</a>

## 11.28. 极小化极大
<a href="#menu" >目录</a>

### 11.28.1. 简单
<a href="#menu" >目录</a>

### 11.28.2. 中等
<a href="#menu" >目录</a>

### 11.28.3. 困难
<a href="#menu" >目录</a>

## 11.29. 树状数组
<a href="#menu" >目录</a>

### 11.29.1. 简单
<a href="#menu" >目录</a>

### 11.29.2. 中等
<a href="#menu" >目录</a>

### 11.29.3. 困难
<a href="#menu" >目录</a>

## 11.30. Line　Ｓweep
<a href="#menu" >目录</a>

### 11.30.1. 简单
<a href="#menu" >目录</a>

### 11.30.2. 中等
<a href="#menu" >目录</a>

### 11.30.3. 困难
<a href="#menu" >目录</a>

## 11.31. Random
<a href="#menu" >目录</a>

### 11.31.1. 简单
<a href="#menu" >目录</a>

### 11.31.2. 中等
<a href="#menu" >目录</a>

**470	用 Rand7() 实现 Rand10()**	

已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

* 示例 1:
```
输入: 1
输出: [7]
```
* 示例 2:
```
输入: 2
输出: [8,4]
```
* 示例 3:
```
输入: 3
输出: [8,1,10]
```

* 提示:
    * rand7 已定义。
    * 传入参数: n 表示 rand10 的调用次数。
* 进阶:
    * rand7()调用次数的 期望值 是多少 ?
    * 你能否尽量少调用 rand7() ?

* 解决思路
这是一道概率题 计算两个rand7()和的个位，两个数用a b表示，即( rand7() + rand7() ) % 10

枚举如下：
```
	a	1	2	3	4	5	6	7
b								
1		2	3	4	5	6	7	8
2		3	4	5	6	7	8	9
3		4	5	6	7	8	9	0
4		5	6	7	8	9	0	1
5		6	7	8	9	0	1	2
6		7	8	9	0	1	2	3
7		8	9	0	1	2	3	4

```
去掉右上角的
```  
6	7	8
7	8	9
8	9	0 
```
后

每个数字的出现次数为4次，0-9的概率相同

所以程序思路就很明了,当结果扫到右上角的时候进行递归调用，直到输出其他结果
```
    a=rand7();  b=rand7();
 if(a>4&&b<4)  return rand10();
 else          return (a+b)%10+1;
```

平均调用2.45次rand7()
(
PS:解释一下为什么是2.45............拉开看
分布列如下：调用次数为1次，P=40/49；2次P=(9/49)*(40/49);    3次P=(9/49)^2*(40/49); ............N次 P=(9/49)^（n-1）*(40/49)；
平均调用次数为期望==（次数*概率）求和==1*40/49+2*(9/49)*(40/49)+(9/49)^2*(40/49)+...............+n*(9/49)^（n-1）*(40/49);
求出后结果为2*49/40=2.45
)


**478	在圆内随机生成点**

给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。

说明:

输入值和输出值都将是浮点数。
圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
圆周上的点也认为是在圆中。
randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。
示例 1：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
示例 2：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-random-point-in-a-circle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**497	非重叠矩形中的随机点**

给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。

* 提示：
```
整数点是具有整数坐标的点。
矩形周边上的点包含在矩形覆盖的空间中。
第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。
每个矩形的长度和宽度不超过 2000。
1 <= rects.length <= 100
pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。
pick 最多被调用10000次。
```

* 示例 1：

```
输入: 
["Solution","pick","pick","pick"]
[[[[1,1,5,5]]],[],[],[]]
输出: 
[null,[4,1],[4,1],[3,3]]
```
* 示例 2：
```
输入: 
["Solution","pick","pick","pick","pick","pick"]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]
```

* 输入语法的说明：
输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。



**519	随机翻转矩阵**

题中给出一个 n 行 n 列的二维矩阵 (n_rows,n_cols)，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。

注意:

1.1 <= n_rows, n_cols <= 10000

2. 0 <= row.id < n_rows 并且 0 <= col.id < n_cols

3.当矩阵中没有值为 0 时，不可以调用 flip 函数

4.调用 flip 和 reset 函数的次数加起来不会超过 1000 次

示例 1：

输入: 
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
输出: [null,[0,1],[1,2],[1,0],[1,1]]
示例 2：

输入: 
["Solution","flip","flip","reset","flip"]
[[1,2],[],[],[],[]]
输出: [null,[0,0],[0,1],null,[0,0]]
输入语法解释：

输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip 和 reset 没有参数，参数总会以列表形式给出，哪怕该列表为空


**528	按权重随机选择**	

给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。

说明:

1 <= w.length <= 10000
1 <= w[i] <= 10^5
pickIndex 将被调用不超过 10000 次
示例1:

输入: 
["Solution","pickIndex"]
[[[1]],[]]
输出: [null,0]
示例2:

输入: 
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出: [null,0,1,1,1,0]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。


### 11.31.3. 困难
<a href="#menu" >目录</a>

**710	黑名单中的随机数**	

给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。

对它进行优化使其尽量少调用系统方法 Math.random() 。

* 提示:
```
1 <= N <= 1000000000
0 <= B.length < min(100000, N)
[0, N) 不包含 N，详细参见 interval notation 。
```
* 示例 1:
输入: 
```
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
输出: [null,0,0,0]
```

* 示例 2:
输入:
``` 
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
输出: [null,1,1,1]
```
* 示例 3:
输入: 
```
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]
```
* 示例 4:

输入: 

```
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
输出: [null,1,3,1]
```

* 输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表

* 解决思路

正常情况下 如果随机了一个数 这个数在黑名单中 那么需要重新随机一个数; 问题是 怎么能够减少随机的次数

换句话说：如何处理能够在随机到黑名单中的值时 仍然能够将这个黑名单值转化为正常值

思路: 在[0,N)中有b个黑名单值， 我们可以在[0,N-b)的范围内取随机数
假设在【0，N-b】内有x个黑名单值 那么在[N-b,N)肯定有x个白名单值(非黑名单)

把这x个黑名单 和x个白名单一一对应 可以用map

那么 当取随机数r时 如果这个r在黑名单中 我们可以不需要再次进行取随机数 只要取map中r对应的白名单值就可以了

* 代码

```java
class Solution {
public:
	int nowSize;//修改后的N
	unordered_map<int, int> hashMap;//映射hash表
	Solution(int N, vector<int>& blacklist) {
		int blacklistSize = blacklist.size();
		nowSize = N - blacklistSize;
		int startNum = nowSize;//扫描在[N - blacklistSize, N)中非黑名单中的数据
		set<int> mySet(blacklist.begin(), blacklist.end());
		auto it = mySet.begin();//扫描黑名单中在[0, N - blacklistSize)的数据
		while (it != mySet.end() && *it < nowSize) {
			while (mySet.find(startNum) != mySet.end()) {
				++startNum;
			}
            //将在[0, N - blacklistSize)中的黑名单的数据一一映射到[N - blacklistSize, N)中非黑名单中的数据
			hashMap[*(it++)] = startNum++;
		}
	}

	int pick() {
		int randNum = rand() % nowSize;//随机生成[0, N - blacklistSize)
		if (hashMap.count(randNum)) {
            //如果randNum在hash表中，说明它是黑名单中的数据，需要修改为它映射的数据
			return hashMap[randNum];
		}
		else {
            //否则直接返回
			return randNum;
		}
	}
};
```

**710**
## 11.32. 拓扑排序
<a href="#menu" >目录</a>

### 11.32.1. 简单
<a href="#menu" >目录</a>

### 11.32.2. 中等
<a href="#menu" >目录</a>

### 11.32.3. 困难
<a href="#menu" >目录</a>

## 11.33. 脑筋急转弯
<a href="#menu" >目录</a>

### 11.33.1. 简单
<a href="#menu" >目录</a>

### 11.33.2. 中等
<a href="#menu" >目录</a>

### 11.33.3. 困难
<a href="#menu" >目录</a>

## 11.34. 几何
<a href="#menu" >目录</a>

### 11.34.1. 简单
<a href="#menu" >目录</a>

### 11.34.2. 中等
<a href="#menu" >目录</a>

### 11.34.3. 困难
<a href="#menu" >目录</a>

## 11.35. 二叉搜索树
<a href="#menu" >目录</a>

### 11.35.1. 简单
<a href="#menu" >目录</a>

### 11.35.2. 中等
<a href="#menu" >目录</a>

### 11.35.3. 困难
<a href="#menu" >目录</a>

## 11.36. Rejection Sampling
<a href="#menu" >目录</a>

### 11.36.1. 简单
<a href="#menu" >目录</a>

### 11.36.2. 中等
<a href="#menu" >目录</a>

### 11.36.3. 困难
<a href="#menu" >目录</a>

## 11.37. 蓄水池搜样
<a href="#menu" >目录</a>

### 11.37.1. 简单
<a href="#menu" >目录</a>

### 11.37.2. 中等
<a href="#menu" >目录</a>

### 11.37.3. 困难
<a href="#menu" >目录</a>

## 11.38. 记忆化
<a href="#menu" >目录</a>

### 11.38.1. 简单
<a href="#menu" >目录</a>

### 11.38.2. 中等
<a href="#menu" >目录</a>

### 11.38.3. 困难
<a href="#menu" >目录</a>


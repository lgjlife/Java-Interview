<span id="menu"></span>
<!-- TOC -->

- [1. 数据结构绪论](#1-数据结构绪论)
- [2. 算法](#2-算法)
- [3. 线性表](#3-线性表)
- [4. 栈和队列](#4-栈和队列)
- [5. 字符串](#5-字符串)
    - [5.1. KMP算法](#51-kmp算法)
- [6. 树](#6-树)
- [7. 图](#7-图)
- [8. 其他数据结构](#8-其他数据结构)
    - [8.1. 跳表](#81-跳表)
- [9. 查找](#9-查找)
    - [9.1. 散列表](#91-散列表)
    - [9.2. 跳表](#92-跳表)
- [10. 排序算法](#10-排序算法)
    - [基本概念](#基本概念)
    - [10.1. 冒泡排序 Bubble Sort](#101-冒泡排序-bubble-sort)
    - [10.2. 简单选择排序 Simple Selection Sort](#102-简单选择排序-simple-selection-sort)
    - [10.3. 直接插入排序 Straight Insertion Sort](#103-直接插入排序-straight-insertion-sort)
    - [10.4. 希尔排序 Shell Sort](#104-希尔排序-shell-sort)
    - [10.5. 堆排序](#105-堆排序)
    - [10.6. 归并排序](#106-归并排序)
    - [10.7. 快速排序 QuickSort](#107-快速排序-quicksort)
    - [10.8. 总结](#108-总结)
- [11. LeetCode](#11-leetcode)
    - [11.1. 数组](#111-数组)
        - [11.1.1. 简单](#1111-简单)
            - [11.1.1.1. 题目1:两数之和](#11111-题目1两数之和)
            - [11.1.1.2. 题目26 RemoveDuplicates](#11112-题目26-removeduplicates)
        - [11.1.2. 中等](#1112-中等)
        - [11.1.3. 困难](#1113-困难)
    - [11.2. 动态规划](#112-动态规划)
        - [11.2.1. 简单](#1121-简单)
        - [11.2.2. 中等](#1122-中等)
        - [11.2.3. 困难](#1123-困难)
    - [11.3. 数学](#113-数学)
        - [11.3.1. 简单](#1131-简单)
        - [11.3.2. 中等](#1132-中等)
        - [11.3.3. 困难](#1133-困难)
    - [11.4. 字符串](#114-字符串)
        - [11.4.1. 简单](#1141-简单)
            - [11.4.1.1. 题目13:字母转换数字](#11411-题目13字母转换数字)
            - [11.4.1.2. 题目67:二进制字符串相加](#11412-题目67二进制字符串相加)
        - [11.4.2. 中等](#1142-中等)
        - [11.4.3. 困难](#1143-困难)
    - [11.5. 树](#115-树)
        - [11.5.1. 简单](#1151-简单)
        - [11.5.2. 中等](#1152-中等)
        - [11.5.3. 困难](#1153-困难)
    - [11.6. 哈希表](#116-哈希表)
        - [11.6.1. 简单](#1161-简单)
        - [11.6.2. 中等](#1162-中等)
        - [11.6.3. 困难](#1163-困难)
    - [11.7. 深度优先搜索](#117-深度优先搜索)
        - [11.7.1. 简单](#1171-简单)
        - [11.7.2. 中等](#1172-中等)
        - [11.7.3. 困难](#1173-困难)
    - [11.8. 二分查找](#118-二分查找)
        - [11.8.1. 简单](#1181-简单)
        - [11.8.2. 中等](#1182-中等)
        - [11.8.3. 困难](#1183-困难)
    - [11.9. 贪心算法](#119-贪心算法)
        - [11.9.1. 简单](#1191-简单)
        - [11.9.2. 中等](#1192-中等)
        - [11.9.3. 困难](#1193-困难)
    - [11.10. 广度优先算法](#1110-广度优先算法)
        - [11.10.1. 简单](#11101-简单)
        - [11.10.2. 中等](#11102-中等)
        - [11.10.3. 困难](#11103-困难)
    - [11.11. 双指针](#1111-双指针)
        - [11.11.1. 简单](#11111-简单)
        - [11.11.2. 中等](#11112-中等)
        - [11.11.3. 困难](#11113-困难)
    - [11.12. 栈](#1112-栈)
        - [11.12.1. 简单](#11121-简单)
        - [11.12.2. 中等](#11122-中等)
        - [11.12.3. 困难](#11123-困难)
    - [11.13. 回溯算法](#1113-回溯算法)
        - [11.13.1. 简单](#11131-简单)
        - [11.13.2. 中等](#11132-中等)
        - [11.13.3. 困难](#11133-困难)
    - [11.14. 设计](#1114-设计)
        - [11.14.1. 简单](#11141-简单)
        - [11.14.2. 中等](#11142-中等)
        - [11.14.3. 困难](#11143-困难)
    - [11.15. 位运算](#1115-位运算)
        - [11.15.1. 简单](#11151-简单)
            - [11.15.1.1. 题目136:只出现一次的数字](#111511-题目136只出现一次的数字)
            - [11.15.1.2. 题目169:多数元素](#111512-题目169多数元素)
            - [11.15.1.3. 题目191:位1的个数](#111513-题目191位1的个数)
            - [11.15.1.4. 题目389:找不同](#111514-题目389找不同)
            - [11.15.1.5. 插入](#111515-插入)
            - [11.15.1.6. 整数转换](#111516-整数转换)
            - [11.15.1.7. 消失的数字](#111517-消失的数字)
        - [11.15.2. 中等](#11152-中等)
        - [11.15.3. 困难](#11153-困难)
    - [11.16. 排序](#1116-排序)
        - [11.16.1. 简单](#11161-简单)
        - [11.16.2. 中等](#11162-中等)
        - [11.16.3. 困难](#11163-困难)
    - [11.17. 图](#1117-图)
        - [11.17.1. 简单](#11171-简单)
        - [11.17.2. 中等](#11172-中等)
        - [11.17.3. 困难](#11173-困难)
    - [11.18. 链表](#1118-链表)
        - [11.18.1. 简单](#11181-简单)
        - [11.18.2. 中等](#11182-中等)
        - [11.18.3. 困难](#11183-困难)
    - [11.19. 堆](#1119-堆)
        - [11.19.1. 简单](#11191-简单)
        - [11.19.2. 中等](#11192-中等)
        - [11.19.3. 困难](#11193-困难)
    - [11.20. 并查集](#1120-并查集)
        - [11.20.1. 简单](#11201-简单)
        - [11.20.2. 中等](#11202-中等)
        - [11.20.3. 困难](#11203-困难)
    - [11.21. Ｓliding Window](#1121-ｓliding-window)
        - [11.21.1. 简单](#11211-简单)
        - [11.21.2. 中等](#11212-中等)
        - [11.21.3. 困难](#11213-困难)
    - [11.22. 分治算法](#1122-分治算法)
        - [11.22.1. 简单](#11221-简单)
        - [11.22.2. 中等](#11222-中等)
        - [11.22.3. 困难](#11223-困难)
    - [11.23. 字典树](#1123-字典树)
        - [11.23.1. 简单](#11231-简单)
        - [11.23.2. 中等](#11232-中等)
        - [11.23.3. 困难](#11233-困难)
    - [11.24. 递归](#1124-递归)
        - [11.24.1. 简单](#11241-简单)
        - [11.24.2. 中等](#11242-中等)
        - [11.24.3. 困难](#11243-困难)
    - [11.25. 线段树](#1125-线段树)
        - [11.25.1. 简单](#11251-简单)
        - [11.25.2. 中等](#11252-中等)
        - [11.25.3. 困难](#11253-困难)
    - [11.26. Ordered Map](#1126-ordered-map)
        - [11.26.1. 简单](#11261-简单)
        - [11.26.2. 中等](#11262-中等)
        - [11.26.3. 困难](#11263-困难)
    - [11.27. 队列](#1127-队列)
        - [11.27.1. 简单](#11271-简单)
        - [11.27.2. 中等](#11272-中等)
        - [11.27.3. 困难](#11273-困难)
    - [11.28. 极小化极大](#1128-极小化极大)
        - [11.28.1. 简单](#11281-简单)
        - [11.28.2. 中等](#11282-中等)
        - [11.28.3. 困难](#11283-困难)
    - [11.29. 树状数组](#1129-树状数组)
        - [11.29.1. 简单](#11291-简单)
        - [11.29.2. 中等](#11292-中等)
        - [11.29.3. 困难](#11293-困难)
    - [11.30. Line　Ｓweep](#1130-line　ｓweep)
        - [11.30.1. 简单](#11301-简单)
        - [11.30.2. 中等](#11302-中等)
        - [11.30.3. 困难](#11303-困难)
    - [11.31. Random](#1131-random)
        - [11.31.1. 简单](#11311-简单)
        - [11.31.2. 中等](#11312-中等)
        - [11.31.3. 困难](#11313-困难)
    - [11.32. 拓扑排序](#1132-拓扑排序)
        - [11.32.1. 简单](#11321-简单)
        - [11.32.2. 中等](#11322-中等)
        - [11.32.3. 困难](#11323-困难)
    - [11.33. 脑筋急转弯](#1133-脑筋急转弯)
        - [11.33.1. 简单](#11331-简单)
        - [11.33.2. 中等](#11332-中等)
        - [11.33.3. 困难](#11333-困难)
    - [11.34. 几何](#1134-几何)
        - [11.34.1. 简单](#11341-简单)
        - [11.34.2. 中等](#11342-中等)
        - [11.34.3. 困难](#11343-困难)
    - [11.35. 二叉搜索树](#1135-二叉搜索树)
        - [11.35.1. 简单](#11351-简单)
        - [11.35.2. 中等](#11352-中等)
        - [11.35.3. 困难](#11353-困难)
    - [11.36. Rejection Sampling](#1136-rejection-sampling)
        - [11.36.1. 简单](#11361-简单)
        - [11.36.2. 中等](#11362-中等)
        - [11.36.3. 困难](#11363-困难)
    - [11.37. 蓄水池搜样](#1137-蓄水池搜样)
        - [11.37.1. 简单](#11371-简单)
        - [11.37.2. 中等](#11372-中等)
        - [11.37.3. 困难](#11373-困难)
    - [11.38. 记忆化](#1138-记忆化)
        - [11.38.1. 简单](#11381-简单)
        - [11.38.2. 中等](#11382-中等)
        - [11.38.3. 困难](#11383-困难)

<!-- /TOC -->

# 1. 数据结构绪论
<a href="#menu" >目录</a>

* 数据结构
    * 是相互之间存在一种或者多种的特定关系的数据集合

* 逻辑结构
    * 是指数据对象中数据元素之间的相互关系
    * 分类
        * 集合结构
        * 线性结构
        * 树形结构
        * 图形结构
    * 物理结构
        * 是指数据的逻辑结构在计算机中的存储形式
        * 顺序存储结构
            * 地址连续
        * 链式存储结构
            * 地址不一定连续
# 2. 算法
<a href="#menu" >目录</a>

* 算法
    * 算法是解决特定问题的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作
* 算法特性
    * 输入输出
        * 算法具有零个或者多个输入
        * 算法至少有一个或者多个输出
    * 有穷性
        * 指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且一个步骤在可接受的时间内完成
    * 确定性
        * 算法的每一个步骤都具有确定的含义，不会出现二义性
    * 可行性
        * 算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限的次数完成

* 算法设计要求
    * 正确性
        * 算法至少应该具有输入，输出和加工处理无歧义性，能够正确反映问题的需求，能够得到问题的正确答案
    * 可读性
        * 算法设计的另一个目的是为了便于阅读，理解和交流
    * 健壮性
        * 当输入数据不合法时，算法也能作出相关处理，而不是产生异常或者莫名奇妙的结果
    * 时间效率高和存储量低
* 算法效率的度量方法
    * 事后统计
        * 比如通过测试运行时间进行对比
    * 事前分析估算  
        * 决定因素
            * 算法采用的策略
            * 编译产生的代码质量
            * 问题的输入和输出
            * 机器执行指令的速度

* 推导大O阶方法
    * 用常数1取代运行时间中的所有加法常数
    * 在修改后的运行次数函数中，只保留最高阶
    * 如果高阶项存在且不是1,则去除与这个项相乘的常数，得到的结果就是大O阶

* 大O阶分类
    * 常数阶: O(1)
    * 线性阶: O(n)
    * 对数阶: O(log2^n)
    * 平方阶: O(n^2)
    * 立方阶: O(n^3)
![算法时间复杂度](pic/算法/基本概念/算法时间复杂度.png)

* 对算法的分析，一种是计算所有情况的平均值，这种计算方法称为平均时间复杂度。另一种是计算最坏情况下的时间复杂度，这种称为最坏时间复杂度。


# 3. 线性表
<a href="#menu" >目录</a>

* 线性表顺序存储结构
    * 用一段地址连续的存储单元依次存储线性表的数据元素
    * 优点
        * 无需为表示表中元素之间的逻辑关系而增加额外的存储空间 
        * 可以快速地存取表中任意位置的元素 
    * 缺点
        * 插入和删除需要移动大量的元素
        * 当线性表长度变化比较大时，难以确定存储空间的容量
        * 造成存储空间的碎片
* 线性表链式存储结构
    * 用一组任意存储单元存储线性表中的元素，这些存储单元可以是连续的，也可以是不连续的
    * 链式存储结构除存储元素本身的信息外，还需要存储指向其他元素的地址的信息
    * 优点
        * 添加，删除不需要移动大量的元素
        * 不需要预先分配存储空间，用多少分配多少。
    * 缺点
        * 不能O（1）读取或者设置任意位置的元素

**单向链表**

![单向链表](pic/算法/链表/单向链表.png)

**双向链表**

![双向链表](pic/算法/链表/双向链表.png)

**循环链表**

![循环链表](pic/算法/链表/循环链表.png)

# 4. 栈和队列
<a href="#menu" >目录</a>

* 栈 stack
    * 基本概念 
        * 限定仅在表尾进行插入和删除操作的线性表
        * 栈的两端分别为栈底和栈顶
        * 栈的插入操作，叫做进栈。也称压栈，入栈
        * 栈的删除操作，叫做出栈/弹栈
    * 栈的基本方法：
        * empty()  如果栈为空返回true，否则返回false  
        * size()   返回栈中元素的个数  
        * pop()    删除栈顶元素但不返回其值  
        * top()    返回栈顶的元素，但不删除该元素  
        * push()   在栈顶压入新元素  

* 队列 queue
    * 只允许在一端进行插入操作，而在另一端进行删除操作的线性表
    * 队列是一种先进先出(First In First Out)的线性表(FIFO) ,允许插入的一端称为队尾，允许删除的一端称为队头。
    * 队列的基本方法：
        * q.empty()    如果队列为空返回true，否则返回false  
        * size()       返回队列中元素的个数  
        * pop()        删除队列首元素但不返回其值  
        * front()      返回队首元素的值，但不删除该元素  
        * push()       在队尾压入新元素  
        * back()       返回队列尾元素的值，但不删除该元素
# 5. 字符串
<a href="#menu" >目录</a>


## 5.1. KMP算法
<a href="#menu" >目录</a>



# 6. 树
<a href="#menu" >目录</a>

# 7. 图
<a href="#menu" >目录</a>

# 8. 其他数据结构
<a href="#menu" >目录</a>

## 8.1. 跳表
<a href="#menu" >目录</a>

# 9. 查找
<a href="#menu" >目录</a>


## 9.1. 散列表

<a href="#menu" >目录</a>

* 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key).查找时，根据这个确定的对应关系找到给定值key的映射f(key).
* 这种对应关系f为散列函数(哈希函数)。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或者哈希表。关键字对应的记录存储位置称为散列地址
* 存储位置=f(关键字)
* 散列冲突
    * f（key1） = f(key2),同一个关键字的计算的位置一样
* 散列函数要求
    * 计算简单，可以提高效率
    * 散列地址分布均匀，分布越均匀，散列冲突出现的概率越小
* 散列方法
    * 直接定址法
        * f(key) = a  * key + b
    * 数字分析法
    * 平方取中法
    * 折叠法
    * 除留余数法
    * 随机数法
* 解决散列冲突的方法
    * 开放定址法: 一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入
    * 再散列函数法: 冲突时更换新的散列函数
    * 链地址法: 如果发生冲突，桶位置上是一个链表结构，链表存储冲突的元素，缺点是查找时需要遍历链表
    * 公共溢出区法: 为所有冲突的关键字位置建立一个公共的溢出区来存放。查找时先在基表里面查找，找不到再到公共溢出区顺序查找

* 查找性能分析
    * 取决因素
        * 散列函数是否均匀，越均匀发生散列冲突概率越小
        * 处理散列冲突的方法
        * 散列表的装填因子
            * 装填因子=实际的元素数量/总数量，装填因子越大，散列冲突的概率越大

## 9.2. 跳表
<a href="#menu" >目录</a>

# 10. 排序算法
<a href="#menu" >目录</a>

## 基本概念

* 内排序
    * 待排序的所有记录全部放置在内存中
* 外排序
    * 由于记录太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行
* 影响排序性能
    * 时间性能
    * 辅助空间
    * 算法的复杂性

## 10.1. 冒泡排序 Bubble Sort
<a href="#menu" >目录</a>

* 基本思路:两两比较相邻的数据，如果反序则交换，直到没有反序为止。

![](pic/算法/排序/冒泡排序.png)


```java
 //普通交换排序，不符合两两相邻比较
    public static int[] sort(int[] arr){

        for (int i = 0; i < arr.length-1; i++) {
            for (int j = i+1; j < arr.length; j++) {
                if(arr[i] <= arr[j]){
                    swap(arr, i, j);
                }
            }
        }
        return arr;
    }
    //冒泡排序
    public static int[] sort1(int[] arr){

        for (int i = 0; i < arr.length; i++) {
            for (int j = arr.length-1; j > i; j--) {
                if(arr[j-1] >= arr[j]){
                    swap(arr, j-1, j);
                }
            }
        }
        return arr;
    }
    //优化
    public static int[] sort2(int[] arr){

        boolean flag = true;
        for (int i = 0; i < arr.length && flag == true; i++) {            
            flag = false;
            for (int j = arr.length-1; j > i; j--) {
                if(arr[j-1] >= arr[j]){
                    swap(arr, j-1, j);
                    flag = true;
                }
            }
        }
        return arr;
    }
    public static void swap(int[] arr,int i , int j){        
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```
* 时间复杂度: f(n) = 1 + 2 + 3 + n = (n-1)* n /2 ,因此时间复杂度是O（n^2）。

## 10.2. 简单选择排序 Simple Selection Sort
<a href="#menu" >目录</a>

* 思路： 通过n-1次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<= i <= n）个记录作交换。就是循环一次找出当前最小值的坐标，然后将最小值和i位置进行交换。

时间复杂度是O（n^2）。相比与冒泡排序，减少了交换的次数。
```java
public static int[] sort(int[] arr){

        int min = 0;
        for (int i = 0; i < arr.length-1; i++) {
            min = i;
            for (int j = i+1; j < arr.length; j++) {
                 if(arr[j] < arr[min]){
                     min = j;
                 }
            }
            if(min != i){
                swap(arr, i, min);
            }
        }
        return arr;
    }
    public static void swap(int[] arr,int i , int j){
        
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;

    }
```
## 10.3. 直接插入排序 Straight Insertion Sort
<a href="#menu" >目录</a>

将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表
```
[8,2,4,5,1] 
第一次比较8和2,2比8小，2拿出来，8往后移动，2插入原来8的位置0,变成[2,8,4,5,1]，然后i++
第二次比较8和4,4比8小，4拿出来，8往后移动，由于4比2大，不会继续往前比较，4插入原来8的位置1,变成[2,4,8,5,1]，然后i++
```
基本有序的情况下，为O（n），平均情况下时间复杂度也是O(n^2)
```java
public static int[] sort(int[] arr){

        for (int i = 0; i < arr.length-1; i++) {
            if(arr[i] > arr[i+1]){
                int j=i+1;
                int data = arr[j];
                while(  (j > 0) && (arr[j-1]> data)){
                    arr[j] = arr[j-1];
                    j--;
                }            
                arr[j] = data;
            }
        }
        return arr;
    }
```


## 10.4. 希尔排序 Shell Sort
<a href="#menu" >目录</a>

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。

希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。

**代码实现**
```java
void shell_sort1(int a[], int n)
{
    int i,j,gap;

    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
        {
            for (j = i + gap; j < n; j += gap) 
            {
                // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
                if (a[j] < a[j - gap])
                {
                    int tmp = a[j];
                    int k = j - gap;
                    while (k >= 0 && a[k] > tmp)
                    {
                        a[k + gap] = a[k];
                        k -= gap;
                    }
                    a[k + gap] = tmp;
                }
            }
        }

    }
}
```

在上面的希尔排序中，首先要选取步长gap的值。选取了gap之后，就将数列分成了gap个组，对于每一个组都执行直接插入排序。在排序完所有的组之后，将gap的值减半；继续对数列进行分组，然后进行排序。重复这样的操作，直到gap<0为止。此时，数列也就是有序的了。

为了便于观察，我们将希尔排序中的直接插入排序独立出来，得到代码(二)。
```java
/*
 * 对希尔排序中的单个组进行排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组总的长度
 *     i -- 组的起始位置
 *     gap -- 组的步长
 *
 *  组是"从i开始，将相隔gap长度的数都取出"所组成的！
 */
void group_sort(int a[], int n, int i,int gap)
{
    int j;

    for (j = i + gap; j < n; j += gap) 
    {
        // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
        if (a[j] < a[j - gap])
        {
            int tmp = a[j];
            int k = j - gap;
            while (k >= 0 && a[k] > tmp)
            {
                a[k + gap] = a[k];
                k -= gap;
            }
            a[k + gap] = tmp;
        }
    }
}

/*
 * 希尔排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void shell_sort2(int a[], int n)
{
    int i,gap;

    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
            group_sort(a, n, i, gap);
    }
}

```
下面以数列{80,30,60,40,20,10,50,70}为例，演示它的希尔排序过程。

第1趟：(gap=4)
![希尔排序示意图1](pic/算法/排序/希尔排序示意图1.jpg)
当gap=4时,意味着将数列分为4个组： {80,20},{30,10},{60,50},{40,70}。 对应数列： {80,30,60,40,20,10,50,70}
对这4个组分别进行排序，排序结果： {20,80},{10,30},{50,60},{40,70}。 对应数列： {20,10,50,40,80,30,60,70}

第2趟：(gap=2)
![希尔排序示意图2](pic/算法/排序/希尔排序示意图2.jpg)
当gap=2时,意味着将数列分为2个组：{20,50,80,60}, {10,40,30,70}。 对应数列： {20,10,50,40,80,30,60,70}

* 注意
    * {20,50,80,60}实际上有两个有序的数列{20,80}和{50,60}组成。
    * {10,40,30,70}实际上有两个有序的数列{10,30}和{40,70}组成。
     
对这2个组分别进行排序，排序结果：{20,50,60,80}, {10,30,40,70}。 对应数列： {20,10,50,30,60,40,80,70}
 
第3趟：(gap=1)
![希尔排序示意图3](pic/算法/排序/希尔排序示意图3.jpg)
当gap=1时,意味着将数列分为1个组：{20,10,50,30,60,40,80,70}

注意：{20,10,50,30,60,40,80,70}实际上有两个有序的数列{20,50,60,80}和{10,30,40,70}组成。
对这1个组分别进行排序，排序结果：{10,20,30,40,50,60,70,80}

**分析**

最佳情况：T(n) = O(nlogn)。最坏情况：T(n) = O(n)。平均情况：T(n) = O(nlogn)。

希尔排序时间复杂度：
希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3/2)。

希尔排序稳定性
希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！


## 10.5. 堆排序
<a href="#menu" >目录</a>

## 10.6. 归并排序
<a href="#menu" >目录</a>

## 10.7. 快速排序 QuickSort
<a href="#menu" >目录</a>

* 基本思想
    * 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分进行排序，以达到整个序列有序的目的
    


## 10.8. 总结
<a href="#menu" >目录</a>

|排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
|---|---|---|---|---|---|
|冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|简单选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|稳定|
|直接插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
|希尔排序|O(nlogn^2)~O(n^2)|O(n)|O(n^2)|O(1)|不稳定|
|堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定|
|归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|稳定|
|快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(logn  ~ O(n))|不稳定|
# 11. LeetCode

## 11.1. 数组
<a href="#menu" >目录</a>

### 11.1.1. 简单

<a href="#menu" >目录</a>

#### 11.1.1.1. 题目1:两数之和

```java
/**
 * 两数之和
 * 给定一个数组和一个目标值,返回和为目标值的两个数的数组位置
 * example: 
 *  Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1]

 */
public class Code1{
    class Solution {
        public int[] twoSum1(int[] nums, int target) { 
            int volume =1<<15; //1000 0000 0000 0000
            int bitMode = volume-1;//011111111111 
            int [] result =new int[volume];
            for (int i=0;i<nums.length;i++){
                int c = (target - nums[i]) & bitMode;
                System.out.println(c +  "  " + Integer.toBinaryString(c));
                if (result[c]!=0){
                    return new int[]{result[c]-1,i};
                }
                result[nums[i] & bitMode]=i+1;
            }
            return null;
        }
        //常规方法 慢
        public int[] twoSum(int[] nums, int target) {
            if(nums.length < 2){
                return  new int[]{};
            }
            int max = nums.length-1;
            for(int i  = 0; i < max;i++){
                int diff = target - nums[i];
                for(int index = i+1 ; index < nums.length ; index++){
                    if(diff == nums[index]){
                        return new int[]{i,index};
                    }    
                }
            }       
            return  new int[]{};
        } 
    }
}
```
#### 11.1.1.2. 题目26 RemoveDuplicates

```java
package leetcode.array;
/**
 * 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。
示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4.你不需要考虑数组中超出新长度后面的元素。
 */
class RemoveDuplicatesSolution {
    public int removeDuplicates(int[] nums) {
        int left = 0;
        int right = 1;
        if(nums == null )return  0;
        while(right < nums.length){
            //相同
            if(nums[left] !=  nums[right]){
                nums[++left]=nums[right];
            }
            right++;
        }
        return left+1;
    }
}

```
### 11.1.2. 中等
<a href="#menu" >目录</a>

### 11.1.3. 困难
<a href="#menu" >目录</a>

## 11.2. 动态规划
<a href="#menu" >目录</a>

### 11.2.1. 简单
<a href="#menu" >目录</a>

### 11.2.2. 中等
<a href="#menu" >目录</a>

### 11.2.3. 困难
<a href="#menu" >目录</a>

## 11.3. 数学
<a href="#menu" >目录</a>

### 11.3.1. 简单
<a href="#menu" >目录</a>

### 11.3.2. 中等
<a href="#menu" >目录</a>

### 11.3.3. 困难
<a href="#menu" >目录</a>

## 11.4. 字符串
<a href="#menu" >目录</a>

### 11.4.1. 简单
<a href="#menu" >目录</a>

#### 11.4.1.1. 题目13:字母转换数字

```java
/**
 * 罗马数字转整数
 * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I（1） 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X（10） 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C（100） 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:
输入: "III"
输出: 3

示例 2:
输入: "IV"
输出: 4

示例 3:
输入: "IX"
输出: 9

示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.

 */
class Solution {
    //I， V， X， L，C，D 和 M。
    public int romanToInt(String s) {

        char dst[]  = new char[s.length()];
        s.getChars(0, s.length(), dst, 0);

        int result = 0;
        int preNum = getValue(dst[0]);
        int index = 1;
        //从高位依次比较相邻的字母，一样或者前比后大的相加，前比后小的相减
        while(index < dst.length){            
            int num = getValue(dst[index]);
            result +=  (preNum >= num)?preNum:-preNum;
            preNum = num;
            index++;
        }
        result += preNum;
        return result;
    }

    private int getValue(char ch) {
        switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0;
        }
    }
}
```

#### 11.4.1.2. 题目67:二进制字符串相加

```java

/**
 * 给你两个二进制字符串，返回它们的和（用二进制表示） 输入为 非空 字符串且只包含数字 1 和 0。

示例 1:
输入: a = "11", b = "1"
输出: "100"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
 
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

 */
class Code67Solution {

    public String addBinary(String a, String b) {     

        int aIndex = a.length()-1;
        int bIndex = b.length()-1;

        int aVal = 0;
        int bVal = 0;
        int flag = 0;

        StringBuilder stringBuilder = new StringBuilder();
        while((aIndex >= 0) && (bIndex >= 0)){
            aVal = a.charAt(aIndex--)=='1'?1:0;
            bVal = b.charAt(bIndex--)=='1'?1:0; 
            int val = aVal+bVal+flag;
            stringBuilder.append(val%2==1?1:0);
            flag = val >>1;
        }
        //超出长度处理
        //a的长度较长
        if(aIndex >= 0){
            while(aIndex >= 0){
                aVal = a.charAt(aIndex--)=='1'?1:0;
                int val = aVal+flag;
                stringBuilder.append(val%2==1?1:0);
                flag = val >>1; 
            }
        }
        //b的长度较长
        else if(bIndex >= 0){
            while(bIndex >= 0){
                bVal = b.charAt(bIndex--)=='1'?1:0;
                int val = bVal+flag;
                stringBuilder.append(val%2==1?1:0);
                flag = val >>1; 
            }
        }
        //最高位还有进位
        if (flag == 1) {
            stringBuilder.append('1');
        } 

        return stringBuilder.reverse().toString();
    }

}
```
### 11.4.2. 中等
<a href="#menu" >目录</a>

### 11.4.3. 困难
<a href="#menu" >目录</a>

## 11.5. 树
<a href="#menu" >目录</a>

### 11.5.1. 简单
<a href="#menu" >目录</a>

### 11.5.2. 中等
<a href="#menu" >目录</a>

### 11.5.3. 困难
<a href="#menu" >目录</a>

## 11.6. 哈希表
<a href="#menu" >目录</a>

### 11.6.1. 简单
<a href="#menu" >目录</a>

### 11.6.2. 中等
<a href="#menu" >目录</a>

### 11.6.3. 困难
<a href="#menu" >目录</a>

## 11.7. 深度优先搜索
<a href="#menu" >目录</a>

### 11.7.1. 简单
<a href="#menu" >目录</a>

### 11.7.2. 中等
<a href="#menu" >目录</a>

### 11.7.3. 困难
<a href="#menu" >目录</a>

## 11.8. 二分查找
<a href="#menu" >目录</a>

### 11.8.1. 简单
<a href="#menu" >目录</a>

### 11.8.2. 中等
<a href="#menu" >目录</a>

### 11.8.3. 困难
<a href="#menu" >目录</a>

## 11.9. 贪心算法
<a href="#menu" >目录</a>

### 11.9.1. 简单
<a href="#menu" >目录</a>

### 11.9.2. 中等
<a href="#menu" >目录</a>

### 11.9.3. 困难
<a href="#menu" >目录</a>

## 11.10. 广度优先算法
<a href="#menu" >目录</a>

### 11.10.1. 简单
<a href="#menu" >目录</a>

### 11.10.2. 中等
<a href="#menu" >目录</a>

### 11.10.3. 困难
<a href="#menu" >目录</a>

## 11.11. 双指针
<a href="#menu" >目录</a>

### 11.11.1. 简单
<a href="#menu" >目录</a>

### 11.11.2. 中等
<a href="#menu" >目录</a>

### 11.11.3. 困难
<a href="#menu" >目录</a>

## 11.12. 栈
<a href="#menu" >目录</a>

### 11.12.1. 简单
<a href="#menu" >目录</a>

### 11.12.2. 中等
<a href="#menu" >目录</a>

### 11.12.3. 困难
<a href="#menu" >目录</a>

## 11.13. 回溯算法
<a href="#menu" >目录</a>

### 11.13.1. 简单
<a href="#menu" >目录</a>

### 11.13.2. 中等
<a href="#menu" >目录</a>

### 11.13.3. 困难
<a href="#menu" >目录</a>

## 11.14. 设计
<a href="#menu" >目录</a>

### 11.14.1. 简单
<a href="#menu" >目录</a>

### 11.14.2. 中等
<a href="#menu" >目录</a>

### 11.14.3. 困难
<a href="#menu" >目录</a>

## 11.15. 位运算
<a href="#menu" >目录</a>

### 11.15.1. 简单
<a href="#menu" >目录</a>

#### 11.15.1.1. 题目136:只出现一次的数字
<a href="#menu" >目录</a>

思路: a^a = 0;所有数字只出现一次的只有一个，剩下的都是出现两次，那么将所有元素异或的值就是单独的值
```java
/**
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
输入: [2,2,1]
输出: 1
示例 2:
输入: [4,1,2,1,2]
输出: 4
 */
class SingleNumberSolution {
    public int singleNumber(int[] nums) {
        //注意这里的初始化，不能为0，必须为数组中的元素
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            result ^= nums[i];
        }
        return result;
    }
}
```

#### 11.15.1.2. 题目169:多数元素
<a href="#menu" >目录</a>

```java
/**
 * 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素  你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1:
输入: [3,2,3]
输出: 3
示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2

解决思路:
摩尔投票法：
多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素，那么多数元素的数量一定大于其他元素的总数量
 3 x x 3 3
 3 3 3 x x
 这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。
 */

class MajorityElementSolution {
    public int majorityElement(int[] nums) {
       
        int count = 1;
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if(result == nums[i]){
                count++;
            }
            else if(--count == 0){
                result = nums[i];
                count = 1;
            }
        }
        return result;
    }
}
```
#### 11.15.1.3. 题目191:位1的个数
<a href="#menu" >目录</a>

这里需要注意，java中>>>和>>的区别
```
>> :右移运算符，num >> 1,相当于num除以2
>>>:无符号右移，忽略符号位，空位都以0补齐
```
由于有可能输入为负值，最高为符号位为1的情况，因此应该使用>>>
```java
/**
 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数
 */
 class HammingWeightSolution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n !=0){
            count += (n & 0x01);
            n = n>>>1;
        }
        return count;
    }
}
```
#### 11.15.1.4. 题目389:找不同
<a href="#menu" >目录</a>

```java
/**
 * 给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。
示例:
输入：
s = "abcd"
t = "abcde"
输出：
e
解释：
'e' 是那个被添加的字母。

解题思路: 同一个数异或为0，两个字符串中只有一个字符是单独的，因此其他字符异或之后为0，所有字符异或之后的值就是多出来的字符
        先把字符串转换成byte数组，再进行异或
 */
class FindTheDifferenceSolution {
    public char findTheDifference(String s, String t) {
        byte[] sByte = s.getBytes();
        byte[] tByte = t.getBytes();

        int minLen = sByte.length < tByte.length? sByte.length:tByte.length;
        int data = 0;
        for (int i = 0; i < minLen; i++) {
            data ^= sByte[i]^tByte[i];
        }
        if(minLen != sByte.length ){
            data ^= sByte[sByte.length-1];
        }
        else{
            data ^= tByte[tByte.length-1];
        }

        return (char)data;
    }
}

```

#### 11.15.1.5. 插入
<a href="#menu" >目录</a>

```java
/**
 * 插入。给定两个32位的整数N与M，以及表示比特位置的i与j。编写一种方法，将M插入N，使得M从N的第j位开始，到第i位结束。
 * 假定从j位到i位足以容纳M，也即若M = 10 011，那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。

示例1:

 输入：N = 10000000000, M = 10011, i = 2, j = 6
 输出：N = 10001001100
示例2:

 输入： N = 0, M = 11111, i = 0, j = 4
 输出：N = 11111

 解答思路:
 知识点：
num = 0b11101;
设置num第3位为0： num &= ~(1<<3); --> 0b11001
设置num第2位为1: num |= (1<<2); --> 0b11111

注意点：如果区间的长度[i,j]超过M的长度，剩余的要补0

 */
class InsertBitsSolution {
    public int insertBits(int N, int M, int i, int j) {
        while((i<=j)){
            int bit  = (M&0x01);
            N = (bit== 0)?N&(~(1<< i)):N|(1<< i);        
            M >>= 1;
            i++;
        }
        return N;
    }
}
```
#### 11.15.1.6. 整数转换
<a href="#menu" >目录</a>

```java
/**
 * 整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

示例1:

 输入：A = 29 （或者0b11101）, B = 15（或者0b01111）
 输出：2

 */
class ConvertIntegerSolution {
    public int convertInteger(int A, int B) {
        int result = 0;
        int data = A^B;
        while(data != 0){
            result += data&0x01;
            data >>>=1;            
        }
        return result;
    }
}
```
#### 11.15.1.7. 消失的数字
<a href="#menu" >目录</a>

```java
/**
 * 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
 * 
 * 思路： 同数值异或为0， 这个数组的值为0-n,也就是多出来的值被n替代
 * 
 * 原本数组: [0,1,2,3]
 * 实际数组: [0,4,2,3] ,可以看出所求的没有出现的数字是1
 * 以上所有数据全部异或= 1^4; 
 * 4即为数组的长度n
 * result = 1^4^n  = 1^4^4= 1.
 */

class MissingNumberSolution {
    public int missingNumber(int[] nums) {
        int result = 0;
        
        for (int i = 0; i < nums.length; i++) {
            result ^= i;
            result ^= nums[i];
        }
        result ^= nums.length;
        return result;
    }
}
```
### 11.15.2. 中等
<a href="#menu" >目录</a>

### 11.15.3. 困难
<a href="#menu" >目录</a>

## 11.16. 排序
<a href="#menu" >目录</a>

### 11.16.1. 简单
<a href="#menu" >目录</a>



### 11.16.2. 中等
<a href="#menu" >目录</a>

### 11.16.3. 困难
<a href="#menu" >目录</a>

## 11.17. 图
<a href="#menu" >目录</a>

### 11.17.1. 简单
<a href="#menu" >目录</a>

### 11.17.2. 中等
<a href="#menu" >目录</a>

### 11.17.3. 困难
<a href="#menu" >目录</a>

## 11.18. 链表
<a href="#menu" >目录</a>

### 11.18.1. 简单
<a href="#menu" >目录</a>

### 11.18.2. 中等
<a href="#menu" >目录</a>

### 11.18.3. 困难
<a href="#menu" >目录</a>

## 11.19. 堆
<a href="#menu" >目录</a>

### 11.19.1. 简单
<a href="#menu" >目录</a>

### 11.19.2. 中等
<a href="#menu" >目录</a>

### 11.19.3. 困难
<a href="#menu" >目录</a>

## 11.20. 并查集
<a href="#menu" >目录</a>

### 11.20.1. 简单
<a href="#menu" >目录</a>

### 11.20.2. 中等
<a href="#menu" >目录</a>

### 11.20.3. 困难
<a href="#menu" >目录</a>

## 11.21. Ｓliding Window
<a href="#menu" >目录</a>

### 11.21.1. 简单
<a href="#menu" >目录</a>

### 11.21.2. 中等
<a href="#menu" >目录</a>

### 11.21.3. 困难
<a href="#menu" >目录</a>

## 11.22. 分治算法
<a href="#menu" >目录</a>

### 11.22.1. 简单
<a href="#menu" >目录</a>

### 11.22.2. 中等
<a href="#menu" >目录</a>

### 11.22.3. 困难
<a href="#menu" >目录</a>

## 11.23. 字典树
<a href="#menu" >目录</a>

### 11.23.1. 简单
<a href="#menu" >目录</a>

### 11.23.2. 中等
<a href="#menu" >目录</a>

### 11.23.3. 困难
<a href="#menu" >目录</a>

## 11.24. 递归
<a href="#menu" >目录</a>

### 11.24.1. 简单
<a href="#menu" >目录</a>

### 11.24.2. 中等
<a href="#menu" >目录</a>

### 11.24.3. 困难
<a href="#menu" >目录</a>

## 11.25. 线段树
<a href="#menu" >目录</a>

### 11.25.1. 简单
<a href="#menu" >目录</a>

### 11.25.2. 中等
<a href="#menu" >目录</a>

### 11.25.3. 困难
<a href="#menu" >目录</a>

## 11.26. Ordered Map
<a href="#menu" >目录</a>

### 11.26.1. 简单
<a href="#menu" >目录</a>

### 11.26.2. 中等
<a href="#menu" >目录</a>

### 11.26.3. 困难
<a href="#menu" >目录</a>

## 11.27. 队列
<a href="#menu" >目录</a>

### 11.27.1. 简单
<a href="#menu" >目录</a>

### 11.27.2. 中等
<a href="#menu" >目录</a>

### 11.27.3. 困难
<a href="#menu" >目录</a>

## 11.28. 极小化极大
<a href="#menu" >目录</a>

### 11.28.1. 简单
<a href="#menu" >目录</a>

### 11.28.2. 中等
<a href="#menu" >目录</a>

### 11.28.3. 困难
<a href="#menu" >目录</a>

## 11.29. 树状数组
<a href="#menu" >目录</a>

### 11.29.1. 简单
<a href="#menu" >目录</a>

### 11.29.2. 中等
<a href="#menu" >目录</a>

### 11.29.3. 困难
<a href="#menu" >目录</a>

## 11.30. Line　Ｓweep
<a href="#menu" >目录</a>

### 11.30.1. 简单
<a href="#menu" >目录</a>

### 11.30.2. 中等
<a href="#menu" >目录</a>

### 11.30.3. 困难
<a href="#menu" >目录</a>

## 11.31. Random
<a href="#menu" >目录</a>

### 11.31.1. 简单
<a href="#menu" >目录</a>

### 11.31.2. 中等
<a href="#menu" >目录</a>

**470	用 Rand7() 实现 Rand10()**	

已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。

不要使用系统的 Math.random() 方法。

* 示例 1:
```
输入: 1
输出: [7]
```
* 示例 2:
```
输入: 2
输出: [8,4]
```
* 示例 3:
```
输入: 3
输出: [8,1,10]
```

* 提示:
    * rand7 已定义。
    * 传入参数: n 表示 rand10 的调用次数。
* 进阶:
    * rand7()调用次数的 期望值 是多少 ?
    * 你能否尽量少调用 rand7() ?

* 解决思路
这是一道概率题 计算两个rand7()和的个位，两个数用a b表示，即( rand7() + rand7() ) % 10

枚举如下：
```
	a	1	2	3	4	5	6	7
b								
1		2	3	4	5	6	7	8
2		3	4	5	6	7	8	9
3		4	5	6	7	8	9	0
4		5	6	7	8	9	0	1
5		6	7	8	9	0	1	2
6		7	8	9	0	1	2	3
7		8	9	0	1	2	3	4

```
去掉右上角的
```  
6	7	8
7	8	9
8	9	0 
```
后

每个数字的出现次数为4次，0-9的概率相同

所以程序思路就很明了,当结果扫到右上角的时候进行递归调用，直到输出其他结果
```
    a=rand7();  b=rand7();
 if(a>4&&b<4)  return rand10();
 else          return (a+b)%10+1;
```

平均调用2.45次rand7()
(
PS:解释一下为什么是2.45............拉开看
分布列如下：调用次数为1次，P=40/49；2次P=(9/49)*(40/49);    3次P=(9/49)^2*(40/49); ............N次 P=(9/49)^（n-1）*(40/49)；
平均调用次数为期望==（次数*概率）求和==1*40/49+2*(9/49)*(40/49)+(9/49)^2*(40/49)+...............+n*(9/49)^（n-1）*(40/49);
求出后结果为2*49/40=2.45
)


**478	在圆内随机生成点**

给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。

说明:

输入值和输出值都将是浮点数。
圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
圆周上的点也认为是在圆中。
randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。
示例 1：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
示例 2：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。randPoint 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-random-point-in-a-circle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**497	非重叠矩形中的随机点**

给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。

* 提示：
```
整数点是具有整数坐标的点。
矩形周边上的点包含在矩形覆盖的空间中。
第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。
每个矩形的长度和宽度不超过 2000。
1 <= rects.length <= 100
pick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。
pick 最多被调用10000次。
```

* 示例 1：

```
输入: 
["Solution","pick","pick","pick"]
[[[[1,1,5,5]]],[],[],[]]
输出: 
[null,[4,1],[4,1],[3,3]]
```
* 示例 2：
```
输入: 
["Solution","pick","pick","pick","pick","pick"]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
输出: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]
```

* 输入语法的说明：
输入是两个列表：调用的子例程及其参数。Solution 的构造函数有一个参数，即矩形数组 rects。pick 没有参数。参数总是用列表包装的，即使没有也是如此。



**519	随机翻转矩阵**

题中给出一个 n 行 n 列的二维矩阵 (n_rows,n_cols)，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。

注意:

1.1 <= n_rows, n_cols <= 10000

2. 0 <= row.id < n_rows 并且 0 <= col.id < n_cols

3.当矩阵中没有值为 0 时，不可以调用 flip 函数

4.调用 flip 和 reset 函数的次数加起来不会超过 1000 次

示例 1：

输入: 
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
输出: [null,[0,1],[1,2],[1,0],[1,1]]
示例 2：

输入: 
["Solution","flip","flip","reset","flip"]
[[1,2],[],[],[],[]]
输出: [null,[0,0],[0,1],null,[0,0]]
输入语法解释：

输入包含两个列表：被调用的子程序和他们的参数。Solution 的构造函数有两个参数，分别为 n_rows 和 n_cols。flip 和 reset 没有参数，参数总会以列表形式给出，哪怕该列表为空


**528	按权重随机选择**	

给定一个正整数数组 w ，其中 w[i] 代表位置 i 的权重，请写一个函数 pickIndex ，它可以随机地获取位置 i，选取位置 i 的概率与 w[i] 成正比。

说明:

1 <= w.length <= 10000
1 <= w[i] <= 10^5
pickIndex 将被调用不超过 10000 次
示例1:

输入: 
["Solution","pickIndex"]
[[[1]],[]]
输出: [null,0]
示例2:

输入: 
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出: [null,0,1,1,1,0]
输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution 的构造函数有一个参数，即数组 w。pickIndex 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。


### 11.31.3. 困难
<a href="#menu" >目录</a>

**710	黑名单中的随机数**	

给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。

对它进行优化使其尽量少调用系统方法 Math.random() 。

* 提示:
```
1 <= N <= 1000000000
0 <= B.length < min(100000, N)
[0, N) 不包含 N，详细参见 interval notation 。
```
* 示例 1:
输入: 
```
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
输出: [null,0,0,0]
```

* 示例 2:
输入:
``` 
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
输出: [null,1,1,1]
```
* 示例 3:
输入: 
```
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]
```
* 示例 4:

输入: 

```
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
输出: [null,1,3,1]
```

* 输入语法说明：

输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，N 和黑名单 B。pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表

* 解决思路

正常情况下 如果随机了一个数 这个数在黑名单中 那么需要重新随机一个数; 问题是 怎么能够减少随机的次数

换句话说：如何处理能够在随机到黑名单中的值时 仍然能够将这个黑名单值转化为正常值

思路: 在[0,N)中有b个黑名单值， 我们可以在[0,N-b)的范围内取随机数
假设在【0，N-b】内有x个黑名单值 那么在[N-b,N)肯定有x个白名单值(非黑名单)

把这x个黑名单 和x个白名单一一对应 可以用map

那么 当取随机数r时 如果这个r在黑名单中 我们可以不需要再次进行取随机数 只要取map中r对应的白名单值就可以了

* 代码

```java
class Solution {
public:
	int nowSize;//修改后的N
	unordered_map<int, int> hashMap;//映射hash表
	Solution(int N, vector<int>& blacklist) {
		int blacklistSize = blacklist.size();
		nowSize = N - blacklistSize;
		int startNum = nowSize;//扫描在[N - blacklistSize, N)中非黑名单中的数据
		set<int> mySet(blacklist.begin(), blacklist.end());
		auto it = mySet.begin();//扫描黑名单中在[0, N - blacklistSize)的数据
		while (it != mySet.end() && *it < nowSize) {
			while (mySet.find(startNum) != mySet.end()) {
				++startNum;
			}
            //将在[0, N - blacklistSize)中的黑名单的数据一一映射到[N - blacklistSize, N)中非黑名单中的数据
			hashMap[*(it++)] = startNum++;
		}
	}

	int pick() {
		int randNum = rand() % nowSize;//随机生成[0, N - blacklistSize)
		if (hashMap.count(randNum)) {
            //如果randNum在hash表中，说明它是黑名单中的数据，需要修改为它映射的数据
			return hashMap[randNum];
		}
		else {
            //否则直接返回
			return randNum;
		}
	}
};
```

**710**
## 11.32. 拓扑排序
<a href="#menu" >目录</a>

### 11.32.1. 简单
<a href="#menu" >目录</a>

### 11.32.2. 中等
<a href="#menu" >目录</a>

### 11.32.3. 困难
<a href="#menu" >目录</a>

## 11.33. 脑筋急转弯
<a href="#menu" >目录</a>

### 11.33.1. 简单
<a href="#menu" >目录</a>

### 11.33.2. 中等
<a href="#menu" >目录</a>

### 11.33.3. 困难
<a href="#menu" >目录</a>

## 11.34. 几何
<a href="#menu" >目录</a>

### 11.34.1. 简单
<a href="#menu" >目录</a>

### 11.34.2. 中等
<a href="#menu" >目录</a>

### 11.34.3. 困难
<a href="#menu" >目录</a>

## 11.35. 二叉搜索树
<a href="#menu" >目录</a>

### 11.35.1. 简单
<a href="#menu" >目录</a>

### 11.35.2. 中等
<a href="#menu" >目录</a>

### 11.35.3. 困难
<a href="#menu" >目录</a>

## 11.36. Rejection Sampling
<a href="#menu" >目录</a>

### 11.36.1. 简单
<a href="#menu" >目录</a>

### 11.36.2. 中等
<a href="#menu" >目录</a>

### 11.36.3. 困难
<a href="#menu" >目录</a>

## 11.37. 蓄水池搜样
<a href="#menu" >目录</a>

### 11.37.1. 简单
<a href="#menu" >目录</a>

### 11.37.2. 中等
<a href="#menu" >目录</a>

### 11.37.3. 困难
<a href="#menu" >目录</a>

## 11.38. 记忆化
<a href="#menu" >目录</a>

### 11.38.1. 简单
<a href="#menu" >目录</a>

### 11.38.2. 中等
<a href="#menu" >目录</a>

### 11.38.3. 困难
<a href="#menu" >目录</a>


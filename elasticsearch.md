

<span id="menu"></span>

<!-- TOC -->

- [1. Elasticsearch搜索引擎](#1-elasticsearch搜索引擎)
    - [1.1. 基本概念](#11-基本概念)
    - [1.2. Elasticsearch工作流程](#12-elasticsearch工作流程)
        - [1.2.1. 启动过程](#121-启动过程)
        - [1.2.2. 故障检测](#122-故障检测)
        - [1.2.3. 与El通信](#123-与el通信)
            - [1.2.3.1. 索引数据](#1231-索引数据)
            - [1.2.3.2. 查询数据](#1232-查询数据)
    - [1.3. 安装与配置](#13-安装与配置)
        - [1.3.1. 配置文件说明](#131-配置文件说明)
            - [1.3.1.1. elasticsearch.yml](#1311-elasticsearchyml)
    - [1.4. 索引](#14-索引)
        - [1.4.1. 索引](#141-索引)
        - [1.4.2. 映射配置](#142-映射配置)
    - [1.5. 集群管理](#15-集群管理)
        - [1.5.1. 集群健康](#151-集群健康)
        - [1.5.2. 添加索引](#152-添加索引)
    - [1.6. 数据](#16-数据)
        - [1.6.1. 文档](#161-文档)
        - [1.6.2. 处理冲突](#162-处理冲突)
    - [1.7. 分布式增删改查](#17-分布式增删改查)
        - [1.7.1. 路由文档到分片](#171-路由文档到分片)
        - [1.7.2. 分片交互](#172-分片交互)
            - [1.7.2.1. 新建，索引和删除文档](#1721-新建索引和删除文档)
            - [1.7.2.2. 索引文档](#1722-索引文档)
    - [1.8. 面试小结之Elasticsearch篇](#18-面试小结之elasticsearch篇)

<!-- /TOC -->


# 1. Elasticsearch搜索引擎
<a href="#menu" style="float:right">目录</a>

## 1.1. 基本概念
<a href="#menu" style="float:right">目录</a>

* 索引
    * 逻辑数据的存储，可以看作一个数据库
    * 一个索引有一个或者多个分片，每个分片可以有多个副本
* 文档类型
    * 可以看作数据库的表名，用于区分不同类型文档
* 文档 document
    * 索引和搜索时使用的主要数据载体，包含一个或者多个存有数据的字段，可以看作数据库的一行数据
* 文档ID
    * 索引的唯一标识符，如果索引建立时不指定，el将会随机生成一个随机字符串当作文档哪个ID
    * 两个不同的文档类型可以有相同的文档ID
* 字段 Field
    * 文档的一部分，包含名称和值两部分
* 词 term
    * 搜索的词
* 标记 token
    * 表示字段在文本中出现的词，由这个词的文本、开始偏移量以及类型组成

* 倒排索引
文档1： 中国伟大
文档2： 中建公司

|词|计数|文档|
|---|---|---|
|中|2|<1><2>|
|中国|1|<1>|
|公司|1|<2>|
|...|...|...|

每一个词指向包含它的文档编号。这样就可以执行一种非常高效且快速的搜索，比如基于词的查询。此外，每个词有一个计数，告诉Lucene该词出现的频率。


* 输入数据分析
    * 传入文档中的数据怎么转化为到排索引，这个过程叫做分析
    * 分析的工作由分析器完成，分析器由一个分词器和零或多个标记过滤器组成，也可以有零个或多个字符映射器
        * 分词器
            * 把文本分隔成多个标记‘
            * 基本就是词加上一些额外的信息，比如该词在原始文本中的位置和长度
            * 分词器的处理结果称为标记流（ token stream），它是一个接一个的标记，准备被过滤器处理
        * 过滤器
            * 小写过滤器，把所有标记变为小写
            * 同义词过滤器，基于基本的同义词规则，把一个标记换成另一个同义的标记。
            * 多语言词干提取过滤器（ multiple language stemming filter）：减少标记（实际上是标记中的文本部分），得到词根或者基本形式，即词干
            * 过滤器是一个接一个进行处理，可以使用多个过滤器进行处理
        * 字符映射器
            * 对未经分析的文本其作用，在分词器之前进行工作
            * 可以将文本中的Html标签去除

* el集群基本概念
    * 节点和集群
        * el可以作为一个独立的搜索的服务器
        * 但为了处理大型数据集，实现容错和可用性，可以多个服务器组成集群。
    * 分片
        * 当存在大量的文档时，由于内存的限制、硬盘能力、处理能力不足、无法足够快地响应客户端请求等，一个节点可能不够
        * 在这种情况下，数据可以分为较小的称为分片（ shard）的部分（其中每个分片都是一个独立的Apache Lucene索引）。每个分片可以放在不同的服务器上
        * 当你查询的索引分布在多个分片上时， Elasticsearch会把查询发送给每个相关的分片，并将结果合并在一起，而应用程序并不知道分片的存在
    * 副本
        * 副本（ replica）只是一个分片的精确复制，每个分片可以有零个或多个副本
        * 副本分为主分片和副本分片
        * 主分片不可用时，则集群将副本分片提升为主分片
        * 使用副本机制可以提高查询吞吐量和实现高可用
        * 索引建立时，副本只是作为额外的位置来存放数据
        * 索引查询时，el会尽量平衡分片和它副本之间的负载
        
* 索引建立和搜索
    * 索引建立
        * 发送一个新的文档给集群，这个节点是任意选择的。
        * 这个节点知道目标索引有多少分片，并且能够确定哪个分片应该用来存储你的文档
        * Elasticsearch使用文档的唯一标识符来计算文档应该被放到哪个分片中
    * 索引查询
        * 使用文档标识符进行查询，根据ID确认持有的节点和分片，然后转发请求，获取结果，返回给客户端

* Elasticsearch架构特点
    * 合理的默认配置，使得用户在简单安装后能直接使用，而不需要额外的调优，这其中包括内置的发现(例如字段类型检测)和自动配置功能
    * 默认的分布式工作模式，每个节点总是假定自己是某个集群的一部分或将是某个集群的一部分
    * 对等架构，可以避免单点故障，节点会自动连接到集群中的其他节点，进行相互的数据交换和监控操作。这其中包括索引分片的自动复制
    * 容易扩充新节点至集群，不论是从数据容量的角度还是数量的角度
    * 没有对索引中的数据结构强加任何限制
    * 准实时搜索和版本同步，由于分布式特性，无法保证数据实时同步，el尝试解决这些问题，并且提供额外的机制用于版本同步。




## 1.2. Elasticsearch工作流程
<a href="#menu" style="float:right">目录</a>

### 1.2.1. 启动过程
<a href="#menu" style="float:right">目录</a>

* 当节点启动时，它使用发现模块来发现同一个集群(集群名称需要一样)中的其他节点，并与他们连接，默认情况下节点会发送广播请求，以找到拥有相同集群名称的其他节点。
* 集群中的一个节点被选为主(master)节点。该节点负责集群的状态管理以及在集群拓扑变化时做出反映，分发索引分片至集群相应的节点上去。
* 用户不需要关注哪个是master,请求可以发送到任何的节点其内部会自行转发处理。
* 管理节点读取集群的状态信息，如果有必要，它会进行会恢复处理，在该阶段，管理节点会检查哪些索引分片，并决定哪些分片将用作主分片，然后整个集群进入**黄色状态**。
* 黄色状态意味着集群可以进行查询，但是系统的吞吐量以及各种可能的状态是未知的(可以理解为所有的主分片已经分配，但是副本分片还没有分配)
* el寻找冗余的分片用作副本，如果某个主分片的副本数过少，管理节点将决定基于某个主分片创建分片和副本，如果主分片和副本分片已经分配好，那么将进入**绿色状态**

### 1.2.2. 故障检测
<a href="#menu" style="float:right">目录</a>

* 集群正常工作时，管理节点会监控所有可用的节点，检查它们是否正常工作。
* 如果任何节点在预订的超时时间内不响应，则认为该节点已经断开，然后错误处理开始启动
    * 这意味着集群-分片之间重新做平衡，选择新的主节点等
    * 对每个丢失的主分片，一个新的主分片将会从原来的主分片副本中选出来


### 1.2.3. 与El通信
<a href="#menu" style="float:right">目录</a>

#### 1.2.3.1. 索引数据
<a href="#menu" style="float:right">目录</a>

![索引建立](https://github.com/lgjlife/Java-Study/blob/master/pic/elasticsearch/index-create.png?raw=true)

* 索引操作只能发生在主分片上，而不是副本，当一个索引请求被发送到一个节点上时
* 如果该节点没有对应的主分片或者只有副本，那么这个请求会被转发到拥有正确的主分片节点。
* 然后该主节点会将请求发送到各个副本，然后等待响应，当达到规定数目的副本返回响应，完成索引过程并返回响应给客户端。


#### 1.2.3.2. 查询数据
<a href="#menu" style="float:right">目录</a>

![索引搜索](https://github.com/lgjlife/Java-Study/blob/master/pic/elasticsearch/index-search.png?raw=true)

* 查询分为分散阶段和合并阶段
    * 分散阶段
        * 查询请求分发到包含相关文档的多个分片中执行查询
    * 合并阶段
        * 从众多分片中收集返回结果，。然后进行合并，排序等操作之后再返回客户端。

## 1.3. 安装与配置
<a href="#menu" style="float:right">目录</a>

新创建的目录中。应该可以看到下面的目录结构：
|目录 |描述|
|---|---|
|bin| 运行Elasticsearch实例和插件管理所需的脚本
|config| 配置文件所在的目录
|lib| Elasticsearch使用的库
Elasticsearch启动后，会创建如下目录（如果目录不存在）：
|目 录 |描 述
|---|---|
|data| Elasticsearch使用的所有数据的存储位置
|logs| 关于事件和错误记录的文件
|plugins| 存储所安装插件的地方
|work| Elasticsearch使用的临时文件

### 1.3.1. 配置文件说明
<a href="#menu" style="float:right">目录</a>

* elasticsearch.yml  Elasticsearch配置文件
* jvm.options jvm参数配置
* log4j2.properties 日志配置


#### 1.3.1.1. elasticsearch.yml
<a href="#menu" style="float:right">目录</a>

```
cluster.name: elasticsearch                 配置集群名称，默认elasticsearch
node.name: node1                            配置节点名称
node.master: true                           配置当前节点是否具有可选为master节点的资格，默认值为true
node.data: true                             配置当前节点是否允许存储数据，默认值为true
node.rack: rack314                          每个节点都可以定义一些与之关联的通用属性，用于后期集群进行碎片分配时的过滤
node.max_local_storage_nodes: 1             默认情况下，多个节点可以在同一个安装路径启动，如果你想让你的es只启动一个节点，可以进行如下设置
index.number_of_shards: 5                   配置索引的默认分片数，默认值为5
index.number_of_replicas: 1                 配置索引的默认副本数，默认值为1
path.conf: /path/to/conf                    配置文件所在的位置，即elasticsearch.yml和logging.yml所在的位置
path.data: /path/to/data                    分配给当前节点的索引数据所在的位置
path.work: /path/to/work                    临时文件位置
path.logs: /path/to/logs                    日志文件所在位置
path.plugins: /path/to/plugins              插件安装位置
plugin.mandatory: mapper-attachments,lang-groovy 
                                            插件托管位置，若列表中的某一个插件未安装，则节点无法启动： 
bootstrap.mlockall: true                    JVM开始交换时，ElasticSearch表现并不好：你需要保障JVM不进行交换，可以将bootstrap.mlockall设置为true禁止交换
network.bind_host: 192.168.0.1              默认情况下，ElasticSearch使用0.0.0.0地址，并为http传输开启9200-9300端口，为节点到节点的通信开启9300-9400端口，也可以自行设置IP地址
network.publish_host: 192.168.0.1           publish_host设置其他节点连接此节点的地址，如果不设置的话，则自动获取，publish_host的地址必须为真实地址
network.host: 192.168.0.1                   bind_host和publish_host可以一起设置
transport.tcp.port: 9300                    配置节点之间交互的端口
transport.tcp.compress: true                节点间交互时，可以设置是否压缩，转为为不压缩
http.port: 9200                             可以为Http传输监听定制端口
http.max_content_length: 100mb              设置内容的最大长度
http.enabled: false                         禁止HTTP 
http.cors.enabled: true                     设置运行跨域访问，默认为false
http.cors.allow-origin: "*"                 设置跨域访问的允许范围
gateway.type: local                         网关允许在所有集群重启后持有集群状态，集群状态的变更都会被保存下来，当第一次启用集群时，可以从网关中读取到状态
gateway.recover_after_nodes: 1              允许在N个节点启动后恢复过程
gateway.recover_after_time: 5m              设置初始化恢复过程的超时时间
gateway.expected_nodes: 2                   设置该集群中可存在的节点上限
cluster.routing.allocation.node_initial_primaries_recoveries: 4 
                                            设置一个节点的并发数量，有两种情况，一种是在初始复苏过程中，另一种是在添加、删除节点及调整时
indices.recovery.max_size_per_sec: 0        设置复苏时的吞吐量，默认情况下是无限的
indices.recovery.concurrent_streams: 5      设置从对等节点恢复片段时打开的流的数量上限
discovery.zen.minimum_master_nodes: 1       设置一个集群中主节点的数量，当多于三个节点时，该值可在2-4之间
discovery.zen.ping.timeout: 3s              设置ping其他节点时的超时时间，网络比较慢时可将该值设大
discovery.zen.ping.multicast.group:224.2.2.4组地址
discovery.zen.ping.multicast.port：54328    端口
discovery.zen.ping.multicast.ttl:3          广播消息ttl
discovery.zen.ping.multicast.address:null   绑定的地址，null表示绑定所有可用的网络接口
discovery.zen.ping.multicast.enabled:true   多播自动发现禁用开关，默认值为true

discovery.zen.ping.unicast.hosts: ["host1", "host2:port", "host3[portX-portY]"] 
                                            设置新节点被启动时能够发现的主节点列表（主要用于不同网段机器连接）


action.destructive_requires_name            设置是否可以通过正则或者_all删除或者关闭索引，默认false 允许 可设置true不允许
action.auto_create_index: true              是否允许自动创建索引，除了true或者false,还可以使用名字匹配模式
action.auto_create_index: -an*,+a*,-*       允许自动创建以a开头的索引，但以an开头的索引则允许。其他索引也必须手动创建（因为指令中的-*）。注意顺序，匹配到就不会继续往下匹配。
```



## 1.4. 索引
<a href="#menu" style="float:right">目录</a>

### 1.4.1. 索引
<a href="#menu" style="float:right">目录</a>

* 分片和副本
    * 每个索引是由一个或者多个分片组成，每个分片包含了文档集的一部分
    * 每个分片可以有副本，每个副本是分片的完整数据副本
    * 创建索引，可以指定分片和副本数，也可以按照配置文件中的默认值
    * 分片分为主分片和副分片副本。
    * 更多分片使索引能传送到更多服务器，意味着可以处理更多文件，而不会降低性能。
    * 更多分片意味着获取特定文档所需的资源量会减少，因为相较于部署更少分片时，存储在单个分片中的文件数量更少。
    * 更多分片意味着搜索索引时会面临更多问题，因为必须从更多分片中合并结果，使得查询的聚合阶段需要更多资源。
    * 更多副本会增强集群系统的容错性，因为当原始分片不可用时，其副本将替代原始分片发挥作用。只拥有单个副本，集群可能在不丢失数据的情况下遗失分片。当有两个副本时，即使丢失了原始分片及其中一个副本，一切工作仍可以很好地持续下去。
    * 更多副本意味着查询吞吐量将会增加，因为执行查询可以使用分片或分片的任一副本。
    * 一旦建立好分片，就无法更新分片数量，涉及到数据迁移的问题。副本数量可以改变。

### 1.4.2. 映射配置
<a href="#menu" style="float:right">目录</a>

* Elasticsearch有以下核心类型
    * string 字符串
    * number 数字
    * date 日期
    * boolean 布尔型
    * binary 二进制

现在来讨论Elasticsearch中可用的每个核心类型，以及它们用来定义行为的属性。

* **公共属性**
    * index_name：该属性定义将存储在索引中的字段名称。若未定义，字段将以对象的名字来命名。
    * index：可设置值为analyzed和no。另外，对基于字符串的字段，也可以设置为not_analyzed。如果设置为analyzed，该字段将被编入索引以供搜索。如果设置为no，将无法搜索该字段。默认值为analyzed。在基于字符串的字段中，还有一个额外的选项not_analyzed。此设置意味着字段将不经分析而编入索引，使用原始值被编入索引，在搜索的过程中必须全部匹配。索引属性设置为no将使include_in_all属性失效。
    * store：这个属性的值可以是yes或no，指定了该字段的原始值是否被写入索引中。默认值设置为no，这意味着在结果中不能返回该字段（然而，如果你使用_source字段，即使没有存储也可返回这个值），但是如果该值编入索引，仍可以基于它来搜索数据。
    * boost：该属性的默认值是1。基本上，它定义了在文档中该字段的重要性。 boost的值越高，字段中值的重要性也越高。
    * null_value：如果该字段并非索引文档的一部分，此属性指定应写入索引的值。默认的行为是忽略该字段。
    * copy_to：此属性指定一个字段，字段的所有值都将复制到该指定字段。
    * include_in_all：此属性指定该字段是否应包括在_all字段中。默认情况下，如果使用_all字段，所有字段都会包括在其中。 2.4节将更详细地介绍_all字段。
* **字符串**
字符串是最基本的文本类型，我们能够用它存储一个或多个字符。字符串字段的示例定义如
下所示：

```json
"contents" : { "type" : "string", "store" : "no", "index" :"analyzed" }
```
* 除了公共属性，基于字符串的字段还可以使用以下属性。
    * term_vector ： 此 属 性 的 值 可 以 设 置 为 no （ 默 认 值 ）、 yes 、 with_offsets 、with_positions和with_positions_offsets。它定义是否要计算该字段的Lucene词向量（ term vector）。如果你使用高亮，那就需要计算这个词向量。
    * omit_norms：该属性可以设置为true或false。对于经过分析的字符串字段，默认值为false，而对于未经分析但已编入索引的字符串字段，默认值设置为true。当属性为true时，它会禁用Lucene对该字段的加权基准计算（ norms calculation），这样就无法使用索引期间的加权，从而可以为只用于过滤器中的字段节省内存（在计算所述文件的得分时不会被考虑在内）。
    * analyzer：该属性定义用于索引和搜索的分析器名称。它默认为全局定义的分析器名称。
    * index_analyzer：该属性定义了用于建立索引的分析器名称。
    * search_analyzer：该属性定义了的分析器，用于处理发送到特定字段的那部分查询字符串。
    * norms.enabled：此属性指定是否为字段加载加权基准（ norms）。默认情况下，为已分析字段设置为true（这意味着字段可加载加权基准），而未经分析字段则设置为false。
    * norms.loading：该属性可设置eager和lazy。第一个属性值表示此字段总是载入加权基准。第二个属性值是指只在需要时才载入。
    * position_offset_gap：此属性的默认值为0，它指定索引中在不同实例中具有相同名称的字段的差距。若想让基于位置的查询（如短语查询）只与一个字段实例相匹配，可将该属性值设为较高值。
    * index_options：该属性定义了信息列表（ postings list）的索引选项（ 2.2.4节将详细讨论）。可能的值是docs（仅对文档编号建立索引）， freqs（对文档编号和词频建立索引），positions（对文档编号、词频和它们的位置建立索引）， offsets（对文档编号、词频、它们的位置和偏移量建立索引）。对于经分析的字段，此属性的默认值是positions，对于未经分析的字段，默认值为docs。
    * ignore_above：该属性定义字段中字符的最大值。当字段的长度高于指定值时，分析器会将其忽略。
* **数值**

* 这一核心类型汇集了所有适用的数值字段类型Elasticsearch中可使用以下类型（使用type属性指定）。
    * byte：定义字节值，例如1。
    * short：定义短整型值，例如12。
    * integer：定义整型值，例如134。
    * long：定义长整型值，例如123456789。   
    * float：定义浮点值，例如12.23。
    * double：定义双精度值，例如123.45。
* 数值类型字段的定义如下所示：
```json
"price" : { "type" : "float", "store" : "yes", "precision_step" : "4" }
```
* 除了公共属性，以下属性也适用于数值字段。
    * precision_step：此属性指定为某个字段中每个值生成的词条数。值越低，产生的词条数越高。对于每个值的词条数更高的字段，范围查询（ range query）会更快，但索引会稍微大点，默认值为4。
    * ignore_malformed：此属性值可以设为true或false。默认值是false。若要忽略格式错误的值，则应设置属性值为true。
    * 布尔值
        布尔值核心类型是专为索引布尔值（ true或false）设计的。基于布尔值类型的字段定义如下所示："allowed" : { "type" : "boolean", "store": "yes" }
    * 二进制
        * 二进制字段是存储在索引中的二进制数据的Base64表示，可用来存储以二进制形式正常写入的数据，例如图像。基于此类型的字段在默认情况下只被存储，而不索引，因此只能提取，但无法对其执行搜索操作。二进制类型只支持index_name属性。基于binary字段的字段定义如下所示："image" : { "type" : "binary" }
    * 日期
        * 日期核心类型被设计用于日期的索引。它遵循一个特定的、可改变的格式，并默认使用UTC保存。能被Elasticsearch理解的默认日期格式是相当普遍的，它允许指定日期，也可指定时间，例如， 2012-12-24T12:10:22。基于日期类型的字段的示例定义如下所示："published" : { "type" : "date", "store" : "yes", "format" :"YYYY-mm-dd" }使用上述字段的示例文档如下所示{"name" : "Sample document","published" : "2012-12-22"}
* 除了公共属性，日期类型的字段还可以设置以下属性。
    * format：此属性指定日期的格式。默认值为dateOptionalTime。对于格式的完整列表，请 访 问 http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-dateormat.html。
    * precision_step：此属性指定在该字段中的每个值生成的词条数。该值越低，产生的词条数越高，从而范围查询的速度越快（但索引大小增加）。默认值是4。
    * ignore_malformed：此属性值可以设为true或false，默认值是false。若要忽略格式错误的值，则应设置属性值为true。

* 多字段
    * 有时候你希望两个字段中有相同的字段值，例如，一个字段用于搜索，一个字段用于排序；或一个经语言分析器分析，一个只基于空白字符来分析。 Elasticsearch允许加入多字段对象来拓展字段定义，从而解决这个需求。它允许把几个核心类型映射到单个字段，并逐个分析。例如，想计算切面并在name字段中搜索，可以定义以下字段：

```json
"name": {
    "type": "string",
    "fields": {
        "facet": { "type" : "string", "index": "not_analyzed" }
    }
}
```
上述定义将创建两个字段：我们将第一个字段称为name，第二个称为name.facet。当然，你不必在索引的过程中指定两个独立字段，指定一个name字段就足够了。 Elasticsearch会处理余下的工作，将该字段的数值复制到多字段定义的所有字段。

* **IP地址类型**
Elasticsearch添加了IP字段类型，以数字形式简化IPv4地址的使用。此字段类型可以帮搜索作为IP地址索引的数据、对这些数据排序，并使用IP值做范围查询。基于IP地址类型的字段示例定义如下所示：
```json
"address" : { "type" : "ip", "store" : "yes" }
```
除公共属性外， IP地址类型的字段还可以设置precision_step属性。该属性指定了字段中的每个值生成的词条数。值越低，词条数越高。对于每个值的词条数更高的字段，范围查询会更快，但索引会稍微大点，默认值为4。

* **使用分析器**
正如我们提到的那样，对于字符串类型的字段，可以指定Elasticsearch应该使用哪个分析器。
回想第1章的内容，分析器是一个用于分析数据或以我们想要的方式查询数据的工具。例如，用
空格和小写字符把单词隔开时，不必担心用户发送的单词是小写还是大写。 Elasticsearch使我们
能够在索引和查询时使用不同的分析器，并且可以在搜索过程的每个阶段选择处理数据的方式。
使用分析器时，只需在指定字段的正确属性上设置它的名字，就这么简单。

* 开箱即用的分析器,Elasticsearch允许我们使用众多默认定义的分析器中的一种。如下分析器可以开箱即用。
    * standard：方便大多数欧洲语言的标准分析器（关于参数的完整列表，请参阅http://www.lasticsearch.org/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html）。
    * simple：这个分析器基于非字母字符来分离所提供的值，并将其转换为小写形式。
    * whitespace：这个分析器基于空格字符来分离所提供的值。
    * stop：这个分析器类似于simple分析器，但除了simple分析器的功能，它还能基于所提供的停用词（ stop word）过滤数据（参数的完整列表，请参阅http://www.elasticsearch.rg/guide/en/elasticsearch/reference/current/analysis-stop-analyzer.html）。
    * keyword：这是一个非常简单的分析器，只传入提供的值。你可以通过指定字段为not_analyzed来达到相同的目的。
    * pattern：这个分析器通过使用正则表达式灵活地分离文本（参数的完整列表，请参阅http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-pattern-analyzer.html）。
    * language：这个分析器旨在特定的语言环境下工作。该分析器所支持语言的完整列表可参考http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/nalysis-lang-analyzer. tml。
    * snowball：这个分析器类似于standard分析器，但提供了词干提取算法（ stemmingalgorithm ， 参 数 的 完 整 列 表 请 参 阅 http://www.elasticsearch.org/guide/en/elasticsearch/eference/current/analysis-snowball-analyzer.html）。


## 1.5. 集群管理
<a href="#menu" style="float:right">目录</a>

一个节点(node)就是一个Elasticsearch实例， 而一个集群(cluster)由一个或多个节点组成， 它们具有相同的 cluster.name 它们协同工作， 分享数据和负载。 当加入新的节点或者删除一个节点时， 集群就会感知到并平衡数据。

集群中一个节点会被选举为主节点(master),它将临时管理集群级别的一些变更， 例如新建或删除索引、 增加或移除节点等。主节点不参与文档级别的变更或搜索， 这意味着在流量增长的时候， 该主节点不会成为集群的瓶颈。 任何节点都可以成为主节点。 我们例子中的集群只有一个节点， 所以它会充当主节点的角色。

做为用户， 我们能够与集群中的任何节点通信， 包括主节点。 每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。 我们访问的节点负责收集各节点返回的数据， 最后一起返回给客户端。 这一切都由Elasticsearch处理。

### 1.5.1. 集群健康
<a href="#menu" style="float:right">目录</a>

|颜色| 意义|
|---|---|
|green| 所有主要分片和复制分片都可用
|yellow| 所有主要分片可用， 但不是所有复制分片都可用
|red| 不是所有的主要分片都可用

比如你定义三个分片，每个分片有2个副本。
* 当只启动一个节点时，主分片可用，但是副本只有一个。此时为**yellow**
* 当启动两个节点时，主分片和副本分片都可用，此时为**green**.此时el平衡负载，可能两个节点都有主分片。
* 此时关闭一个节点，必然至少有一个主分片被关掉，此时状态为**red**.经过内部调整，被关掉的主分片的副本分片升级为主分片，此时所有主要分片可用， 但不是所有复制分片都可用，因此为yellow

### 1.5.2. 添加索引
<a href="#menu" style="float:right">目录</a>


为了将数据添加到Elasticsearch， 我们需要索引(index)——一个存储关联数据的地方。 实际上， 索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”.
一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了索引中所有数据的一部分。 在接下来的《深入分片》 一章， 我们将详细说明分片的工作原理， 但是现在我们只要知道分片就是一个Lucene实例， 并且它本身就是一个完整的搜索引擎。 我们的文档存储在分片中， 并且在分片中被索引， 但是我们的应用程序不会直接与它们通信， 取而代之的是， 直接与索引通信。
分片是Elasticsearch在集群中分发数据的关键。 把分片想象成数据的容器。 文档存储在分片中， 然后分片分配到你集群中的节点上。 当你的集群扩容或缩小， Elasticsearch将会自动在你的节点间迁移分片， 以使集群保持平衡。
分片可以是主分片(primary shard)或者是复制分片(replica shard)。 你索引中的每个文档属于一个单独的主分片， 所以主分片的数量决定了索引最多能存储多少数据。
理论上主分片能存储的数据大小是没有限制的， 限制取决于你实际的使用情况。 分片的最大容量完全取决于你的使用状况： 硬件存储的大小、 文档的大小和复杂度、 如何索引和查询你的文档， 以及你期望的响应时间。
复制分片只是主分片的一个副本， 它可以防止硬件故障导致的数据丢失， 同时可以提供读请求， 比如搜索或者从别的shard取回文档。
当索引创建完成的时候， 主分片的数量就固定了， 但是复制分片的数量可以随时调整。
让我们在集群中唯一一个空节点上创建一个叫做 blogs 的索引。 默认情况下， 一个索引被分配5个主分片，但是为了演示的目的， 我们只分配3个主分片和一个复制分片（每个主分片都有一个复制分片）

```json
PUT /blogs
{
    "settings" : {
        "number_of_shards" : 3,
        "number_of_replicas" : 1
    }
}
```


## 1.6. 数据
<a href="#menu" style="float:right">目录</a>

### 1.6.1. 文档
<a href="#menu" style="float:right">目录</a>

在Elasticsearch中， 文档(document)这个术语有着特殊含义。 它特指最顶层结构或者根对象(root object)序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中） 。

**文档元数据**
一个文档不只有数据。 它还包含了元数据(metadata)——关于文档的信息。 三个必须的元数据节点是：
|节点| 说明
|---|---|
|_index| 文档存储的地方
|_type| 文档代表的对象的类
|_id| 文档的唯一标识

**_index**
索引(index)类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。
提示：
事实上，我们的数据被存储和索引在分片(shards)中， 索引只是一个把一个或多个分片分组在一起的逻辑空间。 然而， 这只是一些内部细节——我们的程序完全不用关心分片。 对于我们的程序而言， 文档存储在索引(index)中。 剩下的细节由Elasticsearch关心既可。

索引名必须是全部小写，不能以下划线开头，不能包含逗号。 让我们使用 website 做为索引名。

**_type**
在应用中， 我们使用对象表示一些“事物”， 例如一个用户、 一篇博客、 一个评论， 或者一封邮件。 每个对象都属于一个类(class)， 这个类定义了属性或与对象关联的数据。 user 类的对象可能包含姓名、 性别、 年龄和Email地址。
在关系型数据库中， 我们经常将相同类的对象存储在一个表里， 因为它们有着相同的结构。 同理， 在Elasticsearch中， 我们使用相同类型(type)的文档表示相同的“事物”， 因为他们的数据结构也是相同的。
每个类型(type)都有自己的映射(mapping)或者结构定义， 就像传统数据库表中的列一样。 所有类型下的文档被存储在同一个索引下， 但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引。 我们将会在《映射》 章节探讨如何定义和管理映射， 但是现在我们将依赖ELasticsearch去自动处理数据结构。
_type 的名字可以是大写或小写， 不能包含下划线或逗号。 我们将使用 `blog 做为类型名。

**_id**
d仅仅是一个字符串， 它与 _index 和 _type 组合时， 就可以在ELasticsearch中唯一标识一个文档。 当创建一个文档， 你可以自定义 _id ， 也可以让Elasticsearch帮你自动生成。


### 1.6.2. 处理冲突
<a href="#menu" style="float:right">目录</a>

当某个文档被并发修改时，如何确保修改丢失?

在数据库中， 有两种通用的方法确保在并发更新时修改不丢失：
* 悲观并发控制
    * 这在关系型数据库中被广泛的使用， 假设冲突的更改经常发生， 为了解决冲突我们把访问区块化。 典型的例子是在读一行数据前锁定这行， 然后确保只有加锁的那个线程可以修改这行数据。
* 乐观并发控制
    * 被Elasticsearch使用， 假设冲突不经常发生， 也不区块化访问， 然而， 如果在读写过程中数据发生了变化， 更新操作将失败。 这时候由程序决定在失败后如何解决冲突。 实际情况中， 可以重新尝试更新， 刷新数据（重新读取） 或者直接反馈给用户。

Elasticsearch是分布式的。 当文档被创建、 更新或删除， 文档的新版本会被复制到集群的其它节点。 Elasticsearch即是同步的又是异步的， 意思是这些复制请求都是平行发送的， 并无序(out of sequence)的到达目的地。 这就需要一种方法确保老版本的文档永远不会覆盖新的版本.

每个文档都有一个 _version 号码， 这个号码在文档被改变时加一。Elasticsearch使用这个_version 保证所有修改都被正确排序。 当一个旧版本出现在新版本之后， 它会被简单的忽略。



## 1.7. 分布式增删改查
<a href="#menu" style="float:right">目录</a>

### 1.7.1. 路由文档到分片
<a href="#menu" style="float:right">目录</a>

当你索引一个文档， 它被存储在单独一个主分片上。 Elasticsearch是如何知道文档属于哪个分片的呢？ 当你创建一个新文档， 它是如何知道是应该存储在分片1还是分片2上的呢？
进程不能是随机的， 因为我们将来要检索文档。 事实上， 它根据一个简单的算法决定：shard = hash(routing) % number_of_primary_shards ，routing 值是一个任意字符串， 它默认是 _id 但也可以自定义。 这个 routing 字符串通过哈希函数生成一个数字， 然后除以主切片的数量得到一个余数(remainder)， 余数的范围永远是 0 到 number_of_primary_shards - 1 ， 这个数字就是特定文档所在的分片。
这也解释了为什么主分片的数量只能在创建索引时定义且不能修改： 如果主分片的数量在未来改变了， 所有先前的路由值就失效了， 文档也就永远找不到了。
有时用户认为固定数量的主分片会让之后的扩展变得很困难。 现实中， 有些技术会在你需要的时候让扩展变得容易。

### 1.7.2. 分片交互
<a href="#menu" style="float:right">目录</a>

每个节点都能够接收客户端的请求，每个节点都能知道任意文档所在的节点，所以也可以将请求转发到需要的节点。

#### 1.7.2.1. 新建，索引和删除文档
<a href="#menu" style="float:right">目录</a>


新建、索引和删除请求都是写(write)操作， 它们必须在主分片上成功完成才能复制到相关的复制分片上。

* 在主分片和复制分片上成功新建、 索引或删除一个文档必要的顺序步骤：
1. 客户端给 Node 1 发送新建、 索引或删除请求。
2. 节点使用文档的 _id 确定文档属于分片 0 。 它转发请求到 Node 3 ， 分片 0 位于这个节点上。
3. Node 3 在主分片上执行请求， 如果成功， 它转发请求到相应的位于 Node 1 和 Node 2 的复制节点上。 当所有的复制节点报告成功， Node 3 报告成功到请求的节点， 请求的节点再报告给客户端。

![document-write](https://github.com/lgjlife/Java-Study/blob/master/pic/elasticsearch/document-write.png?raw=true)

客户端接收到成功响应的时候， 文档的修改已经被应用于主分片和所有的复制分片。 你的修改生效了。
有很多可选的请求参数允许你更改这一过程。 你可能想牺牲一些安全来提高性能。 这一选项很少使用因为Elasticsearch已经足够快， 不过为了内容的完整我们将做一些阐述。

**replication**

复制默认的值是 sync 。 这将导致主分片得到复制分片的成功响应后才返回。
如果你设置 replication 为 async ， 请求在主分片上被执行后就会返回给客户端。 它依旧会转发请求给复制节点， 但你将不知道复制节点成功与否。
上面的这个选项不建议使用。 默认的 sync 复制允许Elasticsearch强制反馈传输。 async 复制可能会因为在不等待其它分片就绪的情况下发送过多的请求而使Elasticsearch过载。

**consistency**

默认主分片在尝试写入时需要规定数量(quorum)或过半的分片（可以是主节点或复制节点） 可用。 这是防止数据被写入到错的网络分区。 规定的数量计算公式如下：
int( (primary + number_of_replicas) / 2 ) + 1
consistency 允许的值为 one （只有一个主分片） ， all （所有主分片和复制分片） 或者默认的 quorum 或过半分片。
注意 number_of_replicas 是在索引中的的设置， 用来定义复制分片的数量， 而不是现在活动的复制节点的数量。 如果你定义了索引有3个复制节点， 那规定数量是：

int( (primary + 3 replicas) / 2 ) + 1 = 3
但如果你只有2个节点， 那你的活动分片不够规定数量， 也就不能索引或删除任何文档。

**timeout**
当分片副本不足时会怎样？ Elasticsearch会等待更多的分片出现。 默认等待一分钟。 如果需要， 你可以设置 timeout 参数让它终止的更早： 100 表示100毫秒， 30s 表示30秒。
注意：
新索引默认有 1 个复制分片， 这意味着为了满足 quorum 的要求需要两个活动的分片。 当然， 这个默认设置将阻止我们在单一节点集群中进行操作。 为了避开这个问题， 规定数量只有在 number_of_replicas 大于一时才生效。

#### 1.7.2.2. 索引文档
<a href="#menu" style="float:right">目录</a>


文档能够从主分片或任意一个复制分片被检索。

![document-write](https://github.com/lgjlife/Java-Study/blob/master/pic/elasticsearch/document-read.png?raw=true)

1. 客户端给 Node 1 发送get请求。
2. 节点使用文档的 _id 确定文档属于分片 0 。 分片 0 对应的复制分片在三个节点上都有。 此时， 它转发请求到 Node 2 。
3. Node 2 返回endangered给 Node 1 然后返回给客户端。

对于读请求， 为了平衡负载， 请求节点会为每个请求选择不同的分片——它会循环所有分片副本。

可能的情况是， 一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。 这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。

## 1.8. 面试小结之Elasticsearch篇
<a href="#menu" style="float:right">目录</a>

**Elasticsearch是如何实现Master选举的？**
* Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；
* 对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。
* 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。
* 补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。

**Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？**

* 当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；
* 当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。

**客户端在和集群连接时，如何选择特定的节点执行请求的？**

* TransportClient利用transport模块远程连接一个elasticsearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以 轮询 的方式与这些地址进行通信。

**详细描述一下Elasticsearch索引文档的过程。**
* 协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。
shard = hash(document_id) % (num_of_primary_shards)
* 当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Momery Buffer到Filesystem Cache的过程就叫做refresh；
* 当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；
* 在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。
* flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时；
![Elasticsearch索引文档的过程](https://upload-images.jianshu.io/upload_images/3709321-2084bd0268a42ae1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 补充：关于Lucene的Segement：
    * Lucene索引是由多个段组成，段本身是一个功能齐全的倒排索引。
    * 段是不可变的，允许Lucene将新的文档增量地添加到索引中，而不用从头重建索引。
    * 对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。
    * 为了解决这个问题，Elasticsearch会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。
    
**详细描述一下Elasticsearch更新和删除文档的过程**
* 删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；
* 磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。
* 在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。

**详细描述一下Elasticsearch搜索的过程。**
* 搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；
* 在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。
* 每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。
* 接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。
* 补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。

![Elasticsearch执行搜索的过程](https://upload-images.jianshu.io/upload_images/3709321-88f589037638c93d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**在Elasticsearch中，是怎么根据一个词找到对应的倒排索引的？**

* SEE：
    * Lucene的索引文件格式(1)
    * Lucene的索引文件格式(2)

**Elasticsearch在部署时，对Linux的设置有哪些优化方法？**
* 64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反。
* 如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。
* 如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。
* 即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。
* 请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。
* 通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。
* Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。
* 不要随意修改垃圾回收器（CMS）和各个线程池的大小。
* 把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。
* 内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。
* Lucene 使用了大量的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。

* 补充：索引阶段性能提升方法
    * 使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。
    * 存储：使用 SSD
    * 段和合并：Elasticsearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD，可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。 
    * 如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。
    * 如果你在做大批量导入，考虑通过设置index.number_of_replicas: 0 关闭副本。

**对于GC方面，在使用Elasticsearch时要注意什么？**
* SEE：https://elasticsearch.cn/article/32
* 倒排词典的索引需要常驻内存，无法GC，需要监控data node上segment memory增长趋势。
* 各类缓存，field cache, filter cache, indexing cache, bulk queue等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗？避免采用clear cache等“自欺欺人”的方式来释放内存。
* 避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan & scroll api来实现。
* cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。
想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。


**Elasticsearch对于大数据量（上亿量级）的聚合如何实现？**
* Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。

**在并发情况下，Elasticsearch如果保证读写一致？**
* 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；
另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。
* 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；* 如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。

**如何监控Elasticsearch集群状态？**
* Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。

**介绍下你们电商搜索的整体技术架构**
![整体技术架构](https://upload-images.jianshu.io/upload_images/3709321-3a013fdb77aa88fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**介绍一下你们的个性化搜索方案？**

* SEE 基于word2vec和Elasticsearch实现个性化搜索

**是否了解字典树？**

* 常用字典数据结构如下所示：
![常用字典数据结构](https://upload-images.jianshu.io/upload_images/3709321-7b6f0fab6f412f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有3个基本性质：
根节点不包含字符，除根节点外每一个节点都只包含一个字符。
从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
每个节点的所有子节点包含的字符都不相同。
![字典树](https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/8/8.4/1.jpg)


可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。
实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿子右兄弟表示法记录这棵树；
对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度O(1)。

**拼写纠错是如何实现的？**
* 拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；
* 编辑距离的计算过程：比如要计算batyu和beauty的编辑距离，先创建一个7×8的表（batyu长度为5，coffee长度为6，各加2），接着，在如下位置填入黑色数字。其他格的计算过程是取以下三个值的最小值：
如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0）
左方数字+1（对于3,3格来说为2）
上方数字+1（对于3,3格来说为2）
最终取右下角的值即为编辑距离的值3。

![编辑距离](https://upload-images.jianshu.io/upload_images/3709321-31bef8a5bbf14a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关系满足以下三条基本条件：
d(x,y) = 0 -- 假如x与y的距离为0，则x=y
d(x,y) = d(y,x)  -- x到y的距离等同于y到x的距离
d(x,y) + d(y,z) >= d(x,z) -- 三角不等式
* 根据三角不等式，则满足与query距离在n范围内的另一个字符转B，其与A的距离最大为d+n，最小为d-n。
* BK树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注n表示编辑距离恰好为n。比如，我们有棵树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”的边标号1，”book”到”cake”的边上标号4。从字典里构造好树后，无论何时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树中，我们先检查根节点，查找d(“book”, “boo”) = 1的边，然后检查标号为1的边的子节点，得到单词”books”。我们再计算距离d(“books”, “boo”)=2，则将新单词插在”books”之后，边标号为2。
* 查询相似词如下：计算单词与根节点的编辑距离d，然后递归查找每个子节点标号为d-n到d+n（包含）的边。假如被检查的节点与搜索单词的距离d小于n，则返回该节点并继续查询。比如输入cape且最大容忍距离为1，则先计算和根的编辑距离d(“book”, “cape”)=4，然后接着找和根节点之间编辑距离为3到5的，这个就找到了cake这个节点，计算d(“cake”, “cape”)=1，满足条件所以返回cake，然后再找和cake节点编辑距离是0到2的，分别找到cape和cart节点，这样就得到cape这个满足条件的结果。

![BK树](https://upload-images.jianshu.io/upload_images/3709321-7cdb109e6f73c192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


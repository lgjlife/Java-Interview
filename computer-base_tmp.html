<!DOCTYPE html>
<html>
<head>
<title>computer-base.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<span id="menu">
</span><!-- TOC -->
<ul>
<li><a href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1. 计算机&amp;网络&amp;操作系统</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">1.1. 计算机基础</a>
<ul>
<li><a href="#111-%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F">1.1.1. 数字系统</a>
<ul>
<li><a href="#1111-ascii">1.1.1.1. ASCII</a></li>
</ul>
</li>
<li><a href="#112-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">1.1.2. 数据存储</a></li>
<li><a href="#113-%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97">1.1.3. 数据运算</a></li>
<li><a href="#114-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90">1.1.4. 计算机组成</a>
<ul>
<li><a href="#1141-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90">1.1.4.1. 计算机组成</a></li>
<li><a href="#1142-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%BF%9E">1.1.4.2. 子系统互连</a></li>
<li><a href="#1143-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">1.1.4.3. 程序执行</a></li>
<li><a href="#1144-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.1.4.4. 计算机体系结构</a></li>
</ul>
</li>
<li><a href="#115-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">1.1.5. 程序设计语言</a>
<ul>
<li><a href="#1151-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80">1.1.5.1. 计算机语言</a></li>
<li><a href="#1152-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">1.1.5.2. 编程模式</a></li>
</ul>
</li>
<li><a href="#116-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">1.1.6. 软件工程</a>
<ul>
<li><a href="#1161-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">1.1.6.1. 开发过程模型</a></li>
<li><a href="#1162-%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5">1.1.6.2. 分析阶段</a></li>
<li><a href="#1163-%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5">1.1.6.3. 设计阶段</a></li>
<li><a href="#1164-%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5">1.1.6.4. 实现阶段</a></li>
<li><a href="#1165-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5">1.1.6.5. 测试阶段</a></li>
<li><a href="#1166-%E6%96%87%E6%A1%A3">1.1.6.6. 文档</a></li>
</ul>
</li>
<li><a href="#117-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.1.7. 数据结构</a></li>
<li><a href="#118-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.1.8. 抽象数据类型</a></li>
<li><a href="#119-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">1.1.9. 文件结构</a></li>
<li><a href="#1110-%E6%95%B0%E6%8D%AE%E5%BA%93">1.1.10. 数据库</a></li>
<li><a href="#1111-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9">1.1.11. 数据压缩</a></li>
<li><a href="#1112-%E5%AE%89%E5%85%A8">1.1.12. 安全</a></li>
</ul>
</li>
<li><a href="#12-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">1.2. 编译原理</a></li>
<li><a href="#13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1.3. 操作系统</a>
<ul>
<li><a href="#131-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.1. 操作系统基本概念</a>
<ul>
<li><a href="#1311-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD">1.3.1.1. 操作系统的功能</a></li>
<li><a href="#1312-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B">1.3.1.2. 操作系统发展过程</a></li>
<li><a href="#1313-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7">1.3.1.3. 操作系统的特性</a></li>
<li><a href="#1314-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.3.1.4. 操作系统的体系结构</a>
<ul>
<li><a href="#13141-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">1.3.1.4.1. 层次结构</a></li>
<li><a href="#13142-%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84">1.3.1.4.2. 微内核结构</a></li>
<li><a href="#13143-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">1.3.1.4.3. 基本特性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#132-linux%E5%9F%BA%E7%A1%80">1.3.2. Linux基础</a>
<ul>
<li><a href="#1321-linux%E5%90%84%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%AF%8F%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">1.3.2.1. Linux各目录及每个目录的详细介绍</a></li>
<li><a href="#1322-linux-%E5%92%8C-unix-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8C%BA%E5%88%AB">1.3.2.2. Linux 和 UNIX 的关系/区别</a></li>
<li><a href="#1323-%EF%BD%8Cinux%E7%89%88%E6%9C%AC">1.3.2.3. Ｌinux版本</a>
<ul>
<li><a href="#13231-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E6%97%8F">1.3.2.3.1. 常用的Linux发行版本族：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#133-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1.3.3. 进程管理</a>
<ul>
<li><a href="#1331-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.3.1. 进程的基本概念</a></li>
<li><a href="#1332-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">1.3.3.2. 进程控制</a>
<ul>
<li><a href="#13321-%E7%9B%B8%E5%85%B3%E7%9A%84linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">1.3.3.2.1. 相关的Linux系统调用</a></li>
</ul>
</li>
<li><a href="#1333-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">1.3.3.3. 进程同步</a>
<ul>
<li><a href="#13331-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E6%A6%82%E5%BF%B5">1.3.3.3.1. 临界资源的概念</a></li>
<li><a href="#13332-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5">1.3.3.3.2. 进程的互斥与同步</a></li>
</ul>
</li>
<li><a href="#1334-%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98">1.3.3.4. 经典的进程同步问题</a></li>
</ul>
</li>
<li><a href="#134-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">1.3.4. 进程通信</a>
<ul>
<li><a href="#1341-%E7%AE%A1%E9%81%93">1.3.4.1. 管道</a></li>
</ul>
</li>
<li><a href="#135-%E7%BA%BF%E7%A8%8B">1.3.5. 线程</a>
<ul>
<li><a href="#1351-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.5.1. 线程的基本概念</a></li>
<li><a href="#1352-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">1.3.5.2. 多线程的实现</a></li>
<li><a href="#1353-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87">1.3.5.3. 线程上下文</a></li>
<li><a href="#1354-linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.3.5.4. Linux进程和线程的区别</a></li>
</ul>
</li>
<li><a href="#136-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81">1.3.6. 处理机调度和死锁</a>
<ul>
<li><a href="#1361-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1">1.3.6.1. 处理机调度的层次</a></li>
<li><a href="#1362-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6">1.3.6.2. 进程调度</a></li>
<li><a href="#1363-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3. 调度算法</a>
<ul>
<li><a href="#13631-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3.1. 优先级调度算法</a></li>
<li><a href="#13632-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3.2. 轮转调度算法</a></li>
</ul>
</li>
<li><a href="#1364-linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.4. Linux的进程调度算法</a></li>
<li><a href="#1365-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">1.3.6.5. 产生死锁的原因和必要条件</a></li>
</ul>
</li>
<li><a href="#137-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86">1.3.7. 存储器管理</a>
<ul>
<li><a href="#1371-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">1.3.7.1. 存储器的层次结构</a></li>
<li><a href="#1372-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5">1.3.7.2. 程序的装入和链接</a></li>
<li><a href="#1373-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">1.3.7.3. 连续分配方式</a></li>
<li><a href="#1374-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.4. 基本分段存储管理方式</a></li>
<li><a href="#1375-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.7.5. 虚拟存储器的基本概念</a></li>
<li><a href="#1376-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.6. 请求分页存储管理方式</a></li>
<li><a href="#1377-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">1.3.7.7. 页面置换算法</a></li>
<li><a href="#1378-%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.8. 请求分段管理方式</a></li>
</ul>
</li>
<li><a href="#138-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">1.3.8. 设备管理</a>
<ul>
<li><a href="#1381-io%E7%B3%BB%E7%BB%9F">1.3.8.1. I/O系统</a></li>
<li><a href="#1382-io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">1.3.8.2. I/O控制方式</a></li>
<li><a href="#1383-%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86">1.3.8.3. 缓冲管理</a></li>
<li><a href="#1384-io%E8%BD%AF%E4%BB%B6">1.3.8.4. I/O软件</a></li>
<li><a href="#1385-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D">1.3.8.5. 设备分配</a></li>
<li><a href="#1386-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86">1.3.8.6. 磁盘存储器的管理</a></li>
</ul>
</li>
<li><a href="#139-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">1.3.9. 文件管理</a>
<ul>
<li><a href="#1391-%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.3.9.1. 文件和文件系统</a></li>
<li><a href="#1392-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84">1.3.9.2. 文件的结构</a>
<ul>
<li><a href="#13921-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">1.3.9.2.1. 文件的逻辑结构</a></li>
<li><a href="#13922-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">1.3.9.2.2. 文件的物理结构</a></li>
</ul>
</li>
<li><a href="#1393-%E5%A4%96%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">1.3.9.3. 外存的分配方式</a></li>
<li><a href="#1394-%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86">1.3.9.4. 目录管理</a></li>
<li><a href="#1395-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86">1.3.9.5. 文件存储空间的管理</a></li>
<li><a href="#1396-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4">1.3.9.6. 文件共享与文件保护</a></li>
<li><a href="#1397-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A7%E5%88%B6">1.3.9.7. 数据一致性控制</a></li>
</ul>
</li>
<li><a href="#1310-%EF%BD%8Cinux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">1.3.10. Ｌinux网络基础</a>
<ul>
<li><a href="#13101-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.3.10.1. 网络配置文件</a></li>
</ul>
</li>
<li><a href="#1311-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7">1.3.11. 系统安全性</a></li>
<li><a href="#1312-unix%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84">1.3.12. Unix系统内核结构</a></li>
</ul>
</li>
<li><a href="#14-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B">1.4. Linux系统编程</a>
<ul>
<li><a href="#141-%E6%A0%87%E5%87%86">1.4.1. 标准</a>
<ul>
<li><a href="#1411-posix">1.4.1.1. POSIX</a></li>
<li><a href="#1412-sytem-v">1.4.1.2. Sytem V</a></li>
<li><a href="#1413-%E4%BD%BF%E7%94%A8">1.4.1.3. 使用</a></li>
</ul>
</li>
<li><a href="#142-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.4.2. 基本概念</a>
<ul>
<li><a href="#1421-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83">1.4.2.1. 操作系统的核心</a></li>
<li><a href="#1422-shell">1.4.2.2. shell</a></li>
<li><a href="#1423-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84">1.4.2.3. 用户和组</a></li>
<li><a href="#1424-%E5%8D%95%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E7%9B%AE%E5%BD%95%E9%93%BE%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6">1.4.2.4. 单根目录层级，目录，链接以及文件</a></li>
<li><a href="#1425-%E6%96%87%E4%BB%B6io%E6%A8%A1%E5%9E%8B">1.4.2.5. 文件IO模型</a></li>
<li><a href="#1426-%E7%A8%8B%E5%BA%8F">1.4.2.6. 程序</a></li>
<li><a href="#1427-%E8%BF%9B%E7%A8%8B">1.4.2.7. 进程</a></li>
<li><a href="#1428-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84">1.4.2.8. 内存映射</a></li>
<li><a href="#1429-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93">1.4.2.9. 静态库和共享库</a></li>
<li><a href="#14210-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%92%8C%E5%90%8C%E6%AD%A5">1.4.2.10. 进程间通信和同步</a></li>
<li><a href="#14211-%E4%BF%A1%E5%8F%B7">1.4.2.11. 信号</a></li>
<li><a href="#14212-%E7%BA%BF%E7%A8%8B">1.4.2.12. 线程</a></li>
<li><a href="#14213-%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8Cshell%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6">1.4.2.13. 进程组和shell任务控制</a></li>
<li><a href="#14214-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B">1.4.2.14. 会话，控制终端和控制进程</a></li>
<li><a href="#14215-%E4%BC%AA%E7%BB%88%E7%AB%AF">1.4.2.15. 伪终端</a></li>
<li><a href="#14216-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">1.4.2.16. 日期和时间</a></li>
<li><a href="#14217-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84">1.4.2.17. 客户端服务器架构</a></li>
<li><a href="#14218-%E5%AE%9E%E6%97%B6%E6%80%A7">1.4.2.18. 实时性</a></li>
<li><a href="#14219-%EF%BC%8Fproc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.4.2.19. ／proc文件系统</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">1.5. 计算机网络</a>
<ul>
<li><a href="#151-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.5.1. 网络基础知识</a>
<ul>
<li><a href="#1511-osi%E7%BD%91%E8%B7%AF%E5%88%86%E5%B1%82">1.5.1.1. OSI网路分层</a></li>
<li><a href="#1512-%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD">1.5.1.2. 关键术语</a></li>
</ul>
</li>
<li><a href="#152-%E7%BD%91%E7%BB%9C%E5%B1%82">1.5.2. 网络层</a>
<ul>
<li><a href="#1521-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%8F%91%E9%80%81">1.5.2.1. 寻址和发送</a></li>
<li><a href="#1522-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.5.2.2. 基本概念</a></li>
<li><a href="#1523-ip%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%B9%89">1.5.2.3. IP地址定义</a></li>
<li><a href="#1524-ipv4%E6%95%B0%E6%8D%AE%E6%8A%A5">1.5.2.4. IPV4数据报</a></li>
<li><a href="#1525-ip%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9">1.5.2.5. IP路由选择</a></li>
<li><a href="#1526-ipv6%E5%8D%8F%E8%AE%AE">1.5.2.6. IPV6协议</a></li>
<li><a href="#1527-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.5.2.7. 常用命令</a>
<ul>
<li><a href="#15271-ping">1.5.2.7.1. ping</a></li>
<li><a href="#15272-ifconfig">1.5.2.7.2. ifconfig</a></li>
<li><a href="#15273-netstat">1.5.2.7.3. netstat</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#153-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90dns">1.5.3. 域名解析DNS</a>
<ul>
<li><a href="#1531-dns-%E5%9F%BA%E7%A1%80">1.5.3.1. DNS 基础</a></li>
</ul>
</li>
<li><a href="#154-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEarp">1.5.4. 地址解析协议ARP</a>
<ul>
<li><a href="#1541-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1.5.4.1. 基本原理</a></li>
<li><a href="#1542-arp%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98">1.5.4.2. ARP高速缓存</a></li>
<li><a href="#1543-arp%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F">1.5.4.3. ARP分组格式</a></li>
</ul>
</li>
<li><a href="#155-%E5%B9%BF%E6%92%AD%E5%92%8C%E5%A4%9A%E6%92%AD">1.5.5. 广播和多播</a>
<ul>
<li><a href="#1551-%E5%B9%BF%E6%92%AD">1.5.5.1. 广播</a>
<ul>
<li><a href="#15511-%E5%8F%97%E9%99%90%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.1. 受限的广播</a></li>
<li><a href="#15512-%E6%8C%87%E5%90%91%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.2. 指向网络的广播</a></li>
<li><a href="#15513-%E6%8C%87%E5%90%91%E5%AD%90%E7%BD%91%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.3. 指向子网的广播</a></li>
<li><a href="#15514-%E6%8C%87%E5%90%91%E6%89%80%E6%9C%89%E5%AD%90%E7%BD%91%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.4. 指向所有子网的广播</a></li>
</ul>
</li>
<li><a href="#1552-%E5%A4%9A%E6%92%AD">1.5.5.2. 多播</a>
<ul>
<li><a href="#15521-%E5%A4%9A%E6%92%AD%E7%BB%84%E5%9C%B0%E5%9D%80">1.5.5.2.1. 多播组地址</a></li>
<li><a href="#15522-%E5%A4%9A%E6%92%AD%E7%BB%84%E5%9C%B0%E5%9D%80%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2">1.5.5.2.2. 多播组地址到以太网地址的转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#156-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp">1.5.6. 用户数据报协议UDP</a>
<ul>
<li><a href="#1561-udp%E5%8D%8F%E8%AE%AE">1.5.6.1. udp协议</a></li>
<li><a href="#1562-udp%E6%A0%A1%E9%AA%8C%E5%92%8C">1.5.6.2. udp校验和</a></li>
<li><a href="#1563-%E6%9C%80%E5%A4%A7udp%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%95%BF%E5%BA%A6">1.5.6.3. 最大UDP数据报长度</a></li>
<li><a href="#1564-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.5.6.4. 应用场景</a></li>
</ul>
</li>
<li><a href="#157-tcp%E5%92%8Cudp%E5%B7%AE%E5%88%AB">1.5.7. TCP和UDP差别</a>
- <a href="#15701-%E7%AB%AF%E5%8F%A3">1.5.7.0.1. 端口</a></li>
<li><a href="#158-tcp">1.5.8. TCP</a>
<ul>
<li><a href="#1581-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80">1.5.8.1. 传输控制协议基础</a>
<ul>
<li><a href="#15811-arq%E5%92%8C%E9%87%8D%E4%BC%A0">1.5.8.1.1. ARQ和重传</a></li>
<li><a href="#15812-%E5%88%86%E7%BB%84%E7%AA%97%E5%8F%A3%E5%92%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">1.5.8.1.2. 分组窗口和滑动窗口</a></li>
<li><a href="#15813-%E5%8F%98%E9%87%8F%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">1.5.8.1.3. 变量窗口:流量控制和拥塞控制</a></li>
<li><a href="#15814-tcp%E5%9F%BA%E7%A1%80">1.5.8.1.4. TCP基础</a></li>
<li><a href="#15815-tcp%E5%A4%B4%E9%83%A8%E5%92%8C%E5%B0%81%E8%A3%85">1.5.8.1.5. TCP头部和封装</a></li>
</ul>
</li>
<li><a href="#1582-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">1.5.8.2. 连接管理</a></li>
<li><a href="#1583-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">1.5.8.3. 超时重传机制</a></li>
<li><a href="#1584-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">1.5.8.4. 数据流和窗口机制</a></li>
<li><a href="#1585-%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6">1.5.8.5. 阻塞控制</a></li>
<li><a href="#1586-tcp%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6">1.5.8.6. TCP保活机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%E7%BD%91%E7%BB%9Chttp">1.6. 网络HTTP</a>
<ul>
<li><a href="#161-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.6.1. 基本概念</a>
<ul>
<li><a href="#1611-%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%B5%81%E7%A8%8B">1.6.1.1. 访问一个网站的流程</a></li>
<li><a href="#1612-%E8%B5%84%E6%BA%90">1.6.1.2. 资源</a>
<ul>
<li><a href="#16121-%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8Bmime">1.6.1.2.1. 媒体类型(MIME)</a></li>
<li><a href="#16122-url%E5%92%8C%E8%B5%84%E6%BA%90">1.6.1.2.2. URL和资源</a></li>
</ul>
</li>
<li><a href="#1613-http%E6%8A%A5%E6%96%87">1.6.1.3. HTTP报文</a>
<ul>
<li><a href="#16131-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">1.6.1.3.1. 请求报文和响应报文</a></li>
<li><a href="#16132-%E9%A6%96%E9%83%A8">1.6.1.3.2. 首部</a></li>
<li><a href="#16133-%E6%96%B9%E6%B3%95">1.6.1.3.3. 方法</a></li>
<li><a href="#16134-%E7%8A%B6%E6%80%81%E7%A0%81">1.6.1.3.4. 状态码</a></li>
</ul>
</li>
<li><a href="#1614-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">1.6.1.4. 连接管理</a>
<ul>
<li><a href="#16141-%E5%AF%B9tcp%E6%80%A7%E8%83%BD%E7%9A%84%E8%80%83%E8%99%91">1.6.1.4.1. 对TCP性能的考虑</a></li>
<li><a href="#16142-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5">1.6.1.4.2. 持久连接</a>
<ul>
<li><a href="#161421-tcp%E8%BF%9E%E6%8E%A5">1.6.1.4.2.1. TCP连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1615-%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96">1.6.1.5. 版本变化</a></li>
</ul>
</li>
<li><a href="#162-https">1.6.2. HTTPS</a>
<ul>
<li><a href="#1621-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E7%9B%AE%E6%A0%87">1.6.2.1. HTTP协议的缺点以及改进目标</a></li>
<li><a href="#1622-%E5%AF%86%E7%A0%81%E5%9F%BA%E7%A1%80">1.6.2.2. 密码基础</a></li>
<li><a href="#1623-https%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%B9%E8%BF%9B">1.6.2.3. HTTPS协议的改进</a></li>
<li><a href="#1624-https%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.6.2.4. HTTPS实现原理</a></li>
<li><a href="#1625-%E4%B8%8Ehttp%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB">1.6.2.5. 与HTTP原理区别</a></li>
<li><a href="#1626-%E4%BC%98%E7%BC%BA%E7%82%B9">1.6.2.6. 优缺点</a></li>
</ul>
</li>
<li><a href="#163-http%E7%BB%93%E6%9E%84">1.6.3. HTTP结构</a>
<ul>
<li><a href="#1631-web%E6%9C%8D%E5%8A%A1%E5%99%A8">1.6.3.1. WEB服务器</a></li>
<li><a href="#1632-%E4%BB%A3%E7%90%86">1.6.3.2. 代理</a></li>
<li><a href="#1633-%E7%BC%93%E5%AD%98">1.6.3.3. 缓存</a></li>
<li><a href="#1634-%E7%BD%91%E5%85%B3">1.6.3.4. 网关</a></li>
</ul>
</li>
<li><a href="#164-%E8%AF%86%E5%88%AB%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8">1.6.4. 识别,认证与安全</a>
<ul>
<li><a href="#1641-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%86%E5%88%AB%E4%B8%8Ecookie%E6%9C%BA%E5%88%B6">1.6.4.1. 客户端识别与Cookie机制</a>
<ul>
<li><a href="#16411-cookie">1.6.4.1.1. Cookie</a></li>
</ul>
</li>
<li><a href="#1642-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6">1.6.4.2. 基本认证机制</a></li>
<li><a href="#1643-%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81">1.6.4.3. 摘要认证</a></li>
</ul>
</li>
<li><a href="#165-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81">1.6.5. 实体和编码</a>
<ul>
<li><a href="#1651-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8">1.6.5.1. 实体首部</a></li>
<li><a href="#1652-http%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">1.6.5.2. HTTP的媒体类型</a></li>
</ul>
</li>
<li><a href="#166-%E5%9B%BD%E9%99%85%E5%8C%96">1.6.6. 国际化</a></li>
<li><a href="#167-web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1">1.6.7. WEB主机托管</a></li>
<li><a href="#168-%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">1.6.8. 重定向和负载均衡</a></li>
</ul>
</li>
<li><a href="#17-web-socket">1.7. WEB Socket</a>
<ul>
<li><a href="#171-websocket%E4%B8%8Ehttp">1.7.1. websocket与http</a></li>
<li><a href="#172-%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F">1.7.2. 数据帧格式</a></li>
<li><a href="#173-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92">1.7.3. 数据传递</a></li>
<li><a href="#174-%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%8C%81%E5%BF%83%E8%B7%B3">1.7.4. 连接保持+心跳</a></li>
<li><a href="#175-sec-websocket-keyaccept%E7%9A%84%E4%BD%9C%E7%94%A8">1.7.5. Sec-WebSocket-Key/Accept的作用</a></li>
<li><a href="#176-%E6%95%B0%E6%8D%AE%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8">1.7.6. 数据掩码的作用</a></li>
<li><a href="#177-websocket%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">1.7.7. WebSocket运行流程</a></li>
<li><a href="#178-springboot--websocket%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B">1.7.8. SpringBoot + WebSocket实现案例</a>
<ul>
<li><a href="#1781-%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.7.8.1. 第一种实现方法</a></li>
<li><a href="#1782-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.7.8.2. 第二种实现方法</a></li>
<li><a href="#1783-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">1.7.8.3. 补充说明</a></li>
<li><a href="#1784-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0js%E6%96%B9%E5%BC%8F%E5%92%8Cjava-websocketclient%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">1.7.8.4. 客户端的实现，js方式和java WebSocketClient两种方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#18-unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B">1.8. Unix环境编程</a>
<ul>
<li><a href="#181-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.8.1. 基本概念</a></li>
<li><a href="#182-io%E6%A8%A1%E5%9E%8B">1.8.2. IO模型</a></li>
<li><a href="#183-selectpollepoll%E6%AF%94%E8%BE%83">1.8.3. select&amp;poll&amp;epoll比较</a>
<ul>
<li><a href="#1831-%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88">1.8.3.1. 整体概览</a></li>
<li><a href="#1832-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93">1.8.3.2. 对比总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#19-shell">1.9. Shell</a>
<ul>
<li><a href="#191-%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85">1.9.1. 文件安装</a>
<ul>
<li><a href="#1911-deb%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">1.9.1.1. deb文件操作</a></li>
</ul>
</li>
<li><a href="#192-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.9.2. 常用命令</a>
<ul>
<li><a href="#1921-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">1.9.2.1. 系统信息</a></li>
<li><a href="#1922-proc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.2.2. /proc 文件系统</a></li>
<li><a href="#1923-ssh">1.9.2.3. SSH</a></li>
<li><a href="#1924-%E7%BD%91%E7%BB%9C">1.9.2.4. 网络</a></li>
<li><a href="#1925-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1.9.2.5. 进程管理</a></li>
<li><a href="#1926-%E5%BF%AB%E6%8D%B7%E9%94%AE">1.9.2.6. 快捷键</a></li>
<li><a href="#1927-%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8">1.9.2.7. 查看端口占用</a></li>
<li><a href="#1928-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3">1.9.2.8. 文件相关</a></li>
<li><a href="#1929-%E7%9B%91%E6%B5%8B%E7%A8%8B%E5%BA%8F">1.9.2.9. 监测程序</a>
<ul>
<li><a href="#19291-%E6%8E%A2%E6%9F%A5%E8%BF%9B%E7%A8%8B">1.9.2.9.1. 探查进程</a></li>
<li><a href="#19292-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B%E8%BF%9B%E7%A8%8B">1.9.2.9.2. 实时监测进程</a></li>
<li><a href="#19293-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">1.9.2.9.3. 结束进程</a></li>
</ul>
</li>
<li><a href="#19210-%E7%9B%91%E6%B5%8B%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4">1.9.2.10. 监测磁盘空间</a>
<ul>
<li><a href="#192101-df-%E5%91%BD%E4%BB%A4">1.9.2.10.1. df 命令</a></li>
<li><a href="#192102-du-%E5%91%BD%E4%BB%A4">1.9.2.10.2. du 命令</a></li>
</ul>
</li>
<li><a href="#19211-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">1.9.2.11. 处理数据文件</a>
<ul>
<li><a href="#192111-%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE">1.9.2.11.1. 排序数据</a></li>
<li><a href="#192112-%E6%90%9C%E7%B4%A2%E6%95%B0%E6%8D%AEgrep">1.9.2.11.2. 搜索数据grep</a></li>
<li><a href="#192113-%E5%BD%92%E6%A1%A3%E6%95%B0%E6%8D%AE">1.9.2.11.3. 归档数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#193-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3. 环境变量</a>
<ul>
<li><a href="#1931-%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1. 什么是环境变量</a>
<ul>
<li><a href="#19311-%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1.1. 全局环境变量</a></li>
<li><a href="#19312-%E5%B1%80%E9%83%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1.2. 局部环境变量</a></li>
</ul>
</li>
<li><a href="#1932-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">1.9.3.2. 设置用户定义变量</a>
<ul>
<li><a href="#19321-%E8%AE%BE%E7%BD%AE%E5%B1%80%E9%83%A8%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F">1.9.3.2.1. 设置局部用户变量</a></li>
<li><a href="#19322-%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">1.9.3.2.2. 设置全局变量</a></li>
</ul>
</li>
<li><a href="#1933-%E5%88%A0%E9%99%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.3. 删除环境变量</a></li>
<li><a href="#1934-%E9%BB%98%E8%AE%A4%E7%9A%84shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.4. 默认的shell环境变量</a></li>
<li><a href="#1935-%E8%AE%BE%E7%BD%AEpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.5. 设置PATH环境变量</a></li>
<li><a href="#1936-%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.6. 定位系统环境变量</a>
<ul>
<li><a href="#19361-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%81%E4%B9%85%E5%8C%96">1.9.3.6.1. 环境变量持久化</a></li>
</ul>
</li>
<li><a href="#1937-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F">1.9.3.7. 数组变量</a></li>
</ul>
</li>
<li><a href="#194-%E7%90%86%E8%A7%A3linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">1.9.4. 理解Linux文件权限</a>
<ul>
<li><a href="#1941-linux-%E5%AE%89%E5%85%A8%E6%80%A7">1.9.4.1. Linux 安全性</a>
<ul>
<li><a href="#19411-etcpasswd-%E6%96%87%E4%BB%B6">1.9.4.1.1. /etc/passwd 文件</a></li>
<li><a href="#19412-etcshadow-%E6%96%87%E4%BB%B6">1.9.4.1.2. /etc/shadow 文件</a></li>
<li><a href="#19413-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7">1.9.4.1.3. 添加新用户</a></li>
<li><a href="#19414-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">1.9.4.1.4. 删除用户</a></li>
<li><a href="#19415-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7">1.9.4.1.5. 修改用户</a></li>
</ul>
</li>
<li><a href="#1942-%E4%BD%BF%E7%94%A8linux%E7%BB%84">1.9.4.2. 使用Linux组</a>
<ul>
<li><a href="#19421-etcgroup-%E6%96%87%E4%BB%B6">1.9.4.2.1. /etc/group 文件</a></li>
<li><a href="#19422-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BB%84">1.9.4.2.2. 创建新组</a></li>
<li><a href="#19423-%E4%BF%AE%E6%94%B9%E7%BB%84">1.9.4.2.3. 修改组</a></li>
</ul>
</li>
<li><a href="#1943-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">1.9.4.3. 理解文件权限</a>
<ul>
<li><a href="#19431-%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AC%A6">1.9.4.3.1. 使用文件权限符</a></li>
</ul>
</li>
<li><a href="#1944-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE">1.9.4.4. 改变安全性设置</a></li>
<li><a href="#1945-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6">1.9.4.5. 共享文件</a></li>
</ul>
</li>
<li><a href="#195-%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5. 管理文件系统</a>
<ul>
<li><a href="#1951-linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.1. Linux 文件系统</a></li>
<li><a href="#1952-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.2. 操作文件系统</a></li>
<li><a href="#1953-%E9%80%BB%E8%BE%91%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.3. 逻辑文件系统</a></li>
</ul>
</li>
<li><a href="#196-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.6. Shell脚本编程</a>
<ul>
<li><a href="#1961-%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4">1.9.6.1. 基本脚本命令</a>
<ul>
<li><a href="#19611-%E5%88%9B%E5%BB%BA-shell-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6">1.9.6.1.1. 创建 shell 脚本文件</a></li>
<li><a href="#19612-%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%89%93%E5%8D%B0">1.9.6.1.2. 脚本中打印</a></li>
<li><a href="#19613-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.6.1.3. 使用变量</a></li>
<li><a href="#19614-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">1.9.6.1.4. 命令替换</a></li>
<li><a href="#19615-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">1.9.6.1.5. 重定向输入和输出</a></li>
<li><a href="#19616-%E7%AE%A1%E9%81%93">1.9.6.1.6. 管道</a></li>
<li><a href="#19617-%E6%89%A7%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97">1.9.6.1.7. 执行数学运算</a></li>
<li><a href="#19618-%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC">1.9.6.1.8. 退出脚本</a></li>
</ul>
</li>
<li><a href="#1962-%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.6.2. 结构化命令</a>
<ul>
<li><a href="#19621-%E4%BD%BF%E7%94%A8-if-then-%E8%AF%AD%E5%8F%A5">1.9.6.2.1. 使用 if-then 语句</a></li>
<li><a href="#19622-if-then-else-%E8%AF%AD%E5%8F%A5">1.9.6.2.2. if-then-else 语句</a></li>
<li><a href="#19623-%E5%B5%8C%E5%A5%97-if">1.9.6.2.3. 嵌套 if</a></li>
<li><a href="#19624-test-%E5%91%BD%E4%BB%A4">1.9.6.2.4. test 命令</a></li>
<li><a href="#19625-%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95">1.9.6.2.5. 复合条件测试</a></li>
<li><a href="#19626-if-then-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">1.9.6.2.6. if-then 的高级特性</a></li>
<li><a href="#19627-case-%E5%91%BD%E4%BB%A4">1.9.6.2.7. case 命令</a></li>
</ul>
</li>
<li><a href="#1963-%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.6.3. 更多结构化命令</a>
<ul>
<li><a href="#19631-for%E5%91%BD%E4%BB%A4">1.9.6.3.1. for命令</a></li>
<li><a href="#19632-c-%E8%AF%AD%E8%A8%80%E7%9A%84-for-%E5%91%BD%E4%BB%A4">1.9.6.3.2. C 语言的 for 命令</a></li>
<li><a href="#19633-while-%E5%91%BD%E4%BB%A4">1.9.6.3.3. while 命令</a></li>
<li><a href="#19634-until-%E5%91%BD%E4%BB%A4">1.9.6.3.4. until 命令</a></li>
<li><a href="#19635-%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF">1.9.6.3.5. 控制循环</a></li>
<li><a href="#19636-%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%BE%93%E5%87%BA">1.9.6.3.6. 处理循环的输出</a></li>
</ul>
</li>
<li><a href="#1964-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">1.9.6.4. 处理用户输入</a>
<ul>
<li><a href="#19641-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">1.9.6.4.1. 命令行参数</a></li>
<li><a href="#19642-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">1.9.6.4.2. 特殊参数变量</a></li>
<li><a href="#19643-%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F">1.9.6.4.3. 移动变量</a></li>
<li><a href="#19644-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9">1.9.6.4.4. 处理选项</a></li>
<li><a href="#19645-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">1.9.6.4.5. 获得用户输入</a></li>
</ul>
</li>
<li><a href="#1965-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE">1.9.6.5. 呈现数据</a>
<ul>
<li><a href="#19651-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">1.9.6.5.1. 理解输入和输出</a></li>
<li><a href="#19652-%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA">1.9.6.5.2. 脚本中重定向输出</a></li>
<li><a href="#19653-%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5">1.9.6.5.3. 脚本中重定向输入</a></li>
<li><a href="#19654-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">1.9.6.5.4. 创建自己的重定向</a></li>
<li><a href="#19655-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">1.9.6.5.5. 列出打开的文件描述符</a></li>
<li><a href="#19656-%E9%98%BB%E6%AD%A2%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA">1.9.6.5.6. 阻止命令输出</a></li>
<li><a href="#19657-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">1.9.6.5.7. 创建临时文件</a></li>
<li><a href="#19658-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF">1.9.6.5.8. 记录消息</a></li>
</ul>
</li>
<li><a href="#1966-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC">1.9.6.6. 控制脚本</a>
<ul>
<li><a href="#19661-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7">1.9.6.6.1. 处理信号</a></li>
<li><a href="#19662-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">1.9.6.6.2. 以后台模式运行脚本</a></li>
<li><a href="#19663-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">1.9.6.6.3. 在非控制台下运行脚本</a></li>
<li><a href="#19664-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">1.9.6.6.4. 作业控制</a></li>
<li><a href="#19665-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6">1.9.6.6.5. 调整谦让度</a></li>
<li><a href="#19666-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A">1.9.6.6.6. 定时运行作业</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#197-%E9%AB%98%E7%BA%A7-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.7. 高级 shell 脚本编程</a>
<ul>
<li><a href="#1971-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">1.9.7.1. 创建函数</a>
<ul>
<li><a href="#19711-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0">1.9.7.1.1. 基本的脚本函数</a></li>
<li><a href="#19712-%E8%BF%94%E5%9B%9E%E5%80%BC">1.9.7.1.2. 返回值</a></li>
<li><a href="#19713-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.7.1.3. 在函数中使用变量</a></li>
<li><a href="#19714-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">1.9.7.1.4. 数组变量和函数</a></li>
<li><a href="#19715-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">1.9.7.1.5. 函数递归</a></li>
<li><a href="#19716-%E5%88%9B%E5%BB%BA%E5%BA%93">1.9.7.1.6. 创建库</a></li>
<li><a href="#19717-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">1.9.7.1.7. 在命令行上使用函数</a></li>
</ul>
</li>
<li><a href="#1972-%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.7.2. 图形化桌面环境中的脚本编程</a></li>
<li><a href="#1973-%E5%88%9D%E8%AF%86-sed-%E5%92%8C-gawk">1.9.7.3. 初识 sed 和 gawk</a>
<ul>
<li><a href="#19731-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">1.9.7.3.1. 文本处理</a></li>
<li><a href="#19732-sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80">1.9.7.3.2. sed编辑器基础</a></li>
</ul>
</li>
<li><a href="#1974-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4. 正则表达式</a>
<ul>
<li><a href="#19741-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4.1. 什么是正则表达式</a></li>
<li><a href="#19742-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F">1.9.7.4.2. 定义BRE模式</a></li>
<li><a href="#19743-%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4.3. 扩展正则表达式</a></li>
<li><a href="#19744-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E6%88%98">1.9.7.4.4. 正则表达式实战</a></li>
</ul>
</li>
<li><a href="#1975-sed-%E8%BF%9B%E9%98%B6">1.9.7.5. sed 进阶</a>
<ul>
<li><a href="#19751-%E5%A4%9A%E8%A1%8C%E5%91%BD%E4%BB%A4">1.9.7.5.1. 多行命令</a></li>
<li><a href="#19752-%E4%BF%9D%E6%8C%81%E7%A9%BA%E9%97%B4">1.9.7.5.2. 保持空间</a></li>
<li><a href="#19753-%E6%8E%92%E9%99%A4%E5%91%BD%E4%BB%A4">1.9.7.5.3. 排除命令</a></li>
<li><a href="#19754-%E6%94%B9%E5%8F%98%E6%B5%81">1.9.7.5.4. 改变流</a></li>
<li><a href="#19755-%E6%A8%A1%E5%BC%8F%E6%9B%BF%E4%BB%A3">1.9.7.5.5. 模式替代</a></li>
<li><a href="#19756-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8sed">1.9.7.5.6. 在脚本中使用sed</a></li>
<li><a href="#19757-%E5%88%9B%E5%BB%BAsed%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7">1.9.7.5.7. 创建sed实用工具</a></li>
</ul>
</li>
<li><a href="#1976-gawk-%E8%BF%9B%E9%98%B6">1.9.7.6. gawk 进阶</a>
<ul>
<li><a href="#19761-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.7.6.1. 使用变量</a></li>
<li><a href="#19762-%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">1.9.7.6.2. 处理数组</a></li>
<li><a href="#19763-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F">1.9.7.6.3. 使用模式</a></li>
<li><a href="#19764-%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.7.6.4. 结构化命令</a></li>
<li><a href="#19765-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0">1.9.7.6.5. 格式化打印</a></li>
<li><a href="#19766-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0">1.9.7.6.6. 内建函数</a></li>
<li><a href="#19767-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">1.9.7.6.7. 自定义函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1. 计算机&amp;网络&amp;操作系统</h1>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">1.1. 计算机基础</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="111-%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F">1.1.1. 数字系统</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>整数</strong></p>
<p>非实数:</p>
<p>$\pm S_{k-1} * 10^{k-1} + S_{k-2} * 10^{k-2}... S_{1} * 10^{1} + S_{0} * 10^{0}$</p>
<p>$1234 = 1<em>10^3 + 2</em>10^2 + 3<em>10^1+ 4</em>10^0$</p>
<p>实数:
$\pm S_{k-1} * 10^{k-1} + S_{k-2} * 10^{k-2}... S_{1} * 10^{1} + S_{0} * 10^{0}$</p>
<p><strong>实数</strong></p>
<p><strong>二进制</strong></p>
<p><strong>八进制</strong></p>
<p><strong>十六进制</strong></p>
<h4 id="1111-ascii">1.1.1.1. ASCII</h4>
<ul>
<li>ASCII控制字符</li>
</ul>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>缩写</th>
<th>名称/意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000</td>
<td>0</td>
<td>00</td>
<td>NUL</td>
<td>空字符（Null）</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>01</td>
<td>SOH</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>02</td>
<td>STX</td>
<td>本文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>03</td>
<td>ETX</td>
<td>本文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>4</td>
<td>04</td>
<td>EOT</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>5</td>
<td>05</td>
<td>ENQ</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>6</td>
<td>06</td>
<td>ACK</td>
<td>确认回应</td>
</tr>
<tr>
<td>0000 0111</td>
<td>7</td>
<td>07</td>
<td>BEL</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>8</td>
<td>08</td>
<td>BS</td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>9</td>
<td>09</td>
<td>HT</td>
<td>水平定位符号</td>
</tr>
<tr>
<td>0000 1010</td>
<td>10</td>
<td>0A</td>
<td>LF</td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>11</td>
<td></td>
<td>0B</td>
<td>VT</td>
</tr>
<tr>
<td>0000 1100</td>
<td>12</td>
<td>0C</td>
<td>FF</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>13</td>
<td>0D</td>
<td>CR</td>
<td>归位键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>14</td>
<td>0E</td>
<td>SO</td>
<td>取消变换（Shift out）</td>
</tr>
<tr>
<td>0000 1111</td>
<td>15</td>
<td>0F</td>
<td>SI</td>
<td>启用变换（Shift in）</td>
</tr>
<tr>
<td>0001 0000</td>
<td>16</td>
<td>10</td>
<td>DLE</td>
<td>跳出数据通讯</td>
</tr>
<tr>
<td>0001 0001</td>
<td>17</td>
<td>11</td>
<td>DC1</td>
<td>设备控制一（XON 启用软件速度控制）</td>
</tr>
<tr>
<td>0001 0010</td>
<td>18</td>
<td>12</td>
<td>DC2</td>
<td>设备控制二</td>
</tr>
<tr>
<td>0001 0011</td>
<td>19</td>
<td>13</td>
<td>DC3</td>
<td>设备控制三（XOFF 停用软件速度控制）</td>
</tr>
<tr>
<td>0001 0100</td>
<td>20</td>
<td>14</td>
<td>DC4</td>
<td>设备控制四</td>
</tr>
<tr>
<td>0001 0101</td>
<td>21</td>
<td>15</td>
<td>NAK</td>
<td>确认失败回应</td>
</tr>
<tr>
<td>0001 0110</td>
<td>22</td>
<td>16</td>
<td>SYN</td>
<td>同步用暂停</td>
</tr>
<tr>
<td>0001 0111</td>
<td>23</td>
<td>17</td>
<td>ETB</td>
<td>区块传输结束</td>
</tr>
<tr>
<td>0001 1000</td>
<td>24</td>
<td>18</td>
<td>CAN</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>25</td>
<td>19</td>
<td>EM</td>
<td>连接介质中断</td>
</tr>
<tr>
<td>0001 1010</td>
<td>26</td>
<td>1A</td>
<td>SUB</td>
<td>替换</td>
</tr>
<tr>
<td>0001 1011</td>
<td>27</td>
<td>1B</td>
<td>ESC</td>
<td>跳出</td>
</tr>
<tr>
<td>0001 1100</td>
<td>28</td>
<td>1C</td>
<td>FS</td>
<td>文件分割符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>29</td>
<td>1D</td>
<td>GS</td>
<td>组群分隔符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>30</td>
<td>1E</td>
<td>RS</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>31</td>
<td>1F</td>
<td>US</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0111 1111</td>
<td>127</td>
<td>7F</td>
<td>DEL</td>
<td>删除</td>
</tr>
</tbody>
</table>
<ul>
<li>ASCII可显示字符</li>
</ul>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody>
<tr>
<td>0010 0000</td>
<td>32</td>
<td>20</td>
<td>（空格）(␠)</td>
</tr>
<tr>
<td>0010 0001</td>
<td>33</td>
<td>21</td>
<td>!</td>
</tr>
<tr>
<td>0010 0010</td>
<td>34</td>
<td>22</td>
<td>&quot;</td>
</tr>
<tr>
<td>0010 0011</td>
<td>35</td>
<td>23</td>
<td>#</td>
</tr>
<tr>
<td>0010 0100</td>
<td>36</td>
<td>24</td>
<td>$</td>
</tr>
<tr>
<td>0010 0101</td>
<td>37</td>
<td>25</td>
<td>%</td>
</tr>
<tr>
<td>0010 0110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
</tr>
<tr>
<td>0010 0111</td>
<td>39</td>
<td>27</td>
<td>'</td>
</tr>
<tr>
<td>0010 1000</td>
<td>40</td>
<td>28</td>
<td>(</td>
</tr>
<tr>
<td>0010 1001</td>
<td>41</td>
<td>29</td>
<td>)</td>
</tr>
<tr>
<td>0010 1010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
</tr>
<tr>
<td>0010 1011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
</tr>
<tr>
<td>0010 1100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
</tr>
<tr>
<td>0010 1101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
</tr>
<tr>
<td>0010 1110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
</tr>
<tr>
<td>0010 1111</td>
<td>47</td>
<td>2F</td>
<td>/</td>
</tr>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
<tr>
<td>0011 1010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
</tr>
<tr>
<td>0011 1011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
</tr>
<tr>
<td>0011 1100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
</tr>
<tr>
<td>0011 1101</td>
<td>61</td>
<td>3D</td>
<td>=</td>
</tr>
<tr>
<td>0011 1110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
</tr>
<tr>
<td>0011 1111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
</tr>
<tr>
<td>0100 0000</td>
<td>64</td>
<td>40</td>
<td>@</td>
</tr>
<tr>
<td>0100 0001</td>
<td>65</td>
<td>41</td>
<td>A</td>
</tr>
<tr>
<td>0100 0010</td>
<td>66</td>
<td>42</td>
<td>B</td>
</tr>
<tr>
<td>0100 0011</td>
<td>67</td>
<td>43</td>
<td>C</td>
</tr>
<tr>
<td>0100 0100</td>
<td>68</td>
<td>44</td>
<td>D</td>
</tr>
<tr>
<td>0100 0101</td>
<td>69</td>
<td>45</td>
<td>E</td>
</tr>
<tr>
<td>0100 0110</td>
<td>70</td>
<td>46</td>
<td>F</td>
</tr>
<tr>
<td>0100 0111</td>
<td>71</td>
<td>47</td>
<td>G</td>
</tr>
<tr>
<td>0100 1000</td>
<td>72</td>
<td>48</td>
<td>H</td>
</tr>
<tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
</tr>
<tr>
<td>0100 1011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
</tr>
<tr>
<td>0100 1100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
</tr>
<tr>
<td>0100 1101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0101 0000</td>
<td>80</td>
<td>50</td>
<td>P</td>
</tr>
<tr>
<td>0101 0001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
</tr>
<tr>
<td>0101 0010</td>
<td>82</td>
<td>52</td>
<td>R</td>
</tr>
<tr>
<td>0101 0011</td>
<td>83</td>
<td>53</td>
<td>S</td>
</tr>
<tr>
<td>0101 0100</td>
<td>84</td>
<td>54</td>
<td>T</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
<tr>
<td>0101 1000</td>
<td>88</td>
<td>58</td>
<td>X</td>
</tr>
<tr>
<td>0101 1001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
</tr>
<tr>
<td>0101 1010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
</tr>
<tr>
<td>0101 1011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
</tr>
<tr>
<td>0101 1100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
</tr>
<tr>
<td>0101 1101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
</tr>
<tr>
<td>0101 1110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
</tr>
<tr>
<td>0101 1111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
</tr>
<tr>
<td>0110 0000</td>
<td>96</td>
<td>60</td>
<td>`</td>
</tr>
<tr>
<td>0110 0001</td>
<td>97</td>
<td>61</td>
<td>a</td>
</tr>
<tr>
<td>0110 0010</td>
<td>98</td>
<td>62</td>
<td>b</td>
</tr>
<tr>
<td>0110 0011</td>
<td>99</td>
<td>63</td>
<td>c</td>
</tr>
<tr>
<td>0110 0100</td>
<td>100</td>
<td>64</td>
<td>d</td>
</tr>
<tr>
<td>0110 0101</td>
<td>101</td>
<td>65</td>
<td>e</td>
</tr>
<tr>
<td>0110 0110</td>
<td>102</td>
<td>66</td>
<td>f</td>
</tr>
<tr>
<td>0110 0111</td>
<td>103</td>
<td>67</td>
<td>g</td>
</tr>
<tr>
<td>0110 1000</td>
<td>104</td>
<td>68</td>
<td>h</td>
</tr>
<tr>
<td>0110 1001</td>
<td>105</td>
<td>69</td>
<td>i</td>
</tr>
<tr>
<td>0110 1010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
</tr>
<tr>
<td>0110 1011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
</tr>
<tr>
<td>0110 1100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
</tr>
<tr>
<td>0110 1101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
</tr>
<tr>
<td>0110 1110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
</tr>
<tr>
<td>0110 1111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
</tr>
<tr>
<td>0111 0000</td>
<td>112</td>
<td>70</td>
<td>p</td>
</tr>
<tr>
<td>0111 0001</td>
<td>113</td>
<td>71</td>
<td>q</td>
</tr>
<tr>
<td>0111 0010</td>
<td>114</td>
<td>72</td>
<td>r</td>
</tr>
<tr>
<td>0111 0011</td>
<td>115</td>
<td>73</td>
<td>s</td>
</tr>
<tr>
<td>0111 0100</td>
<td>116</td>
<td>74</td>
<td>t</td>
</tr>
<tr>
<td>0111 0101</td>
<td>117</td>
<td>75</td>
<td>u</td>
</tr>
<tr>
<td>0111 0110</td>
<td>118</td>
<td>76</td>
<td>v</td>
</tr>
<tr>
<td>0111 0111</td>
<td>119</td>
<td>77</td>
<td>w</td>
</tr>
<tr>
<td>0111 1000</td>
<td>120</td>
<td>78</td>
<td>x</td>
</tr>
<tr>
<td>0111 1001</td>
<td>121</td>
<td>79</td>
<td>y</td>
</tr>
<tr>
<td>0111 1010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
</tr>
<tr>
<td>0111 1011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
</tr>
<tr>
<td>0111 1100</td>
<td>124</td>
<td>7C</td>
<td>\</td>
</tr>
<tr>
<td>0111 1101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
</tr>
<tr>
<td>0111 1110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
</tr>
</tbody>
</table>
<h3 id="112-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8">1.1.2. 数据存储</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="113-%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97">1.1.3. 数据运算</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="114-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90">1.1.4. 计算机组成</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1141-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90">1.1.4.1. 计算机组成</h4>
<ul>
<li>中央处理器CPU
<ul>
<li>作用
<ul>
<li>用于数据的运算</li>
</ul>
</li>
<li>三大部分
<ul>
<li>算术逻辑单元
<ul>
<li>对数据进行逻辑,移位,和算术运算</li>
</ul>
</li>
<li>寄存器
<ul>
<li>用来存放临时数据的高速独立的存储单元</li>
<li>数据寄存器
<ul>
<li>用来存储输入数据和运算结果,可以提高运算速度</li>
</ul>
</li>
<li>指令寄存器
<ul>
<li>CPU的主要职责就是从内存中逐条取出指令,并将指令存储在指令寄存器中,解释并执行</li>
</ul>
</li>
<li>程序计数器
<ul>
<li>保存当前正在执行的指令,当前指令执行完后,计数器将自动加1,指向下一条指令的内存地址</li>
</ul>
</li>
</ul>
</li>
<li>控制单元
<ul>
<li>控制各个子系统的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>主存储器
<ul>
<li>存储单元的集合,每一个存储单元都有唯一的标识,也就是地址</li>
<li>存储器类型
<ul>
<li>随机存取存储器RAM
<ul>
<li>数据断电会丢失</li>
<li>SRAM
<ul>
<li>技术是使用传统的触发器门电路</li>
<li>速度较快,价格较贵</li>
</ul>
</li>
<li>DRAM
<ul>
<li>使用电容器</li>
<li>速度较慢,价格较便宜</li>
</ul>
</li>
</ul>
</li>
<li>只读存储器ROM
<ul>
<li>只能读不能写,断电数据不丢失,一般用来存储程序或者数据</li>
</ul>
</li>
<li>可编程只读存储器PROM</li>
<li>可擦除可编程存储器EPROM
<ul>
<li>用户可以对它进行编程,需要一种可以发出紫外光的特殊仪器进行擦写</li>
</ul>
</li>
<li>电可擦除可编程存储器EEPROM
<ul>
<li>对它的编程和擦除都是使用电子脉冲即可,无需从计算机上拆除下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输入/输出子系统</li>
</ul>
<h4 id="1142-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%BF%9E">1.1.4.2. 子系统互连</h4>
<p><strong>CPU和存储器的连接</strong></p>
<p>CPU和存储器一般使用三组线进行连接:数据总线,控制总线,地址总线</p>
<ul>
<li>数据总线
<ul>
<li>每一根线上传送一位数据,线的数量取决于计算机字的大小,比如32位的计算机需要32根线的数据总线,以便一次传输完一个字的数据</li>
</ul>
</li>
<li>地址总线
<ul>
<li>地址总线的线数取决于存储空间的大小,存储器容量为2^N,就需要N根线</li>
</ul>
</li>
<li>控制总线
<ul>
<li>控制读写时钟等操作</li>
</ul>
</li>
</ul>
<p><strong>输入输出设备寻址</strong></p>
<ul>
<li>I/O独立寻址
<ul>
<li>用来读写内存的指令和用来读写输入输出设备的指令不同,有专门的指令完成对输入输出设备的读写控制等操作</li>
</ul>
</li>
<li>I/O存储器的映射寻址
<ul>
<li>用来读写内存的指令和用来读写输入输出设备的指令相同,CPU将输入/输出控制器中的每一个寄存器都看作内存中的某个存储字</li>
</ul>
</li>
</ul>
<h4 id="1143-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">1.1.4.3. 程序执行</h4>
<ul>
<li>机器周期
<ul>
<li>取指令
<ul>
<li>控制单元命令系统将下一条将要执行的指令复制到CPU的指令寄存器.被复制的指令地址保存在程序计数器中.复制完成后,程序计数器自动加1指向内存中的下一条指令</li>
</ul>
</li>
<li>译码
<ul>
<li>当指令置于指令寄存器后,该指令将由控制单元负责译码,指令译码的结果就是系统可以识别执行的二进制代码</li>
</ul>
</li>
<li>执行
<ul>
<li>译码完成后,控制单元发送任务命令到CPU的某个部件执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1144-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.1.4.4. 计算机体系结构</h4>
<ul>
<li>复杂指令集计算机CISC(complex instruction set computer)
<ul>
<li>指令多且复杂</li>
<li>使得CPU和控制单元的电路非常复杂</li>
</ul>
</li>
<li>精简指令集计算机RISC(reduce instruction set computer)
<ul>
<li>使用少量的指令完成最少的操作,复杂指令使用简单指令集模拟</li>
</ul>
</li>
</ul>
<h3 id="115-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">1.1.5. 程序设计语言</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1151-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80">1.1.5.1. 计算机语言</h4>
<ul>
<li>
<p>计算机语言</p>
<ul>
<li>根据事先定义的规则(语法)而写出的预定语句的语句集合</li>
<li>机器语言
<ul>
<li>机器语言是计算机硬件唯一能理解的语言</li>
<li>由&quot;0&quot;&quot;1&quot;组成,表示两种电子开关的状态</li>
</ul>
</li>
<li>汇编语言
<ul>
<li>带符号和助记符的指令和地址代替机器语言的二进制码</li>
<li>难于理解,编程复杂</li>
</ul>
</li>
<li>高级语言
<ul>
<li>比如C/C++,Java等</li>
<li>高级语言转化为机器语言的过程为解释或者编译</li>
</ul>
</li>
</ul>
</li>
<li>
<p>高级语言翻译为机器语言</p>
<ul>
<li>编译
<ul>
<li>把整个源程序翻译成目标程序</li>
</ul>
</li>
<li>解释
<ul>
<li>把源程序中的每一行翻译成目标程序中相应的行,并执行它的过程</li>
<li>早期的解释式语言BASIC|APL
<ul>
<li>源程序的每一行被翻译成其计算机上的机器语言,该行机器语言被立即执行,如果在翻译和执行的过程中有任何错误,过程就会被终止.</li>
</ul>
</li>
<li>Java所使用的
<ul>
<li>源程序到目标程序两个阶段:编译和解释</li>
<li>源程序先经过编译成虚拟机可识别的字节码,然后能被任何运行JVM模拟器的计算机编译或者解释</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>编译和解释不同在于:编译在执行前翻译整个源代码,而解释一次只翻译和执行源代码中的一行.两种方法都遵循如下的翻译过程</p>
<pre class="hljs"><code><div>源文件---符号---&gt;词法分析器---助记符---&gt;语法分析器---指令---&gt;语义分析器---可编码的指令---&gt;代码生成器---代码---&gt;目标文件
</div></code></pre>
<ul>
<li>词法分析器
<ul>
<li>语法分析器一个符号一个符地读源代码,创建源代码中的助助记符,比如'f''o''r'被读入,就成了高级语言中的助记符&quot;for&quot;</li>
</ul>
</li>
<li>语法分析器
<ul>
<li>分析助记符,找出指令</li>
</ul>
</li>
<li>语义分析器
<ul>
<li>检查分析器创建的句子,确保不会有二义性</li>
</ul>
</li>
<li>代码生成器
<ul>
<li>在无二义性指令被创建完成后,每条指令将转化成计算机的机器语言</li>
</ul>
</li>
</ul>
<h4 id="1152-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">1.1.5.2. 编程模式</h4>
<ul>
<li>面向过程</li>
<li>面向对象</li>
<li>函数式</li>
<li>声明式</li>
</ul>
<h3 id="116-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">1.1.6. 软件工程</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1161-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">1.1.6.1. 开发过程模型</h4>
<ul>
<li>瀑布模型
<ul>
<li>开发过程只有一个阶段,前一个阶段不结束,后一个阶段不能开始(分析-设计-实现-测试)</li>
<li>优点:下一个阶段开始前每个阶段已经完成</li>
<li>缺点:难以定位问题,如果过程的一部分有问题,那么必须检视整个过程</li>
</ul>
</li>
<li>增量模型
<ul>
<li>先完成整个系统的简化版本,后续增加实现各个细节,直到所有得到要求全部实现</li>
</ul>
</li>
</ul>
<h4 id="1162-%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5">1.1.6.2. 分析阶段</h4>
<ul>
<li>面向过程分析
<ul>
<li>常用建模工具
<ul>
<li>数据视图
<ul>
<li>显示系统中数据的流动</li>
</ul>
</li>
<li>实体关系图</li>
<li>状态图</li>
</ul>
</li>
</ul>
</li>
<li>面向对象分析
<ul>
<li>用例图</li>
<li>类图</li>
<li>状态图</li>
</ul>
</li>
</ul>
<h4 id="1163-%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5">1.1.6.3. 设计阶段</h4>
<ul>
<li>
<p>面向过程设计</p>
<ul>
<li>结构图,描述模块间的关系</li>
<li>模块化,降低耦合和提高内聚
<ul>
<li>耦合:两个模块间互相绑定程度的度量,耦合越大,独立性越差.修改一个模块时可能会影响另一个模块</li>
<li>内聚:程序中处理过程相关紧密程度的度量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面向对象设计</p>
<ul>
<li>详细描述类的实现细节</li>
</ul>
</li>
<li>
<p>语言的选择</p>
</li>
</ul>
<h4 id="1164-%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5">1.1.6.4. 实现阶段</h4>
<ul>
<li>软件质量
<ul>
<li>可操作性
<ul>
<li>准确性
<ul>
<li>准确性可以通过故障平均时间,每千行代码错误数等来度量</li>
</ul>
</li>
<li>高效性
<ul>
<li>也就是性能</li>
</ul>
</li>
<li>可靠性
<ul>
<li>故障率,故障平均时间</li>
</ul>
</li>
<li>安全</li>
<li>及时性</li>
<li>适用性</li>
</ul>
</li>
<li>可维护性</li>
<li>可迁移性</li>
</ul>
</li>
</ul>
<h4 id="1165-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5">1.1.6.5. 测试阶段</h4>
<ul>
<li>
<p>白盒测试</p>
<ul>
<li>基于知道软件内部结构进行测试,测试的目标是检查软件所有的部分是否全部设计出来</li>
<li>完成白盒测试需要保证
<ul>
<li>每个模块中的所有独立的路径至少被测试过一次</li>
<li>所有的判断结构每个分支都要进行测试</li>
<li>每个循环被测试</li>
<li>所有的数据结构都被测试</li>
</ul>
</li>
<li>测试方法
<ul>
<li>基本路径测试
<ul>
<li>软件中的每条语句必须被执行一次</li>
</ul>
</li>
<li>控制结构测试</li>
</ul>
</li>
</ul>
</li>
<li>
<p>黑盒测试</p>
<ul>
<li>不知道程序内部如何工作的情况下进行测试</li>
<li>穷尽测试
<ul>
<li>用输入域中的所有可能的值区测试软件,效率偏低</li>
</ul>
</li>
<li>随机测试</li>
<li>边界值测试</li>
</ul>
</li>
</ul>
<h4 id="1166-%E6%96%87%E6%A1%A3">1.1.6.6. 文档</h4>
<ul>
<li>用户文档
<ul>
<li>软件使用手册</li>
</ul>
</li>
<li>系统文档</li>
<li>技术文档</li>
</ul>
<h3 id="117-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.1.7. 数据结构</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="118-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.1.8. 抽象数据类型</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="119-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">1.1.9. 文件结构</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="1110-%E6%95%B0%E6%8D%AE%E5%BA%93">1.1.10. 数据库</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="1111-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9">1.1.11. 数据压缩</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="1112-%E5%AE%89%E5%85%A8">1.1.12. 安全</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="12-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">1.2. 编译原理</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1.3. 操作系统</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<p>计算机系统由软件和硬件组成,硬件是计算机系统的基础,操作系统是位于硬件上的第一层软件,用于控制管理各种硬件资源.为其他软件和用户提供了工作环境.操作系统为人们有效的使用计算机提供了用户接口.操作系统还要对系统资源进行统一管理,使各并发进程能改按照一定的原则合理共享计算机资源,并在保证各个并发进程顺利运行的基础上提高资源的利用率,操作系统是整个计算机的控制管理中心.</p>
<h3 id="131-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.1. 操作系统基本概念</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1311-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD">1.3.1.1. 操作系统的功能</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>1.提供人机接口</strong></p>
<ul>
<li>作业控制级接口</li>
<li>程序级接口</li>
</ul>
<p><strong>管理计算机资源</strong></p>
<ul>
<li>进程管理
<ul>
<li>进程调度</li>
<li>进程通信</li>
<li>进程控制</li>
<li>进程同步</li>
</ul>
</li>
<li>存储管理
<ul>
<li>内存分配</li>
<li>地址转换</li>
<li>内存保护</li>
<li>内存扩充</li>
</ul>
</li>
<li>设备管理
<ul>
<li>设备分配</li>
<li>缓冲管理</li>
<li>设备驱动</li>
<li>设备独立性</li>
</ul>
</li>
<li>文件管理
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件操作</li>
<li>文件的存取和权限管理</li>
</ul>
</li>
</ul>
<h4 id="1312-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B">1.3.1.2. 操作系统发展过程</h4>
<ul>
<li>无操作系统的计算机</li>
<li>单道批处理系统</li>
<li>分时系统</li>
<li>实时系统</li>
</ul>
<h4 id="1313-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7">1.3.1.3. 操作系统的特性</h4>
<ul>
<li>程序并发运行
<ul>
<li>宏观上多道程序同时运行,微观上交替运行,如果有多个CPU,可以实现并行</li>
<li>提高资源利用率和系统吞吐量</li>
<li>由操作系统实现并发的管理</li>
</ul>
</li>
<li>资源共享
<ul>
<li>共享的理由
<ul>
<li>各用户或任务独占系统资源将导致资源浪费</li>
<li>多个任务共享一个程序的同一个副本</li>
</ul>
</li>
</ul>
</li>
<li>异步</li>
<li>虚拟
<ul>
<li>虚拟指的是通过某种技术把一个物理实体映射为多个逻辑实体,用户程序使用的是逻辑实体</li>
<li>比如虚拟内存,docker的应用</li>
</ul>
</li>
</ul>
<h4 id="1314-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.3.1.4. 操作系统的体系结构</h4>
<h5 id="13141-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">1.3.1.4.1. 层次结构</h5>
<h5 id="13142-%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84">1.3.1.4.2. 微内核结构</h5>
<h5 id="13143-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">1.3.1.4.3. 基本特性</h5>
<h3 id="132-linux%E5%9F%BA%E7%A1%80">1.3.2. Linux基础</h3>
<h4 id="1321-linux%E5%90%84%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%AF%8F%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">1.3.2.1. Linux各目录及每个目录的详细介绍</h4>
<pre class="hljs"><code><div>/bin 二进制可执行命令

/dev 设备特殊文件
/etc 系统管理和配置文件
/etc/rc.d 启动的配置文件和脚本
/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序
/tmp 公共的临时文件存储点
/root 系统管理员的主目录
/mnt 系统提供这个目录是让用户临时挂载其他的文件系统
/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
/var 某些大文件的溢出区，比方说各种服务的日志文件
/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：

/usr/x11R6 存放x window的目录
/usr/bin 众多的应用程序
/usr/sbin 超级用户的一些管理程序
/usr/doc linux文档
/usr/include linux下开发和编译应用程序所需要的头文件
/usr/lib 常用的动态链接库和软件包的配置文件
/usr/man 帮助文档
/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里
/usr/local/bin 本地增加的命令
/usr/local/lib 本地增加的库根文件系统
</div></code></pre>
<h4 id="1322-linux-%E5%92%8C-unix-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8C%BA%E5%88%AB">1.3.2.2. Linux 和 UNIX 的关系/区别</h4>
<p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。
说模仿可能会被人喷，你也可以说微创新或者改进。
相比于 UNIX，Linux 最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的 UNIX 大部分都是收费的，小公司和个人都难以承受。</p>
<p>正是由于 Linux 和 UNIX 有着千丝万缕的联系，所以人们把 Linux 叫做“类UNIX系统”</p>
<p>UNIX/Linux 系统可以粗糙地抽象为 3 个层次.底层是 UNIX/Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层．</p>
<ul>
<li>
<p>内核层</p>
<ul>
<li>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</li>
</ul>
</li>
<li>
<p>Shell层</p>
<ul>
<li>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</li>
</ul>
</li>
<li>
<p>应用层</p>
<ul>
<li>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP/IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</li>
</ul>
</li>
<li>
<p>X Window 与微软的 Windows 图形环境有很大的区别：</p>
<ul>
<li>UNIX/Linux 系统与 X Window 没有必然捆绑的关系，也就是说，UNIX/Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。</li>
<li>UNIX/Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。</li>
</ul>
</li>
</ul>
<p>作为服务器部署，绝大多数 Linux 并不安装或并不启用图形环境</p>
<h4 id="1323-%EF%BD%8Cinux%E7%89%88%E6%9C%AC">1.3.2.3. Ｌinux版本</h4>
<ul>
<li>Linux内核版本与linux发行版本的区别：LINUX内核版本是指系统内核的版本号，LINUX的内核具有两种不同的版本号，实验版本和产品化版本。首先解释一下什么是Linux发行版(英文名称是Linux Distribution)。Linux实际上是一种开放源代码的操作系统内核，通常我们说的Linux指的是基于Linux内核的操作系统。</li>
<li>Linux操作系统包括Linux内核和Linux用户态程序，Linux内核和Linux用户态程序都是开放源代码的，绝大多数软件代码遵循GPL协议，任何人拿到这些代码都可以对这些代码进行修改和分发。</li>
<li>由于Linux上代码的高度自由，很多公司和组织都推出了自己的Linux操作系统，这些Linux操作系统我们就叫做Linux发行版。各种不同的Linux发行版的共同点就是都使用了Linux内核，不同的Linux发行版的内核可能有一些小的修改。</li>
<li>要确定 LINUX版本 的类型，只要查看一下版本号：每一个版本号由三位数字组成，第二位数字说明版本类型。如果第二位数字是偶数则说明这种版本是产品化版本，如果是奇数说明是实验版本。
如2.4.18是产品化版本，2.5.21是实验版本。查看 linux内核版本 命令：uname -r Linux发行版本 是指一些 Linux厂商 将 LINUX系统内核 与应用软件及文档包装在一起，并提供一些安装界面和系统设定与管理工具，这就构成了一个发行套件。</li>
</ul>
<p><strong>查看Linux版本</strong></p>
<pre class="hljs"><code><div>1、# uname －a （Linux查看版本当前操作系统内核信息）
2、# cat /proc/version （Linux查看当前操作系统版本信息）
3、# cat /etc/issue 或 cat /etc/redhat-release （Linux查看版本当前操作系统发行版信息）
4、# cat /proc/cpuinfo （Linux查看cpu相关信息，包括型号、主频、内核信息等）
5、# getconf LONG_BIT （Linux查看版本多少位）
6、# lsb_release -a （CentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用，网上都说Linux都支持，我只验证过CentOS系统）
</div></code></pre>
<h5 id="13231-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E6%97%8F">1.3.2.3.1. 常用的Linux发行版本族：</h5>
<p><strong>redhat家族</strong></p>
<p>主要包括有redhat 企业版，CentOS版本，Fedara</p>
<p>redhat 企业版，这个需要授权费，主要用在高要求的服务器商用系统，比如各种运营商内部非核心系统，在版本上注重了性能和稳定性以及对硬件的支持。 由于企业版操作系统的开发周期较长，注重性能、稳定性和服务端软件支持，因此版本更新相对较缓慢。</p>
<p>CentOS：CentOS全名为“社区企业操作系统”，CentOS社区将Red hat的网站上的所有源代码下载下来，进行重新编译。由于AS/ES/WS是商业产品，因此，必须将所有Red hat的Logo和标识改成自己的CentOS标识。比如将AS4。0原版的SRPM源码编译后，换上Centos社区的logo，这样就成为了CentOS 4.0。Redhat Enterprise Linux AS4 Update1的源码编译后，就成为了CentOS4.1。AS4 Update2的源码编译后，就成为了CentOS4.2等等。CentOS就是这样产生的。此版本主要用在互联网各大中小网站。</p>
<p>Fedara：被红帽公司定位为新技术的实验场地，许多新的技术都会在 FC 中检验，如果稳定的话红帽公司则会考虑加入 Red Hat Enterprise Linux 中;一般在服务器上不推荐采用Fedora Core。其实可以这么认为，Fedora就是Red Hat发行Red Hat企业版Linux的一个实验版本，拿用户做测试，为Red Hat企业版发布做基础。</p>
<p>还有其它版本如下：Scientific Linux/Oracle Linux</p>
<p><strong>Debian</strong></p>
<p>Debian运行起来极其稳定，这使得它非常适合用于服务器。Debian平时维护三套正式的软件库和一套非免费软件库，这给另外几款发行版（比如Ubuntu和Kali等）带来了灵感。Debian这款操作系统派生出了多个Linux发行版。它有37500多个软件包，这方面唯一胜过Debian的其他发行版只有Gentoo。Debian使用apt或aptitude来安装和更新软件。</p>
<p>Debian这款操作系统无疑并不适合新手用户，而是适合系统管理员和高级用户。Debian支持如今的大多数架构（处理器）。</p>
<p>主要基于Debian的版本如下：Debian/Ubuntu/Linux Mint/Knoppix/MEPIS/sidux/CrunchBang Linux/Chromium OS/Google Chrome OS</p>
<p>重点推荐：Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统,是一个以桌面应用为主的Linux操作系统,Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助。2013年1月3日，Ubuntu正式发布面向智能手机的移动操作系统。笔者现在也在使用此版本。</p>
<p><strong>SUSE</strong></p>
<p>是欧洲大陆最流行的LINUX起源于德国，于2003年末被Novell收购。主要版本有：SUSE Linux，针对个人用户，可以免费下载；</p>
<p>另一个是SUSE Linux Enterprise Server (SLES)是基于企业服务器端的。如果需要使用数据库高级服务和电子邮件网络应用可以选SUSE</p>
<p>主要版本：SUSE Linux Enterprise Server (SLES) 最新版本SUSE Linux Enterprise 12/SUSE Linux Enterprise Desktop（SLED）/SUSE Manager （版本号1.7）/SUSE Studio</p>
<p><strong>Gentoo</strong></p>
<p>是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在她之前的所有发行版本的优点。Gentoo最初由Daniel Robbins（FreeBSD的开发者之一）创建，首个稳定版本发布于2002年。由于开发者对FreeBSD的熟识，所以Gentoo拥有媲美FreeBSD的广受美誉的ports系统——Portage包管理系统。不同于APT和YUM等二进制文件分发的包管理系统，Portage是基于源代码分发的，必须编译后才能运行，对于大型软件而言比较慢，不过正因为所有软件都是在本地机器编译的，在经过各种定制的编译参数优化后，能将机器的硬件性能发挥到极致。Gentoo是所有Linux发行版本里安装最复杂的，但是又是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本.</p>
<p>相关版本：Gentoo Linux/Sabayon Linux/Calculate Linux/Funtoo Linux/</p>
<h3 id="133-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1.3.3. 进程管理</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1331-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.3.1. 进程的基本概念</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>进程是操作系统中一个非常重要的概念,程序的运行是通过进程来完成的.在层次结构的操作系统中.进程不仅使系统分配资源的基本单位.而且是CPU调度的基本单位.</p>
<p>Unix系统中,进程的创建通过函数fork进行创建,这个系统调用会创建一个与调用进程相同的副本.在调用fork之后,这两个进程(父进程和子进程)拥有相同的内存映像,相同的环境字符串和相同的打开文件.但是父子进程却拥有各自独立的地址空间.如果其中某一个进程在其地址空间修改了一个字,则这一改变对另一个进程是不可见的.子进程的初始地址是父进程地址空间的一个副本,但是这是两个不同的地址空间,可写的地址空间是不共享的.但是,一个新建的进程可能共享像打开文件之类的资源.</p>
<ul>
<li>
<p>进程和程序的区别</p>
<ul>
<li>程序是静态的概念,本身可以作为一种软件资源长期保存,而进程是程序的一次执行过程,是动态的概念</li>
<li>进程是一个能独立运行的单位,能与其他进程并发执行.进程作为资源申请和调度单位存在.通常程序不能作为一个独立运行的单位而并发执行</li>
<li>程序和进程不存在一一对应的关系,一个程序可由多个进程共用,一个进程在其活动中又可顺序执行若干个程序</li>
<li>各个进程在并发执行过程中会产生相互制约的关系,造成各自前进速度的不可预测性,而程序本身是静态的,不存在这种异步特征.</li>
</ul>
</li>
<li>
<p>进程的特征</p>
<ul>
<li>动态性
<ul>
<li>进程是程序的执行过程</li>
</ul>
</li>
<li>并发性
<ul>
<li>同一个计算机上的进程会存在并发执行的情况</li>
</ul>
</li>
<li>独立性
<ul>
<li>进程是一个能独立运行的基本单位,是系统中独立获得资源和独立调度的基本单位</li>
</ul>
</li>
<li>异步性</li>
</ul>
</li>
<li>
<p>进程的终止</p>
<ul>
<li>正常退出</li>
<li>出错退出</li>
<li>严重错误</li>
<li>被其他进程杀死</li>
</ul>
</li>
<li>
<p>进程的层次结构</p>
<ul>
<li>进程创建子进程之后,子进程也可以创建子进程,这些进程共同组成一个进程组</li>
<li>如果一个信号(比如kill)发送给一个进程组,那么每个进程都可以捕获这个信号,忽略该信号或者采取默认的动作</li>
</ul>
</li>
<li>
<p>进程的状态</p>
<ul>
<li>运行态
<ul>
<li>获得CPU的运行权,正在运行</li>
<li>单CPU计算机同一时刻只能有一个进程处于执行状态</li>
</ul>
</li>
<li>就绪态
<ul>
<li>进程的外部条件满足,但是因为其他进程已经占用CPU,所以暂时不能运行</li>
</ul>
</li>
<li>阻塞态
<ul>
<li>进程正在等待某种事件发生而暂时不能运行起来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1332-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">1.3.3.2. 进程控制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>进程控制就是系统使用一个引起具有特定功能的程序段来创建,撤销进程以及完成进程各状态间的转换,从而达到多进程高效率并发执行和协调,实现资源共享的目的.通常,把系统态下执行的某些具有特定功能的程序段成为原语(原子操作).原语可以分为两类,一类是机器指令级的,执行期间不允许中断.一类是功能级的,其特点是作为原语的程序段不允许并发执行.这两类原语都是在系统态下执行,都是为了完成某个系统管理锁需要的功能而被高层软件所调用.</p>
<h5 id="13321-%E7%9B%B8%E5%85%B3%E7%9A%84linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">1.3.3.2.1. 相关的Linux系统调用</h5>
<p><strong>fork系统调用</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">//创建一个进程,返回值为pid</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fork</span><span class="hljs-params">()</span></span>;
</div></code></pre>
<ul>
<li>pid=0:创建子进程成功,表示从子进程返回</li>
<li>pid&gt;0:创建子进程成功,表示从父进程返回,pid的值为新创建的子进程标识号</li>
<li>pid=-1:子进程创建失败</li>
</ul>
<pre class="hljs"><code><div>     
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdio.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"unistd.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello!my pid is %d\r\n"</span>,getpid());
    
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> pid = fork();
    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"create process error!\r\n"</span>);

    }   
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>){
        <span class="hljs-comment">//处理子进程业务</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"I am child proccess ,my pid is : %d\r\n"</span>,getpid());
        count++;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child process:count = %d\r\n"</span>,count);
    }
   
    <span class="hljs-keyword">else</span>{
        <span class="hljs-comment">//处理父进程业务</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"I am main  proccess ,my pid is : %d\r\n"</span>,getpid());
        count++;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"main process:count = %d\r\n"</span>,count);
    }

   

}

<span class="hljs-comment">//执行输出</span>
lgj@lgj-Lenovo-G470:~/aProject/c$ ./hello
hello!my pid is <span class="hljs-number">7512</span>
I am main  proccess ,my pid is : <span class="hljs-number">7512</span>
main <span class="hljs-built_in">process</span>:count = <span class="hljs-number">1</span>
I am child proccess ,my pid is : <span class="hljs-number">7513</span>
child <span class="hljs-built_in">process</span>:count = <span class="hljs-number">1</span>

</div></code></pre>
<p><strong>exec()系统调用</strong></p>
<p>exec()用于执行新的程序</p>
<p><strong>exit()系统调用</strong>
实现进程的自我终止</p>
<p><strong>wait()系统调用</strong></p>
<p>该系统调用将调用进程挂起,直至其子进程因暂停或终止而发来软中断信号为止.</p>
<h4 id="1333-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">1.3.3.3. 进程同步</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="13331-%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E6%A6%82%E5%BF%B5">1.3.3.3.1. 临界资源的概念</h5>
<p>在操作系统引入进程以及进程并发性概念之后,增加了系统的效率,同时由于资源有限导致了进程之间的资源竞争与共享.</p>
<ul>
<li>
<p>临界资源</p>
<ul>
<li>两个或者两个以上的进程不能同时使用的资源称为临界资源.</li>
<li>临界资源可以是一些独占设备,比如打印机,磁带机等,也可能是一些共享变量,表格,链表等</li>
</ul>
</li>
<li>
<p>临界区</p>
<ul>
<li>不论硬件临界资源还是软件临界资源,多个进程必须互斥对其进行访问.每个进程访问临界资源的那段代码称为临界区(Critical Section).</li>
<li>为了保证临界区的互斥访问,每次进程在进入临界区以前,应先对欲访问的临界资源进行检测,查看是否有其他进程正在访问</li>
<li>因此需要在临界区之前增加检测代码(进入区),在退出临界区增加检查退出临界区的代码(退出区).</li>
</ul>
</li>
</ul>
<h5 id="13332-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5">1.3.3.3.2. 进程的互斥与同步</h5>
<ul>
<li>
<p>进程互斥</p>
<ul>
<li>多个进程不能同时使用同一个临界资源,也就是互斥访问</li>
</ul>
</li>
<li>
<p>进程同步</p>
<ul>
<li>指有协作关系的进程之间不断地调整它们之间的相对速度或者执行过程,以保证临界资源的合理利用和进程的顺利执行.一般使用加锁操作,信号量等来解决</li>
</ul>
</li>
<li>
<p>同步机制应遵循的规划</p>
<ul>
<li>空闲让进
<ul>
<li>并发进程中的某个进程不在临界区时,不阻止其他进程进入临界区</li>
</ul>
</li>
<li>忙则等待
<ul>
<li>临界区有其他进程在访问时,想要访问的进程必须等待</li>
</ul>
</li>
<li>有限等待
<ul>
<li>应保证在一定的时间内访问到临界资源,避免死等</li>
</ul>
</li>
<li>让权等待
<ul>
<li>当进程不能进入自己的临界区,应立即释放处理机,以避免进程陷入&quot;忙等&quot;状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>锁机制</p>
<ul>
<li>在临界区之前加锁,比如使用一个标志位.在临界区之后释放锁</li>
<li>存在的问题:不断检测,直到其他进程释放锁.容易造成浪费时间.</li>
</ul>
</li>
<li>
<p>信号量机制</p>
<ul>
<li>wait</li>
<li>signal</li>
</ul>
</li>
</ul>
<h4 id="1334-%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98">1.3.3.4. 经典的进程同步问题</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="134-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">1.3.4. 进程通信</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>
<p>Unix系统提供的进程间通信的基本机制</p>
<ul>
<li>管道和FIFO(命名管道)
<ul>
<li>最适合在进程之间实现生产者／消费者的交互．有些进程向管道中写入数据，而另外一些进程则从管道中读出数据</li>
</ul>
</li>
<li>信号量
<ul>
<li>内核信号量的用户态版本</li>
</ul>
</li>
<li>消息
<ul>
<li>允许进程在预定义的消息队列中读和写消息来交换信息．linux提供了两种消息版本：Ｓystem V IPC和posix消息</li>
</ul>
</li>
<li>共享内存区
<ul>
<li>允许进程通过共享内存来交换信息</li>
</ul>
</li>
<li>套接字
<ul>
<li>通过网络交换信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>低级通信</p>
<ul>
<li>进程间控制消息的交换,比如进程的互斥和同步以及信号量</li>
</ul>
</li>
<li>
<p>高级通信</p>
<ul>
<li>进程间大量消息的交换</li>
<li>实现方案
<ul>
<li>共享存储系统
<ul>
<li>共享存储器系统的类型
<ul>
<li>基于共享数据结构的通信方式
<ul>
<li>各个进程共用某些数据结构,以实现各进程间的信息交换.效率低,只适用于传递相对少量的数据</li>
</ul>
</li>
<li>基于共享存储区的通信方式
<ul>
<li>各个进程通过访问共享存储区的数据读或者写来实现通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>消息传递系统</li>
<li>管道通信系统
<ul>
<li>管道是指用于连接一个读进程和一个写进程,以实现它们之间通信的一个共享文件(pipe文件),由于发送进程和接收进程是利用管道进行通信,又称为管道通信</li>
<li>向管道(共享文件)提供输入的发送进程(写进程),以字符流形式将大量的数据送入管道</li>
<li>而接收管道输出的接收进程(读进程),则从管道中读数据</li>
<li>管道机制必须提供能力
<ul>
<li>互斥
<ul>
<li>每次只能有一个进程对管道进行读写</li>
</ul>
</li>
<li>同步
<ul>
<li>写完睡眠等待,管道为空时读也睡眠等待</li>
</ul>
</li>
<li>确定对方是否存在
<ul>
<li>只有对方存在,才能进行通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信号通信机制</p>
<ul>
<li>信号基本概念
<ul>
<li>每个信号都对应一个正整数常量,定义在头文件<code>&lt;signal.h&gt;</code>.</li>
<li>每个进程运行时,都要通过信号机制来检查是否有信号到达,若有,便中断正在执行的程序,转向与该信号相对应的处理程序,以完成对该事件的处理,处理结束后再返回到原来的断点继续执行</li>
</ul>
</li>
<li>信号和中断的相似点
<ul>
<li>采用的异步通信方式是相同的</li>
<li>当有中断请求或检测出有信号时,都暂停正在执行的程序而转去执行相应的处理程序</li>
<li>都在处理完毕后返回到原来的断点</li>
<li>对信号或中断都可以进行屏蔽</li>
</ul>
</li>
<li>信号和中断的区别
<ul>
<li>中断有优先级,信号没有</li>
<li>信号的处理程序是在用户态下运行的,而中断处理程序是在核心态下运行的</li>
<li>中断响应是即时的,而信号响应通常都有较大的延迟</li>
</ul>
</li>
<li>信号处理方式
<ul>
<li>第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。</li>
<li>第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</li>
<li>第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。</li>
</ul>
</li>
<li>信号机制功能
<ul>
<li>发送信号,使用kill()实现
<ul>
<li>int kill(pid,sig)
<ul>
<li>pid &gt; 0; 核心将信号发送给进程pid</li>
<li>pid = 0; 核心将信号发送给与发送进程同组的进程</li>
<li>pid = -1 ; 核心将信号发送给所有用户标识符真正等于发送进程的有效用户标识号的进程</li>
</ul>
</li>
<li>信号的发送是指由发送进程把信号发送到指定进程的信号域上的某一位</li>
<li>如果目标进程正在一个可被中断的优先级上睡眠,核心会将它唤醒,发送进程就此结束</li>
<li>一个进程可以同时接收多个信号</li>
</ul>
</li>
<li>预置对信号的处理方式,使用signal()实现
<ul>
<li>signal(sig,function)
<ul>
<li>function 处理函数的地址
<ul>
<li>function=1,对信号忽略</li>
<li>function=0,默认值，收到信号后终止自己</li>
<li>其他值，信号处理函数的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>收受信号的进程按事先的规定完成对相应事件的处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>信号值</th>
<th>默认处理动作</th>
<th>发出信号的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>A</td>
<td>终端挂起或者控制进程终止</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>A</td>
<td>键盘中断（如break键被按下）</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>C</td>
<td>键盘的退出键被按下</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>C</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>C</td>
<td>由abort(3)发出的退出指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>C</td>
<td>浮点异常</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>AEF</td>
<td>Kill信号</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>C</td>
<td>无效的内存引用</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>A</td>
<td>管道破裂: 写一个没有读端口的管道</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>A</td>
<td>由alarm(2)发出的信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>A</td>
<td>终止信号</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>A</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>A</td>
<td>用户自定义信号2</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>B</td>
<td>子进程结束信号</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td></td>
<td>进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>DEF</td>
<td>终止进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>D</td>
<td>控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>D</td>
<td>后台进程企图从控制终端读</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>D</td>
<td>后台进程企图从控制终端写</td>
</tr>
</tbody>
</table>
<p>处理动作一项中的字母含义如下</p>
<ul>
<li>A 缺省的动作是终止进程</li>
<li>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理</li>
<li>C 缺省的动作是终止进程并进行内核映像转储（dump core），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</li>
<li>D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）</li>
<li>E 信号不能被捕获</li>
<li>F 信号不能被忽略</li>
</ul>
<h4 id="1341-%E7%AE%A1%E9%81%93">1.3.4.1. 管道</h4>
<p>管道是所有Unix提供的进程间通信机制．管道是一个进程之间的单向数据流．一个进程写入管道的所有数据都由内核定向到另一个进程．另一个进程就可以从管道中读取数据．</p>
<p>在Ｕnix的命令中，可以使用&quot;|&quot;操作来创建管道．</p>
<pre class="hljs"><code><div><span class="hljs-comment">#第一个进程(ls程序)的标准输出被重定向到管道中．第二个进程(more程序)从这个管道中读取输入．</span>
ls | more
<span class="hljs-comment">#同上</span>
ls ＞ more
<span class="hljs-comment">#强制more从temp文件中读取数据</span>
more ＜ temp.text
</div></code></pre>
<p>管道可以看作是打开的文件．可以使用pipe()系统调用来创建一个管道，这个系统调用返回一对文件描述符，然后进程通过fork()把这两个文件描述符传递给它的子进程．由此与子进程共享管道．进程可以在read()系统调用中使用第一个文件描述符从管道中读取数据．同样也可以在write()系统调用中使用第二个文件描述符向管道中写入数据．</p>
<h3 id="135-%E7%BA%BF%E7%A8%8B">1.3.5. 线程</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1351-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.5.1. 线程的基本概念</h4>
<p>引入线程主要是为了提高系统的执行效率，减少处理机的空转时间和在进行调度切换时因保护现场信息所用的时间，便于系统管理．</p>
<p>线程是进程中执行运算的最小单位，即执行处理机调度的基本单位．在引入线程的操作系统中，可以在一个进程内部进行线程器切换，现场保护工作量小．一方面通过共享进程的基本资源而减轻系统的开销．另一方面提高了现场切换的效率．一个进程内的基本调度单位称为线程，这个调度单位可以由操作系统内核控制，也可以由用户程序控制．</p>
<p><strong>线程和进程的比较:</strong></p>
<ul>
<li>进程是操作系统资源分配的基本单位，，同一进程的所有线程共享该进程的所有资源</li>
<li>线程是分配处理机的基本��位，它与资源分配无关，即真正处理机上运行的是线程</li>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
<li>线程在执行过程中需要协作同步．不同的进程的线程间要利用消息通信的方法实现同步</li>
</ul>
<p><strong>引入线程的好处</strong></p>
<ul>
<li>易于调度,由于线程只能作为独立调度的基本单位，同一进程的多个线程共享进程的资源，所以线程易于切换</li>
<li>提高了系统的效率，通过线程可以方便有效地实现并发性，进程可以创建多个线程来执行同一程序的不同部分</li>
<li>创建一个线程比创建一个进程所花的时间开销少，创建速度快</li>
<li>有利于发挥多处理器的功能，提高进程的并发性</li>
</ul>
<p><strong>线程的状态与转换操作</strong></p>
<p>线程有三种状态：执行，阻塞，就绪</p>
<ul>
<li>派生
<ul>
<li>线程在进程中派生出来，也可在线程中派生出来</li>
<li>unix可使用clonc()和create_thread()来派生不同执行模式下的线程</li>
<li>一个新派生出来的线程具有相应的数据结构指针和变量，这些指针变量作为寄存器上下文放在本线程的寄存器和堆栈中．新派生出来的线程被放入就绪队列中</li>
</ul>
</li>
<li>调度
<ul>
<li>选择一个线程使之进入执行状态</li>
</ul>
</li>
<li>阻塞
<ul>
<li>等待某个事发生则被阻塞．</li>
</ul>
</li>
<li>激活
<ul>
<li>如果阻塞的线程所等待的事件发生，则线程进入就绪状态</li>
</ul>
</li>
<li>结束
<ul>
<li>如果一个线程执行结束，它的寄存器上下文以及堆栈内容等将被释放</li>
</ul>
</li>
</ul>
<h4 id="1352-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">1.3.5.2. 多线程的实现</h4>
<p>线程有两个基本类型：用户级线程和系统级线程．</p>
<ul>
<li>
<p>用户级线程</p>
<ul>
<li>由用户应用程序建立，并由用户程序负责进行调度和管理，操作系统内核并不知道这些线程的存在，只对进程进行管理．</li>
<li>优点
<ul>
<li>线程开关的时间消耗小</li>
<li>线程调度算法和操作系统的调度算法无关</li>
<li>用户级线程方法适用于任何操作系统，因为与内核无关</li>
</ul>
</li>
<li>缺点
<ul>
<li>在一个典型的操作系统中，有许多系统请求正被阻塞，当进程被阻塞时，进程内的所有线程也将被阻塞</li>
<li>一个进程只能由一个线程在ＣＰＵ上运行，不能利用多核ＣＰＵ的优点</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内核级线程</p>
<ul>
<li>所有线程的创建，调度和管理全部由操作系统的内核负责完成</li>
<li>优点
<ul>
<li>内核可以调度一个进程中的多个线程，使其在多个处理机上并行运行，从而提高系统的效率</li>
<li>当进程中的一个线程被阻塞时，进程中的其他线程仍然获得运行的机会</li>
<li>内核本身可以以线程的方式实现</li>
</ul>
</li>
<li>缺点
<ul>
<li>由于线程调度程序运行在内核态，而应用程序运行在用户态．因此同一进程的线程切换需要经过用户态到核心态，再从核心态到用户态的两次模式转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1353-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87">1.3.5.3. 线程上下文</h4>
<p>操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核 中移出，另一个进程成为活动的，这些��程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下 文，它描述了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。进程的上下文信息包括：</p>
<ul>
<li>进程id</li>
<li>指向可执行文件的指针</li>
<li>栈</li>
<li>静态和动态分配的变量的内存</li>
<li>处理器寄存器</li>
</ul>
<p>进程上下文的多数信息都与地址空间的描述有关。进程的上下文使用很多系统资源，而且会花费一些时间来从一个进程的上下文切换到另一个进程的上下文。 线程也有上下文。当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它 们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很 多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一的，而线程的其他方面包含在进程的各个段的内部。</p>
<p>线程本地（且唯一）的信息包括线程id、处理器寄存器(当线程执行时寄存器的状态，包括程序计数器和栈指针)、线程状态及优先级、线程特定数 据(thread-specific data，TSD)。</p>
<p>线程id是在创建线程时指定的。线程能够访问它所属进程的数据段，因此线程可以读写它所属进程的全局声明数据。进程中一个线程做出的 任何改动都可以被进程中的所有线程以及主线程获得。在多数情况下，这要求某种类型的同步以防止无意的更新。线程的局部声明变量不应当被任何对等线程访问。 它们被放置到线程栈中，而且当线程完成时，它们便会被移走。</p>
<h4 id="1354-linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.3.5.4. Linux进程和线程的区别</h4>
<p>进程与线程的区别，早已经成为了经典问题。自线程概念诞生起，关于这个问题的讨论就没有停止过。无论是初级程序员，还是资深专家，都应该考虑过这个问题，只是层次角度不同罢了。一般程序员而言，搞清楚二者的概念，在工作实际中去运用成为了焦点。而资深工程师则在考虑系统层面如何实现两种技术及其各自的性能和实现代价。以至于到今天，Linux内核还在持续更新完善(关于进程和线程的实现模块也是内核完善的任务之一)。</p>
<p>首先，简要了解一下进程和线程。对于操作系统而言，进程是核心之核心，整个现代操作系统的根本，就是以进程为单位在执行任务。系统的管理架构也是基于进程层面的。在按下电源键之后，计算机就开始了复杂的启动过程，此处有一个经典问题：当按下电源键之后，计算机如何把自己由静止启动起来的？本文不讨论系统启动过程，请读者自行科普。操作系统启动的过程简直可以描述为上帝创造万物的过程，期初没有世界，但是有上帝，是上帝创造了世界，之后创造了万物，然后再创造了人，然后塑造了人的七情六欲，再然后人类社会开始遵循自然规律繁衍生息。。。操作系统启动进程的阶段就相当于上帝造人的阶段。本文讨论的全部内容都是“上帝造人”之后的事情。第一个被创造出来的进程是0号进程，这个进程在操作系统层面是不可见的，但它存在着。0号进程完成了操作系统的功能加载与初期设定，然后它创造了1号进程(init)，这个1号进程就是操作系统的“耶稣”。1号进程是上帝派来管理整个操作系统的，所以在用pstree查看进程树可知，1号进程位于树根。再之后，系统的很多管理程序都以进程身份被1号进程创造出来，还创造了与人类沟通的桥梁——shell。从那之后，人类可以跟操作系统进行交流，可以编写程序，可以执行任务。</p>
<p>而这一切，都是基于进程的。每一个任务(进程)被创建时，系统会为他分配存储空间等必要资源，然后在内核管理区为该进程创建管理节点，以便后来控制和调度该任务的执行。</p>
<p>进程真正进入执行阶段，还需要获得CPU的使用权，这一切都是操作系统掌管着，也就是所谓的调度，在各种条件满足(资源与CPU使用权均获得)的情况下，启动进程的执行过程。</p>
<p>除CPU而外，一个很重要的资源就是存储器了，系统会为每个进程分配独有的存储空间，当然包括它特别需要的别的资源，比如写入时外部设备是可使用状态等等。有了上面的引入，我们可以对进程做一个简要的总结：</p>
<p>进程，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。它的执行需要系统分配资源创建实体之后，才能进行。</p>
<p>随着技术发展，在执行一些细小任务时，本身无需分配单独资源时(多个任务共享同一组资源即可，比如所有子进程共享父进程的资源)，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间。后来就有了专门的多任务技术被创造出来——线程。</p>
<p>线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p>
<p>从下面几个方面阐述进程和线程的区别。</p>
<ul>
<li>二者的相同点</li>
<li>实现方式的差异</li>
<li>多任务程序设计模式的区别</li>
<li>实体间(进程间，线程间，进线程间)通信方式的不同</li>
<li>控制方式的异同</li>
<li>资源管理方式的异同</li>
<li>个体间辈分关系的迥异</li>
<li>进程池与线程池的技术实现差别</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享，同步</td>
<td>数据共享复杂，需要用到ＩＰＣ，数据共享复杂．数据是分开的，同步简单</td>
<td>共享进程数据，数据共享简单，导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存，ＣＰＵ</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建和销毁</td>
<td>复杂，速度慢</td>
<td>简单，速度快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程，调试</td>
<td>简单</td>
<td>复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适用于多核，多机分布式</td>
<td>适用于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<p><strong>二者的相同点</strong></p>
<p>无论是进程还是线程，对于程序员而言，都是用来实现多任务并发的技术手段。二者都可以独立调度，因此在多任务环境下，功能上并无差异。并且二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制。而且二者所具有的状态都非常相似。而且，在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。</p>
<p>其实在Linux内核2.4版以前，线程的实现和管理方式就是完全按照进程方式实现的。在2.6版内核以后才有了单独的线程实现。</p>
<p><strong>实现方式的差异</strong></p>
<p>进程是资源分配的基本单位，线程是调度的基本单位。</p>
<p>这句经典名言已流传数十年，各种操作系统教材都可见此描述。确实如此，这就是二者的显著区别。读者请注意“基本”二字。相信有读者看到前半句的时候就在心里思考，“进程岂不是不能调度？”，非也！进程和线程都可以被调度，否则多进程程序该如何运行呢！</p>
<p>只是，线程是更小的可以调度的单位，也就是说，只要达到线程的水平就可以被调度了，进程自然可以被调度。它强调的是分配资源时的对象必须是进程，不会给一个线程单独分配系统管理的资源。若要运行一个任务，想要获得资源，最起码得有进程，其他子任务可以以线程身份运行，资源共享就行了。</p>
<p>简而言之，进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。</p>
<p>其实，也没有人写出只有线程而没有进程的程序。多线程程序中至少有一个主线程，而这个主线程其实就是有main函数的进程。它是整个程序的进程，所有线程都是它的子线程。我们通常把具有多线程的主进程称之为主线程。</p>
<p>从系统实现角度讲，进程的实现是调用fork系统调用：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
</div></code></pre>
<p>线程的实现是调用clone系统调用：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *child_stack, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">void</span> *arg, ...
<span class="hljs-comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span>
)</span></span>;
</div></code></pre>
<p>其中，fork()是将父进程的全部资源复制给了子进程。而线程的clone只是复制了一小部分必要的资源。在调用clone时可以通过参数控制要复制的对象。可以说，fork实现的是clone的加强完整版。当然，后来操作系统还进一步优化fork实现——写时复制技术。在子进程需要复制资源(比如子进程执行写入动作更改父进程内存空间)时才复制，否则创建子进程时先不复制。</p>
<p>实际中，编写多进程程序时采用fork创建子进程实体。而创建线程时并不采用clone系统调用，而是采用线程库函数。常用线程库有Linux-Native线程库和POSIX线程库。其中应用最为广泛的是POSIX线程库。因此读者在多线程程序中看到的是pthread_create而非clone。</p>
<p>我们知道，库是建立在操作系统层面上的功能集合，因而它的功能都是操作系统提供的。由此可知，线程库的内部很可能实现了clone的调用。不管是进程还是线程的实体，都是操作系统上运行的实体。</p>
<p>最后，我们说一下vfork() 。这也是一个系统调用，用来创建一个新的进程。它创建的进程并不复制父进程的资源空间，而是共享，也就说实际上vfork实现的是一个接近线程的实体，只是以进程方式来管理它。并且，vfork()的子进程与父进程的运行时间是确定的：子进程“结束”后父进程才运行。请读者注意“结束”二字。并非子进程完成退出之意，而是子进程返回时。一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间。此时，execv返回时父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？莫非视频播放器想要窥探你的聊天隐私不成？懂了吧！</p>
<p><strong>多任务程序设计模式的区别</strong></p>
<p>由于进程间是独立的，所以在设计多进程程序时，需要做到资源独立管理时就有了天然优势，而线程就显得麻烦多了。比如多任务的TCP程序的服务端，父进程执行accept()一个客户端连接请求之后会返回一个新建立的连接的描述符DES，此时如果fork()一个子进程，将DES带入到子进程空间去处理该连接的请求，父进程继续accept等待别的客户端连接请求，这样设计非常简练，而且父进程可以用同一变量(val)保存accept()的返回值，因为子进程会复制val到自己空间，父进程再覆盖此前的值不影响子进程工作。但是如果换成多线程，父线程就不能复用一个变量val多次执行accept()了。因为子线程没有复制val的存储空间，而是使用父线程的，如果子线程在读取val时父线程接受了另一个客户端请求覆盖了该值，则子线程无法继续处理上一次的连接任务了。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。但这执行起来并不简单，因为子线程与父线程的调度是独立的，父线程无法知道子线程何时复制完毕。这又得发生线程间通信，子线程复制完成后主动通知父线程。这样一来父线程的处理动作必然不能连贯，比起多进程环境，父线程显得效率有所下降。</p>
<p>PS：这里引述一个知名的面试问题：多进程的TCP服务端，能否互换fork()与accept()的位置？请读者自行思考。</p>
<p>关于资源不独立，看似是个缺点，但在有的情况下就成了优点。多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。当然多个子线程在同时执行写入操作时需要实现互斥，否则数据就写“脏”了。</p>
<p><strong>实体间(进程间，线程间，进线程间)通信方式的不同</strong></p>
<ul>
<li>
<p>进程间的通信方式有这样几种：</p>
<ul>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
<li>有名管道</li>
<li>无名管道</li>
<li>信号</li>
<li>文件</li>
<li>socket</li>
</ul>
</li>
<li>
<p>线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：</p>
<ul>
<li>互斥量</li>
<li>自旋锁</li>
<li>条件变量</li>
<li>读写锁</li>
<li>线程信号</li>
<li>全局变量</li>
</ul>
</li>
</ul>
<p>值得注意的是，线程间通信用的信号不能采用进程间的信号，因为信号是基于进程为单位的，而线程是共属于同一进程空间的。故而要采用线程信号。</p>
<p>综上，进程间通信手段有8种。线程间通信手段有13种。</p>
<p>而且，进程间采用的通信方式要么需要切换内核上下文，要么要与外设访问(有名管道，文件)。所以速度会比较慢。而线程采用自己特有的通信方式的话，基本都在自己的进程空间内完成，不存在切换，所以通信速度会较快。也就是说，进程间与线程间分别采用的通信方式，除了种类的区别外，还有速度上的区别。</p>
<p>另外，进程与线程之间穿插通信的方式，除信号以外其他进程间通信方式都可采用.线程有内核态线程与用户级线程。</p>
<p><strong>控制方式的异同</strong></p>
<p>进程与线程的身份标示ID管理方式不一样，进程的ID为pid_t类型，实际为一个int型的变量(也就是说是有限的)：</p>
<pre class="hljs"><code><div>/usr/include/unistd.h:<span class="hljs-number">260</span>:<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">__pid_t</span>   <span class="hljs-keyword">pid_t</span>;
/usr/include/bits/types.h:<span class="hljs-number">126</span>:<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __STD_TYPE    typedef</span>
/usr/include/bits/types.h:<span class="hljs-number">142</span>:__STD_TYPE  __PID_T_TYPE   <span class="hljs-keyword">__pid_t</span>;
/usr/include/bits/typesizes.h:<span class="hljs-number">53</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __PID_T_TYPE   __S32_TYPE</span>
/usr/include/bits/types.h:<span class="hljs-number">100</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>   __S32_TYPE      int</span>
</div></code></pre>
<p>在全系统中，进程ID是唯一标识，对于进程的管理都是通过PID来实现的。每创建一个进程，内核去中就会创建一个结构体来存储该进程的全部信息：</p>
<p>注：下述代码来自 Linux内核3.18.1</p>
<pre class="hljs"><code><div>include/linux/sched.h:<span class="hljs-number">1235</span>:<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> {</span>

        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;    <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>

        <span class="hljs-keyword">void</span> *<span class="hljs-built_in">stack</span>;

...

        <span class="hljs-keyword">pid_t</span> pid;

        <span class="hljs-keyword">pid_t</span> tgid;

...

};
</div></code></pre>
<p>每一个存储进程信息的节点也都保存着自己的PID。需要管理该进程时就通过这个ID来实现(比如发送信号)。当子进程结束要回收时(子进程调用exit()退出或代码执行完)，需要通过wait()系统调用来进行，未回收的消亡进程会成为僵尸进程，其进程实体已经不复存在，但会虚占PID资源，因此回收是有必要的。</p>
<p>线程的ID是一个long型变量：</p>
<pre class="hljs"><code><div>/usr/include/bits/pthreadtypes.h:<span class="hljs-number">60</span>:<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">pthread_t</span>;
</div></code></pre>
<p>它的范围大得多，管理方式也不一样。线程ID一般在本进程空间内作用就可以了，当然系统在管理线程时也需要记录其信息。其方式是，在内核创建一个内核态线程与之对应，也就是说每一个用户创建的线程都有一个内核态线程对应。但这种对应关系不是一对一，而是多对一的关系，也就是一个内核态线程可以对应着多个用户级线程。还是请读者参看《Linux线程的实质》普及相关概念。此处贴出blog地址：</p>
<p>http://my.oschina.net/cnyinlinux/blog/367910</p>
<p>对于线程而言，若要主动终止需要调用pthread_exit() ，主线程需要调用pthread_join()来回收(前提是该线程没有被detached，相关概念请查阅线程的“分离属性”)。像线发送线程信号也是通过线程ID实现的。</p>
<p><strong>资源管理方式的异同</strong></p>
<p>进程本身是资源分配的基本单位，因而它的资源都是独立的，如果有多进程间的共享资源，就要用到进程间的通信方式了，比如共享内存。共享数据就放在共享内存去，大家都可以访问，为保证数据写入的安全，加上信号量一同使用。一般而言，共享内存都是和信号量一起使用。消息队列则不同，由于消息的收发是原子操作，因而自动实现了互斥，单独使用就是安全的。</p>
<p>线程间要使用共享资源不需要用共享内存，直接使用全局变量即可，或者malloc()动态申请内存。显得方便直接。而且互斥使用的是同一进程空间内的互斥量，所以效率上也有优势。</p>
<p>实际中，为了使程序内资源充分规整，也都采用共享内存来存储核心数据。不管进程还是线程，都采用这种方式。原因之一就是，共享内存是脱离进程的资源，如果进程发生意外终止的话，共享内存可以独立存在不会被回收(是否回收由用户编程实现)。进程的空间在进程崩溃的那一刻也被系统回收了。虽然有coredump机制，但也只能是有限的弥补。共享内存在进程down之后还完整保存，这样可以拿来分析程序的故障原因。同时，运行的宝贵数据没有丢失，程序重启之后还能继续处理之前未完成的任务，这也是采用共享内存的又一大好处。</p>
<p>总结之，进程间的通信方式都是脱离于进程本身存在的，是全系统都可见的。这样一来，进程的单点故障并不会损毁数据，当然这不一定全是优点。比如，进程崩溃前对信号量加锁，崩溃后重启，然后再次进入运行状态，此时直接进行加锁，可能造成死锁，程序再也无法继续运转。再比如，共享内存是全系统可见的，如果你的进程资源被他人误读误写，后果肯定也是你不想要的。所以，各有利弊，关键在于程序设计时如何考量，技术上如何规避。这说起来又是编程技巧和经验的事情了。</p>
<p><strong>个体间辈分关系的迥异</strong></p>
<p>进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到备份关系。</p>
<p>多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</p>
<p><strong>进程池与线程池的技术实现差别</strong></p>
<p>我们都知道，进程和线程的创建时需要时间的，并且系统所能承受的进程和线程数也是有上限的，这样一来，如果业务在运行中需要动态创建子进程或线程时，系统无法承受不能立即创建的话，必然影响业务。综上，聪明的程序员发明了一种新方法——池。</p>
<p>在程序启动时，就预先创建一些子进程或线程，这样在需要用时直接使唤。这就是老人口中的“多生孩子多种树”。程序才开始运行，没有那么多的服务请求，必然大量的进程或线程空闲，这时候一般让他们“冬眠”，这样不耗资源，要不然一大堆孩子的口食也是个负担啊。对于进程和线程而言，方式是不一样的。另外，当你有了任务，要分配给那些孩子的时候，手段也不一样。下面就分别来解说。
<strong>进程池</strong>
首先创建了一批进程，就得管理，也就是你得分开保存进程ID，可以用数组，也可用链表。建议用数组，这样可以实现常数内找到某个线程，而且既然做了进程池，就预先估计好了生产多少进程合适，一般也不会再动态延展。就算要动态延展，也能预估范围，提前做一个足够大的数组。不为别的，就是为了快速响应。本来错进程池的目的也是为了效率。</p>
<p>接下来就要让闲置进程冬眠了，可以让他们pause()挂起，也可用信号量挂起，还可以用IPC阻塞，方法很多，分析各自优缺点根据实际情况采用就是了。</p>
<p>然后是分配任务了，当你有任务的时候就要让他干活了。唤醒了进程，让它从哪儿开始干呢？肯定得用到进程间通信了，比如信号唤醒它，然后让它在预先指定的地方去读取任务，可以用函数指针来实现，要让它干什么，就在约定的地方设置代码段指针。这也只是告诉了它怎么干，还没说干什么(数据条件)，再通过共享内存把要处理的数据设置好，这也子进程就知道怎么做了。干完之后再来一次进程间通信然后自己继续冬眠，父进程就知道孩子干完了，收割成果。</p>
<p>最后结束时回收子进程，向各进程发送信号唤醒，改变激活状态让其主动结束，然后逐个wait()就可以了。</p>
<p><strong>线程池</strong>
线程池的思想与上述类似，只是它更为轻量级，所以调度起来不用等待额外的资源。
要让线程阻塞，用条件变量就是了，需要干活的时候父线程改变条件，子线程就被激活。
线程间通信方式就不用赘述了，不用繁琐的通信就能达成，比起进程间效率要高一些。
线程干完之后自己再改变条件，这样父线程也就知道该收割成果了。
整个程序结束时，逐个改变条件并改变激活状态让子线程结束，最后逐个回收即可。</p>
<p><strong>分类</strong></p>
<p>根据进程与线程的设置，操作系统大致分为如下类型：</p>
<ul>
<li>单进程、单线程，MS-DOS大致是这种操作系统；</li>
<li>多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统；</li>
<li>多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；</li>
<li>单进程、多线程，VxWorks是这种操作系统。</li>
</ul>
<h3 id="136-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81">1.3.6. 处理机调度和死锁</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1361-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1">1.3.6.1. 处理机调度的层次</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>
<p>作业</p>
<ul>
<li>用户向计算机提交任务的实体</li>
<li>一个作业是指一次应用业务处理过程中，从输入开始到输出结束，用户要求计算机所做的有关该次业务处理的全部过程</li>
<li>一个作业总是由一个或者多个的进程组成</li>
</ul>
</li>
<li>
<p>调度层次</p>
<ul>
<li>作业调度(高级调度或者长调度)
<ul>
<li>用于选择把外存上处于后备队列中的那些作业调入内存，并且为它们创建进程，分配必要的资源．然后，再将新创建的进程排在就绪队列上，准备执行</li>
</ul>
</li>
<li>对换(交换调度或者中级调度)
<ul>
<li>按照给定的原则和策略，将处于外存交换区中的就绪状态或等待状态的进程调入内存，或把内存就绪状态或内存等待状态的进程交换到外存交换区</li>
<li>交换调度主要涉及到内存管理和扩充</li>
</ul>
</li>
<li>进程调度(低级调度或者微观调度)
<ul>
<li>按照某种策略和算法，将处理机分配给一个处于就绪状态的进程</li>
<li>分类
<ul>
<li>非抢占式的
<ul>
<li>不允许进程抢占已经分配出去的处理机，必须等到执行的进程执行完或者等待进程因为某种原因（比如wait操作）不能继续执行</li>
<li>实现简单，系统开销小，但很难满足紧急任务的要求</li>
</ul>
</li>
<li>抢占式的
<ul>
<li>允许调度程序根据某种原则暂停正在执行的进程，将处理机收回，分配给另一个处于就绪或者等待状态的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1362-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6">1.3.6.2. 进程调度</h4>
<ul>
<li>
<p>进程调度的功能</p>
<ul>
<li>记录系统中所有进程的执行情况</li>
<li>从就绪状态队列中选择一个进程</li>
<li>进行进程上下文的切换</li>
</ul>
</li>
<li>
<p>进程调度的时机</p>
<ul>
<li>完成任务
<ul>
<li>正在执行的进程运行完成，主动释放对ＣＰＵ的控制</li>
</ul>
</li>
<li>等待资源
<ul>
<li>由于等待某些资源或者事件发生，放弃ＣＰＵ，进入阻塞状态</li>
</ul>
</li>
<li>运行时间到
<ul>
<li>在分时系统中，当前进程使用完规定的时间片，时钟中断，使该进程让出CPU</li>
</ul>
</li>
<li>进入睡眠状态</li>
<li>发现标志</li>
<li>优先级变化
<ul>
<li>就绪队列中的某进程的优先级高于当前执行进程的优先级时，将引起进程调度</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程上下文的切换</p>
<ul>
<li>进程的上下文由正文段，数据断，硬件寄存器的内容以及有关的数据结构组成．硬件寄存器主要包括存放CPU将要执行的下条指令地址的程序计数器，指出机器与进程相关联的硬件状态的处理机状态寄存器PS .存放过程调用时所传递参数的通用寄存器R和堆栈指针寄存器S等．数据结构包括PCB等在内的所有与执行该进程相关的管理和控制用表格，数组，链等．当进程调度发生时，要做进程上下文切换</li>
<li>进程上下文切换时
<ul>
<li>决定是否要做以及是否允许做上下文切换</li>
<li>保存当前执行的进程的上下文</li>
<li>选择一个处于就绪状态的进程</li>
<li>使被选中的进程执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1363-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3. 调度算法</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="13631-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3.1. 优先级调度算法</h5>
<p>系统或者用户会按照某种原则，为作业或者进程设定一个优先级．在进行调度时，调度程序根据优先级进行调度．</p>
<ul>
<li>
<p>非抢占式优先级调度算法</p>
<ul>
<li>系统在就绪队列中寻找优先级最高的进程执行，要么等待执行结束或则进入阻塞状态才进行进程调度</li>
</ul>
</li>
<li>
<p>抢占式优先级调度算法</p>
<ul>
<li>系统在就绪队列中寻找优先级最高的进程执行，如果此时就绪队列中出现优先级更高的进程，会切换到该进程执行．</li>
<li>一般用在对实时性要求较高的系统</li>
</ul>
</li>
<li>
<p>优先级的类型</p>
<ul>
<li>静态优先级
<ul>
<li>创建进程时确定的，且在进程执行期间保持不变</li>
</ul>
</li>
<li>动态优先级
<ul>
<li>随着进程执行而改变，以便获得更好的调度性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="13632-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.3.2. 轮转调度算法</h5>
<p>时间片轮转法主要用于分时系统中的进程调度．轮转调度的实现原理是系统把　所有进入就绪状态的进程按先入先出的原则排成一个队列．新来的进程加到末尾，每当执行进程调度时，位于队首的进程被执行一段时间，当执行完后系统的定时器发出中断，进而选择新的进程继续执行．</p>
<h4 id="1364-linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">1.3.6.4. Linux的进程调度算法</h4>
<p>Linux系统的调度程序就是内核中的schedule()函数，它的主要任务是在就绪队列run_queue中选出一个进程并投入运行．
schedule()函数需要确定以下参数:</p>
<ul>
<li>进程调试算法policy</li>
<li>进程过程中剩余的时间片counter</li>
<li>进程静态优先级(已经取消)</li>
<li>实时进程的优先级rt_priority</li>
<li>用户可控制的nice因子</li>
</ul>
<h4 id="1365-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">1.3.6.5. 产生死锁的原因和必要条件</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>死锁是指多个进程循环等待其他进程占有的资源，因为额无限期僵持下去的局面，也可以说死锁是进程之间互相等待永不发生的事件，如果没有外界的作用，死锁中的各个进程将永远处于阻塞状态．</p>
<ul>
<li>
<p>死锁产生的原因</p>
<ul>
<li>各进程竞争有限的资源</li>
<li>进程推进顺序不当</li>
</ul>
</li>
<li>
<p>死锁产生的必要条件</p>
<ul>
<li>互斥条件
<ul>
<li>对于一个排他性资源，某一时刻最多只能由一个进程占有，不能同时分配给两个以上的进程．只有占有该资源的进程放弃之后，其他进程才能占用该资源</li>
</ul>
</li>
<li>占有且申请条件
<ul>
<li>进程至少已经占有一个资源，但又申请新的资源，由于该资源已经被其他进程占有，此时该进程阻塞，但是，它在等待新资源时，仍不释放已占有的资源</li>
</ul>
</li>
<li>不可抢占条件（不剥夺条件）
<ul>
<li>进程未释放该资源，其他进程不可强行剥夺该进程所占有的资源</li>
</ul>
</li>
<li>环路条件
<ul>
<li>存在一个进程序列{P1,P2....Pn},P1等待进程P2的资源，P2等待进程P3的资源．．．．．Pn等待进程P1的资源.形成一个循环等待的环路</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4个条件中只要有一个不满足，则死锁不会发生．这是预防死锁所需要考虑的问题．</p>
<ul>
<li>解决死锁的基本方法
<ul>
<li>死锁的预防
<ul>
<li>采取某种策略，减少并发进程对同一个资源的请求</li>
</ul>
</li>
<li>死锁的避免
<ul>
<li>给定一个合适的安全的进程推进顺序</li>
</ul>
</li>
<li>死锁的检测
<ul>
<li>系统能够检测死锁的发生</li>
</ul>
</li>
<li>死锁的解除</li>
</ul>
</li>
</ul>
<h3 id="137-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86">1.3.7. 存储器管理</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1371-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">1.3.7.1. 存储器的层次结构</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1372-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5">1.3.7.2. 程序的装入和链接</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1373-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">1.3.7.3. 连续分配方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1374-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.4. 基本分段存储管理方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1375-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.3.7.5. 虚拟存储器的基本概念</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1376-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.6. 请求分页存储管理方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1377-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">1.3.7.7. 页面置换算法</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1378-%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">1.3.7.8. 请求分段管理方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="138-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">1.3.8. 设备管理</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1381-io%E7%B3%BB%E7%BB%9F">1.3.8.1. I/O系统</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1382-io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">1.3.8.2. I/O控制方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1383-%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86">1.3.8.3. 缓冲管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1384-io%E8%BD%AF%E4%BB%B6">1.3.8.4. I/O软件</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1385-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D">1.3.8.5. 设备分配</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1386-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86">1.3.8.6. 磁盘存储器的管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="139-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">1.3.9. 文件管理</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1391-%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.3.9.1. 文件和文件系统</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>文件类型
<ul>
<li>按文件的数据形式分类
<ul>
<li>源文件
<ul>
<li>由源程序和数据构成的文件</li>
</ul>
</li>
<li>目标文件
<ul>
<li>由相应的编译程序编译而成的文件</li>
</ul>
</li>
<li>可执行文件
<ul>
<li>由目标文件连接而成的文件</li>
</ul>
</li>
</ul>
</li>
<li>按用途分类
<ul>
<li>系统文件</li>
<li>库文件</li>
<li>用户文件</li>
</ul>
</li>
<li>按存取权限分类
<ul>
<li>只读文件</li>
<li>读写文件</li>
<li>可执行文件</li>
</ul>
</li>
<li>按保存时间分类
<ul>
<li>临时文件</li>
<li>档案文件</li>
<li>永久文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1392-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84">1.3.9.2. 文件的结构</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>文件结构：文件的组织形式
<ul>
<li>文件的逻辑结构
<ul>
<li>从用户观察和使用文件的角度出发所定义的文件组织形式</li>
</ul>
</li>
<li>文件的物理结构(存储形式)
<ul>
<li>从系统的角度考察文件在实际存储设备上的存放形式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="13921-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">1.3.9.2.1. 文件的逻辑结构</h5>
<p>从用户对文件元素的操作出发，建立文件的逻辑结构．文件的逻辑结构决定对文件构成元素的操作方法</p>
<ul>
<li>
<p>有结构的文件</p>
<ul>
<li>在逻辑上可被砍成是一组连续顺序的记录的集合，比如多个键值对</li>
</ul>
</li>
<li>
<p>无结构的文件</p>
<ul>
<li>字符流文件，字符序列组成的文件</li>
</ul>
</li>
<li>
<p>文件存储方式</p>
<ul>
<li>顺序存储方式
<ul>
<li>按照文件的逻辑地址依次存取，也就是说每条记录都有自己的位移，通过位移可以读取到记录</li>
</ul>
</li>
<li>随机存取方式
<ul>
<li>基于磁盘的文件模式，又称为直接存取方式，允许用户随意存取文件中的任何一个物理位置，而不管上次存取了哪一个记录．</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="13922-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">1.3.9.2.2. 文件的物理结构</h5>
<p>文件的物理结构是指文件在外部存储器上的存取方式，以及它与文件逻辑结构之间的对应关系，即文件的存储结构</p>
<ul>
<li>连续文件
<ul>
<li>一个文件顺序存放在外存的若干个连续物理块中</li>
</ul>
</li>
<li>串联结构文件</li>
<li>索引文件结构
<ul>
<li>系统为每个文件建立了一张索引表，索引表是文件逻辑快号和物理块号的对照表</li>
</ul>
</li>
</ul>
<h4 id="1393-%E5%A4%96%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">1.3.9.3. 外存的分配方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1394-%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86">1.3.9.4. 目录管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>文件目录是查看，读取外存中所存放文件的数据结构，用于文件描述和文件控制，实现按名存取和文件共享和保护，随文件的建立而创建，随文件的删除而消亡</p>
<h4 id="1395-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86">1.3.9.5. 文件存储空间的管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1396-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4">1.3.9.6. 文件共享与文件保护</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1397-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A7%E5%88%B6">1.3.9.7. 数据一致性控制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="1310-%EF%BD%8Cinux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">1.3.10. Ｌinux网络基础</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="13101-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.3.10.1. 网络配置文件</h4>
<p><strong>/etc/hostname</strong>
系统的主机名称和完全域名</p>
<pre class="hljs"><code><div>$ cat /etc/hostname
lgj-Lenovo-G470

</div></code></pre>
<p><strong>/etc/host.conf</strong>
指定如何解析主机名，Linux通过解析器库获得主机名对应的ＩＰ地址</p>
<pre class="hljs"><code><div>$ cat /etc/host.conf
# The &quot;order&quot; line is only used by old versions of the C library.
# 指定主机名查询顺序，这里规定先查询／etc/hosts文件，再使用ＤＮＳ解析域名
order hosts,bind
# 表示/etc／host文件中指定的主机可以有多个地址，拥有多个ＩＰ地址的主机一般称为具有多个网络接口
multi on

</div></code></pre>
<p><strong>/etc/service</strong>
服务名和端口号之间的映射.格式：服务名　端口号／端口类型</p>
<pre class="hljs"><code><div>tcpmux		1/tcp				# TCP port service multiplexer
echo		7/tcp
echo		7/udp
discard		9/tcp		sink null
discard		9/udp		sink null
systat		11/tcp		users
daytime		13/tcp
daytime		13/udp
netstat		15/tcp

</div></code></pre>
<h3 id="1311-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7">1.3.11. 系统安全性</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="1312-unix%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84">1.3.12. Unix系统内核结构</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="14-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B">1.4. Linux系统编程</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="141-%E6%A0%87%E5%87%86">1.4.1. 标准</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1411-posix">1.4.1.1. POSIX</h4>
<p>POSIX(Portable Operating System Interface for Computing Systems)是由IEEE 和ISO/IEC 开发的一簇标准。该标准是基于现有的UNIX 实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。它是在1980 年早期一个UNIX 用户组(usr/group)的早期工作的基础上取得的。该UNIX 用户组原来试图将AT&amp;T 的系统V 和Berkeley CSRG的BSD 系统的调用接口之间的区别重新调和集成，从而于1984 年产生了/usr/group 标准。1985 年，IEEE操作系统技术委员会标准小组委员会(TCOS-SS)开始在ANSI 的支持下责成IEEE 标准委员会制定有关程序源代码可移植性操作系统服务接口正式标准。到了1986 年4 月，IEEE 就制定出了试用标准。第一个正式标准是在1988 年9 月份批准的(IEEE 1003.1-1988)，也既以后经常提到的POSIX.1 标准。</p>
<p>POSIX(Portable Operating System Interface)可移植操作系统接口，这样的简写完全是为了和UNIX读起来更像而已。它是由IEEE(电子和电气工程师协会)开发，由ANSI(美国国家标准化学会)和OSI(国际标准化组织)两个机构标准化。由于早起各厂家对UNIX的开发各自为政，互相竞争，造成UNIX版本混乱，给软件移植造成困难，不利于UNIX长期发展，基于此，IEEE开发了POSIX，在源码级别定义了一组UNIX操作系统接口。</p>
<p>目前POSIX已经成为类UNIX（Unix-like）操作系统编程的通用接口，极大方便了类UNIX环境下应用程序源码级的可移植性。Glibc(GNU C Library),即Ｃ运行库，是Linux系统中最底层的API，它就是完全按照POSIX标准编写的。</p>
<h4 id="1412-sytem-v">1.4.1.2. Sytem V</h4>
<p>System V， 曾经也被称为 AT&amp;T System V，是Unix操作系统众多版本中的一支。它最初由 AT&amp;T 开发，在1983年第一次发布。一共发行了4个 System V 的主要版本：版本1、2、3 和 4。System V Release 4，或者称为SVR4，是最成功的版本，成为一些UNIX共同特性的源头，例如 ”SysV 初始化脚本“ (/etc/init.d)，用来控制系统启动和关闭，System V Interface Definition (SVID) 是一个System V 如何工作的标准定义。</p>
<p>AT&amp;T 出售运行System V的专有硬件，但许多(或许是大多数)客户在其上运行一个转售的版本，这个版本基于 AT&amp;T 的实现说明。流行的SysV 衍生版本包括 Dell SVR4 和 Bull SVR4。当今广泛使用的 System V 版本是 SCO OpenServer，基于 System V Release 3，以及SUN Solaris 和 SCO UnixWare，都基于 System V Release 4。</p>
<p>System V 是 AT&amp;T 的第一个商业UNIX版本(UNIX System III)的加强。传统上，System V 被看作是两种UNIX”风味”之一(另一个是 BSD)。然而，随着一些并不基于这两者代码的UNIX实现的出现，例如 Linux 和 QNX， 这一归纳不再准确，但不论如何，像POSIX这样的标准化努力一直在试图减少各种实现之间的不同。</p>
<p>System V(System Five),是Unix操作系统众多版本中的一支，就是当年UNIX厂家混战中，比较强大的一个诸侯王，最初由 AT&amp;T 开发，在1983年第一次发布。一共发行了4个 System V 的主要版本：1、2、3 和 4，比如：System V Release 4，或者称为SVR4，是最成功的版本，比如现今依然使用的操作系统ＳUN Solaris 和 SCO UnixWare，都基于 System V Release 4的，SUN公司我想大家都知道吧，依然是现在商用服务器操作系统重要提供商，但是我们常用的Linux操作系统并不是基于此的，但是这里要感谢POSIX这样标准化的努力，是它兼容了绝大部分System V的规格，减少了各类操作系统之间移植的麻烦。</p>
<h4 id="1413-%E4%BD%BF%E7%94%A8">1.4.1.3. 使用</h4>
<p>照上面所说的System V和POXIS是一种应用于系统的接口协议，POXIS相对于System V可以说是比较新的标准，语法相对简单。</p>
<p>在linux/unix系统编程中支持System V和POXIS。我们常见的一个名词就是POSIX IPC和System V IPC。IPC的全称是Inter-process Comminication，就是进程间通信。</p>
<p>在POSIX IPC中，在POSIX IPC中，每个IPC对象是有名称的，而且名称是一个很重要的概念，posix ipc使用ipc的名称作为ipc的标识。mq_open sem_open shm_open三个函数的第一个参数就是这个名称，这个名称不一定是在文件系统中存在的名称。 要使用IPC对象，需要创建或者打开，这与文件操作类似，主要是使用mq_open、sem_open、shm_open 函数操作。在创建或者打开ipc对象时需要指定操作的mode，例如O_RONLY、O_WRONLY、O_RDWR、O_CREAT、O_EXCL 等，IPC对象是有一定权限的，与文件的权限类似。</p>
<p>在System V IPC中，System v ipc中有一个重要的类型是key_t，在msget、semget、shmget函数操作中都需要利用这个类型是参数。</p>
<h3 id="142-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.4.2. 基本概念</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1421-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83">1.4.2.1. 操作系统的核心</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>操作系统
<ul>
<li>完整的软件包，包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具</li>
<li>更狭义的范围内，是指管理和分配计算机资源的核心层软件(内核)</li>
</ul>
</li>
</ul>
<p>虽然在没有内核的情况下，计算机也能运行程序，但是有了内核会简化程序的编写，比如用户程序不用直接去访问计算机硬件．</p>
<ul>
<li>
<p>内核职责</p>
<ul>
<li>进程调度
<ul>
<li>Linux属于抢占式多任务操作系统</li>
</ul>
</li>
<li>内存管理
<ul>
<li>Linux采用虚拟内存管理机制
<ul>
<li>优势
<ul>
<li>进程和进程之间，进程和内核之间彼此隔离，因此一个进程无法读取或者修改内核或者其他进程的内存内容</li>
<li>只需将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在RAM中加载更多的进程．</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>提供文件系统
<ul>
<li>内核在磁盘之上提供了文件系统，允许对文件进行创建等操作</li>
</ul>
</li>
<li>创建和终止进程
<ul>
<li>内核可以将新程序载入内存，为其提供运行所需的资源．一旦进程执行结束，内核还要保证其所持有的资源　，以供后续程序使用</li>
</ul>
</li>
<li>对设备的访问
<ul>
<li>内核为程序访问设备(鼠标，键盘，磁盘等)提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</li>
</ul>
</li>
<li>联网</li>
<li>提供系统调用应用编程接口(API)
<ul>
<li>进程可以使用这些接口请求内核去执行相关的任务</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内核态和用户态</p>
<ul>
<li>现代处理器架构一般允许CPU至少在两种不同状态下运行，(用户态和内核态)．执行硬件指令可以在两种状态之间来回切换</li>
<li>与之对应，可以将虚拟内存划分为用户空间部分和内核空间部分．</li>
<li>在用户态下，cpu只能访问被标记为用户空间的内存．试图访问属于内核空间的内存会引发硬件异常．当运行于核心态时，两个内存空间都可以访问．</li>
<li>但是有些操作只能在内核空间下执行，比如访问内存管理硬件等．这种机制保证了用户态下不会执行非法操作导致系统出现异常</li>
</ul>
</li>
</ul>
<h4 id="1422-shell">1.4.2.2. shell</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>shel是一种具有特殊用途的程序，主要啊用于读取用户输入的命令，并执行相应的程序以响应命令．也称为命令解释器．</p>
<ul>
<li>几种常见的shell
<ul>
<li>Bourne（sh）</li>
<li>C shell (csh)</li>
<li>Korn shell （ksh）</li>
<li>Bourne again shell(bash)</li>
</ul>
</li>
</ul>
<h4 id="1423-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84">1.4.2.3. 用户和组</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>系统会为每个用户的身份做唯一标识，用户可隶属于多个组．</p>
<ul>
<li>超级用户
<ul>
<li>超级用户在系统中享有特权，用户ID为，通常登录名是root.超级用户可以访问系统中的任何文件．也能发送信号干预系统运行的所有用户进程．系统管理员可以使用草机用户帐号来进行各种系统管理用户．</li>
</ul>
</li>
</ul>
<h4 id="1424-%E5%8D%95%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E7%9B%AE%E5%BD%95%E9%93%BE%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6">1.4.2.4. 单根目录层级，目录，链接以及文件</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>unix的根目录是&quot;／&quot;，所有的文件和目录都是根目录的子孙．</p>
<p>文件不仅仅指文本文件，还包括设备，管道，套接字以及符号链接．</p>
<ul>
<li>一切皆文件
<ul>
<li>首先通常在windows中是文件的东西,它们在linux中也是文件</li>
<li>一些在windows中不是文件的东西, 比如进程, 磁盘, 也被抽象成了文件. 你可以使用访问文件的方法访问它们获得信息.</li>
<li>一些很离谱的东西, 比如管道, 比如/dev/zero(一个可以读出无限个0的文件) /dev/null(一个重定向进去之后就消失了的文件). 它们也是文件</li>
<li>类似于socket这样的东西, 使用的接口跟文件接口也是一致的.
带来的好处就是, 你可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源.这就使得组合了简单的命令和字符处理工具(awk, sed)之后, shell脚本就能发挥出强大的功能.</li>
</ul>
</li>
</ul>
<p>Linux下文件一般有如下几种类型</p>
<ul>
<li>普通文件          # xxx.log</li>
<li>目录              # /usr/ /home/</li>
<li>字符设备文件      # /dev/tty的属性是 crw-rw-rw- ，注意前面第一个字符是 c ，这表示字符设备文件,比如猫等串口设备</li>
<li>块设备文件        # /dev/hda1 的属性是 brw-r----- ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备</li>
<li>套接字文件        # /var/lib/mysql/mysql.sock srwxrwxrwx</li>
<li>管道              # pipe</li>
<li>符号链接文件      # softlink...</li>
</ul>
<p>每个目录至少包含两条记录，＂．＂和＂．．＂，前者指向自身目录，后者指向上级目录．根目录的&quot;..&quot;是其自身．</p>
<p>绝对路径名以&quot;/&quot;开始，相对路径基于当前的目录，缺少起始的&quot;/&quot;.</p>
<h4 id="1425-%E6%96%87%E4%BB%B6io%E6%A8%A1%E5%9E%8B">1.4.2.5. 文件IO模型</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>unix系统IO模型的特点是I/O通用性，同一套系统调用(open(),read(),write(),close()等)所执行的操作，可适用于所有文件．应用程序发起IO请求，内核会将其转化为相应的文件系统操作．或者设备驱动程序操作．也就是说内核提供了上面的通用接口．但是内核层面会根据访问文件的差异实现不同的代码．</p>
<p>就本质而言，内核只提供一种文件类型:字节流序列．在处理磁盘文件，磁盘或者磁盘驱动器时，可以通过lseek来实现随机访问．</p>
<ul>
<li>
<p>文件描述符</p>
<ul>
<li>文件描述符 是 用来访问资源(文件，输入输出设备等)的一种抽象指示符。</li>
<li>文件描述符 是POSIX(Portable Operating System Interface)规范的组成部分</li>
<li>文件描述符 通常是非负整数，C 语言中使用int类型</li>
</ul>
</li>
<li>
<p>系统默认的FDs</p>
<ul>
<li>每一个 Unix 进程中，通常会有三个预制的 FD。它们分别是
<ul>
<li>标准输入 Standard input</li>
<li>标准输出 Standard output</li>
<li>标准错误(输出) Standard error</li>
</ul>
</li>
<li>其对应的行为是
<ul>
<li>标准输入 用于程序接受数据</li>
<li>标准输出 用于程序输出数据</li>
<li>标准错误 用于程序输出错误或者诊断信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>FD 数量限制</p>
<ul>
<li>出于稳定系统性能和避免因为过多打开文件导致CPU和RAM占用居高的考虑，系统都会设置了一个最大可用的 FD 数量。</li>
<li>FD上限值通常不小，一般应用很难达到。</li>
<li>限制类型
<ul>
<li>hard limit 由系统管理权限人员设定，是soft limit 可以设置的上限</li>
<li>soft limit 当前用户设置，用来限定进程，通常小于（但不能超过）hard limit值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">#查看soft limit 设置	</span>
<span class="hljs-built_in">ulimit</span> -nS	
4864	
<span class="hljs-comment">#查看 hard limit 设置	</span>
<span class="hljs-built_in">ulimit</span> -nH	
unlimited
</div></code></pre>
<ul>
<li>
<p>进程退出与 FD 关系</p>
<ul>
<li>因为file descriptor table 存在于 PCB (进程控制块，Process Control Block) 中，进程退出后所有的 FD都需要关闭处理掉。</li>
</ul>
</li>
<li>
<p>同一路径 与 FD 关系</p>
<ul>
<li>同一文件，多次打开，FD值不同</li>
<li>同一文件，读写模式不同打开，FD值也不同</li>
</ul>
</li>
<li>
<p>打开文件过多会怎样</p>
<ul>
<li>open返回值会出现 -1</li>
<li>通常会导致进程无法进行，甚至是崩溃</li>
</ul>
</li>
</ul>
<h4 id="1426-%E7%A8%8B%E5%BA%8F">1.4.2.6. 程序</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1427-%E8%BF%9B%E7%A8%8B">1.4.2.7. 进程</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>进程是正在执行的程序实例．也是受操作系统资源管理的基本单位．执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核数据结构．以记录与进程相关的各种信息，比如进程id，用户id等信息．</p>
<p>在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源．对于像内存这样的受限资源来说，内核一开始会为进程分配一定数量的资源，并在进程的生命周期内，统筹该进程和整个系统对资源的需求．对这一分配进行调整．程序终止时，内核会释放所有此类资源，供其他进程使用．</p>
<ul>
<li>
<p>进程的内存布局</p>
<ul>
<li>文本:程序的指令</li>
<li>数据:程序使用的静态变量</li>
<li>堆：程序可从该区域动态分配内存</li>
<li>栈：随函数调用＼返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</li>
</ul>
</li>
<li>
<p>创建进程和执行程序</p>
<ul>
<li>进程可以使用系统调用fork()来创建一个新进程．调用fork()的进程称为父进程．新创建的进程为子进程，内核通过对父进程的复制来创建子进程．子进程从父进程处继承数据段，栈段，以及堆段的副本后，可以修改这些内容，但是不会影响父进程的原版内容．在内存中标记为只读的程序文本则由父子进程共享</li>
</ul>
</li>
</ul>
<p>每一个进程都有一个唯一的整数型标识符(PID).此外，每一个进程还具有一个父进程标识符(PPID)</p>
<ul>
<li>资源限制
<ul>
<li>每个进程都会消耗诸如打开文件，内存，以及cpu时间之类的资源．使用系统调用setrlimit()，进程可以为自己消耗的各类资源设定上限．</li>
<li>软限制(soft　limit),限制进程可以消耗的资源总量．硬限制(hard limit),软限制的调整上限．</li>
<li>非特权用户可调整软限制0－相应的硬限制之间的值．但是硬限制只能调低不能调高．</li>
<li>由fork（）创建的新进程，会继承其父进程对资源的限制值</li>
</ul>
</li>
</ul>
<h4 id="1428-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84">1.4.2.8. 内存映射</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1429-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93">1.4.2.9. 静态库和共享库</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14210-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%92%8C%E5%90%8C%E6%AD%A5">1.4.2.10. 进程间通信和同步</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14211-%E4%BF%A1%E5%8F%B7">1.4.2.11. 信号</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14212-%E7%BA%BF%E7%A8%8B">1.4.2.12. 线程</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14213-%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8Cshell%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6">1.4.2.13. 进程组和shell任务控制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14214-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B">1.4.2.14. 会话，控制终端和控制进程</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14215-%E4%BC%AA%E7%BB%88%E7%AB%AF">1.4.2.15. 伪终端</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14216-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">1.4.2.16. 日期和时间</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14217-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84">1.4.2.17. 客户端服务器架构</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14218-%E5%AE%9E%E6%97%B6%E6%80%A7">1.4.2.18. 实时性</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="14219-%EF%BC%8Fproc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.4.2.19. ／proc文件系统</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="15-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">1.5. 计算机网络</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="151-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1.5.1. 网络基础知识</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1511-osi%E7%BD%91%E8%B7%AF%E5%88%86%E5%B1%82">1.5.1.1. OSI网路分层</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>网路通信系统应该完成的任务:</p>
<ul>
<li>把消息分解成可管理的数据块,并且这些数据块能够有效地通过传输乎介质</li>
<li>与网络适配器进行连接</li>
<li>寻址,即发送端计算机必须能改定位到接收数据的计算机,接收数据的计算机必须能够识别自己要接收的数据</li>
<li>将数据路由到目的计算机所在的子网,即使源子网和目的子网分处不同的物理网路</li>
<li>执行错误控制,流量控制和确认,对可靠的通信而言,发送和接收计算机必须能发现并纠正传输错误,并控制数据流</li>
<li>从应用程序接收数据并传输到网络</li>
<li>从网络接收数据并传输到应用程序</li>
</ul>
<p>为了实现上述的功能,TCP/IP使用了分层的模块化设计,每个模块是独立的,分别负责通信过程中的一个步骤.模块化设计可以轻易进行内部修改而不需要其他模块进行同步修改.</p>
<p>OSI分为七层,而TCP/IP常规分为四层:应用层,传输层,网络层,网络访问层.</p>
<p><img src="https://github.com/lgjlife/Java-Study/pic/tcp/osi.png" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th>层</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层</td>
<td>为应用程序提供网络接口,支持文件传输,通信等功能的网络应用.针对特定应用的协议</td>
<td>电子邮件，远程登录，文件传输等。HTTP，DNS，DHCP，SSH，FTP</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>把数据转换为标准格式,管理数据加密与压缩.设备固有数据格式和网络标准数据格式的转换</td>
<td>接收不同表现形式的信息，比如文字，图片，声音等</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>在计算机的通信应用程序之间建立会话.通信管理，负责建立连接和断开通信连接，管理传输层以下的分层</td>
<td>何时建立连接，何时断开连接，保持多久的连接</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>为网络提供错误控制和数据流控制.管理两个节点之间的可靠传输</td>
<td>TCP，UDP，SCYP，DCCP</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>支持逻辑寻址和路由选择.地址管理和路由选择</td>
<td>如何通过IP地址寻找目标主机，IPV4,IPV6,ARP地址解析协议</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>互联设备之间传送和识别数据帧</td>
<td>数据帧和比特位之间的转换</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>数据比特流在实际物理设备上的传输，比如光纤。负责比特流和物理电压之间的转换</td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/send.png?raw=true" alt=""></p>
<p>在数据发送时，下层不会改变上层的PDU（消息），只会在上层上添加头部或者尾部信息。</p>
<p>一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层协议系统</p>
<ul>
<li>网络访问层
<ul>
<li>提供与物理网络连接的接口</li>
<li>实现数据在物理设备之间的传输和错误控制等</li>
<li>有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</li>
</ul>
</li>
<li>网络层
<ul>
<li>提供独立于硬件的逻辑寻址,从而能改让数据在不同的子网之间进行传递</li>
<li>有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控
制报文协议），以及IGMP协议（Internet组管理协议）。</li>
</ul>
</li>
<li>传输层
<ul>
<li>为网络提供了流量控制,错误控制,和确认服务</li>
<li>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。这两种运输层协议分别在不同的应用程序中有不同的用途。</li>
</ul>
</li>
<li>应用层
<ul>
<li>为网络排错,文件传输,远程控制和网络操作提供了应用程序,还支持应用编程接口,从而使得针对特定操作系统编写的程序能访问网络</li>
<li>负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：
<ul>
<li>Telnet 远程登录。</li>
<li>FTP 文件传输协议。</li>
<li>SMTP 简单邮件传送协议。</li>
<li>SNMP 简单网络管理协议。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据在各层间传递时,每一层的数据为:报头+数据.发送端计算机上的每一层协议都在数据上添加层信息,也就是在上一层传递的数据添加本层的报头信息.而在接收端,数据在各层间传递,这些报头信息会被主键解除.</p>
<p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>
<ul>
<li>分层优点
<ul>
<li>解耦，每层内部协议改变，不影响其他层。</li>
<li>开发方便，每层负责自己的协议即可。</li>
</ul>
</li>
<li>传输方式分类
<ul>
<li>有连接型
<ul>
<li>发送数据前，两个通信端必须建立连接的通信链路(TCP)</li>
</ul>
</li>
<li>无连接型
<ul>
<li>不要求建立和断开连接，发送端任何时候都可以发送数据(UDP)</li>
</ul>
</li>
<li>根据接收端数据分类
<ul>
<li>单播：一对一通信</li>
<li>多播:一对多通信，组播通信</li>
<li>任播:特定的多台主机中选出一台进行通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1512-%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD">1.5.1.2. 关键术语</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>TCP/IP
<ul>
<li>网络协议簇</li>
</ul>
</li>
<li>ARPAnet
<ul>
<li>一种实验性网络,也是TCP/IP的诞生地</li>
</ul>
</li>
<li>域名
<ul>
<li>通过TCP/IP的DNS域名服务系统,与IP地址相关联的名字</li>
</ul>
</li>
<li>网关
<ul>
<li>连接LAN到大型网络的路由器</li>
</ul>
</li>
<li>IP地址
<ul>
<li>用于定位TCP/IP网络计算机或其他连接网络设备的逻辑地址</li>
</ul>
</li>
<li>局域网LAN
<ul>
<li>供单个办公室,组织或者家庭使用的小型网络</li>
</ul>
</li>
<li>逻辑地址
<ul>
<li>通过协议软件配置的网络地址</li>
</ul>
</li>
<li>域名服务
<ul>
<li>将网络地址与便于人记忆的名字相关联的一种服务,提供该服务的计算机被称为域名服务器,将名字解析为地址的行为称为名称解析</li>
</ul>
</li>
<li>端口
<ul>
<li>一种内部通道或者地址,它在应用程序和TCP/IP传输层之间提供了一个接口</li>
</ul>
</li>
<li>RFC
<ul>
<li>提供TCP/IP相关技术文档</li>
</ul>
</li>
<li>路由器
<ul>
<li>通过逻辑地址来转发数据的一种网络设备.并且也可以用来将大型网络分为几个较小的子网</li>
</ul>
</li>
</ul>
<h3 id="152-%E7%BD%91%E7%BB%9C%E5%B1%82">1.5.2. 网络层</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1521-%E5%AF%BB%E5%9D%80%E5%92%8C%E5%8F%91%E9%80%81">1.5.2.1. 寻址和发送</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>计算机通过网络接口设备与网络进行通信,网络接口设备具有唯一的物理地址,用于接收发向该地址的数据.网路接口设备对于上层协议层的细节不了解,不知到IP地址,也不知道发送来的数据帧是要给FTP还是其他的应用层软件.它只是监听了是否收到数据帧,发现其中目标地址与自己物理地址相符的帧,并把这个帧传递给上层协议栈.</p>
<p>TCP/IP隐藏了物理地址,以一种逻辑化,层次化的寻址方案对网络进行组织.这种逻辑寻址方案由网际层的IP协议维护,而逻辑地址为IP地址,地址解析协议ARP是另一种网际层协议,维护了一个表格,用于把IP地址转化成物理地址.</p>
<p>数据在网络间传输过程</p>
<ul>
<li>如果目的地址和源地址在同一个网段,源计算机就把数据包直接发送给目的计算机,IP地址被ARP解析为物理地址,数据被直接发送给目的网络适配器</li>
<li>如果目的地址和源地址不再同一个网段,就执行如下过程
<ul>
<li>直接将数据发送到网关,网关是位于局域网网段上的一个设备,能够把数据报转发到其他网段,网关地址被ARP解析为物理地址,数据被发送到网关的网络适配器</li>
<li>数据报通过网关被路由到更高级别的网段,再次重复上述过程,如果目的地址在这个新网段内,数据就被发送到目的,否则数据就被发送到另一个网关</li>
<li>数据报经过一系列网关转发到目的网段,目的IP地址被ARP解析为物理地址,数据被发送到目的网络适配器</li>
</ul>
</li>
</ul>
<h4 id="1522-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.5.2.2. 基本概念</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>IP(Internet Protocol,网际协议)是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输.</p>
<p>IP协议它提供了一种分层的,与硬件无关的寻址系统,具有在复杂的路由式网络中传递数据所需的服务,每个网络适配器都有一个唯一的IP地址.如果计算机有多个网卡,也就有多个IP地址.
IP提供不可靠、无连接的数据报传送服务</p>
<p>不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</p>
<p>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</p>
<p>IP协议负责将数据包发送给最终的目标主机。
通信链路层是负责两个直连两个设备之间的通信，而IP是负责两个没有直连设备之间的通信。每个计算机都有自己的IP地址，发送端在发送数据之前要先确定接收者是属于哪台计算机。也就是ARP地址解析协议，通过广播发送请求，有回应的是便是目标主机，然后获取目标主机的网卡地址，缓在发送端，下次发送的时候，就可以从缓存中获取到目标主机的网卡地址。</p>
<ul>
<li>IP协议是面向无连接的，通信可靠性由上层解决
<ul>
<li>一是为了简化</li>
<li>二是为了快速</li>
</ul>
</li>
</ul>
<h4 id="1523-ip%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%B9%89">1.5.2.3. IP地址定义</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/ip-address.png?raw=true" alt="IPV4协议"></p>
<ul>
<li>IPV4
<ul>
<li>使用32位来表示，每8位一组，中间使用&quot;.&quot;分隔</li>
<li>最大值2的32次方，也就是42.94亿，无法满足全球用户</li>
<li>组成
<ul>
<li>由网络标识(网络地址)和主机标识(主机地址)组成</li>
<li>192.168.1.10/24</li>
<li>&quot;/24&quot;表示从第一位到24位是网络标识，后面的为主机标识</li>
<li>路由器通过比较网络标识决定如何转发</li>
<li>同一个网络标识作为一个网段</li>
</ul>
</li>
<li>IPV4地址的分类
<ul>
<li>A类
<ul>
<li>0开头的地址,前8位为网络ID</li>
<li>第一位到第八都是它的网络标��：0.0.0.0～127.0.0.0</li>
<li>A类地址后24位为主机标识，也就是A类网段可以容纳16777214个主机</li>
</ul>
</li>
<li>B类
<ul>
<li>&quot;10&quot;开头的地址,前16位为网络ID</li>
<li>1～16位是它的网络标识，128.0.0.1～191.255.0.0是B类的网络地址</li>
<li>后16位是主机标识，所以B类一个网段可以容纳的主机最大为65534</li>
</ul>
</li>
<li>C类
<ul>
<li>&quot;110&quot;开头的地址,前24位为网络ID</li>
<li>1~24位是网络标识，192.168.0.0～239.255.255.0</li>
<li>主机标识为后8位，一个网段最大主机数为254个</li>
</ul>
</li>
<li>D类
<ul>
<li>&quot;1110&quot;开头的地址</li>
<li>1~32位是它的网络标识，224.0.0.0～239.255.255.255</li>
<li>没有主机标识，常被用于多播</li>
</ul>
</li>
<li>IP主机地址不能全部为0或者全部为1
<ul>
<li>全部为0表示IP地址在网络地址不可获知的情况下才使用，因此上面每个都少了两个IP地址。</li>
<li>全部为1通常用作广播地址</li>
</ul>
</li>
</ul>
</li>
<li>广播
<ul>
<li>广播主机地址全部设置为1</li>
<li>本地广播:本网络内的广播</li>
<li>直接广播:不同网络之间的广播</li>
</ul>
</li>
<li>IP多播
<ul>
<li>广播是将数据发送给网络上的所有计算机，由于不是目标的主机也会收到消息，因此造成通讯效率差。</li>
<li>多播是放送给特定组的主机</li>
<li>应用场景:电视会议中的1对多</li>
<li>多播采用D类地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1524-ipv4%E6%95%B0%E6%8D%AE%E6%8A%A5">1.5.2.4. IPV4数据报</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/ip-protocol.png?raw=true" alt="IPV4协议"></p>
<table>
<thead>
<tr>
<th></th>
<th>长度(bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本 Version</td>
<td>4</td>
</tr>
<tr>
<td>首部长度 IHL</td>
<td>4</td>
</tr>
<tr>
<td>区分服务 Type of Service</td>
<td>8</td>
</tr>
<tr>
<td>总长度 Total Length</td>
<td>32</td>
</tr>
<tr>
<td>标识 Identification</td>
<td>16</td>
</tr>
<tr>
<td>标志 Flags</td>
<td>3</td>
</tr>
<tr>
<td>片偏移 Fragment Offset</td>
<td>29</td>
</tr>
<tr>
<td>生存时间 Time To Live</td>
<td>8</td>
</tr>
<tr>
<td>协议 Protocal</td>
<td>8</td>
</tr>
<tr>
<td>首部校验和 Header CheckSum</td>
<td>32</td>
</tr>
<tr>
<td>源地址 Source Address</td>
<td>32</td>
</tr>
<tr>
<td>目标地址 Destination Adress</td>
<td>32</td>
</tr>
<tr>
<td>可选字段 Options</td>
<td>24</td>
</tr>
<tr>
<td>填充 Padding</td>
<td>8</td>
</tr>
<tr>
<td>实际的数据部分Data</td>
<td>~</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>最高位在左边，记为0bit；最低位在右边，记为31bit。4个字节的32bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作bigendian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如littleendian格式，则必须在传输数据之前把首部转换成网络字节序。</p>
</li>
<li>
<p>IP协议的版本,目前的版本是4</p>
</li>
<li>
<p>首部长度指的是首部占32bit字的数目，包括任何选项。</p>
</li>
<li>
<p>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务.不同的应用程序有不同的推荐值.现在大多数的TCP/IP实现都不支持TOS特性</p>
</li>
</ul>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/ip-protocol-tos.png?raw=true" alt="IPV4协议-TOS"></p>
<ul>
<li>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节,超过则会进行数据分片</li>
<li>标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。在介绍分片和重组时再详细讨论它。同样，在讨论分片时再来分析标志字段和片偏移字段。</li>
<li>TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>
<li>首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。数据包每经过一个路由器就重新计算,因为TTL字段总是在变化</li>
<li>每一份IP数据报都包含源IP地址和目的IP地址</li>
<li>最后一个字段是任选项，是数据报中的一个可变长的可选信息
<ul>
<li>安全和处理限制（用于军事领域，详细内容参见 RFC 1108[Kent 1991]）</li>
<li>记录路径（让每个路由器都记下它的IP地址）</li>
<li>时间戳（让每个路由器都记下它的IP地址和时间）</li>
<li>宽松的源站选路（为数据报指定一系列必须经过的IP地址）</li>
<li>严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址） 。</li>
<li>这些选项很少被使用，并非所有的主机和路由器都支持这些选项</li>
</ul>
</li>
</ul>
<h4 id="1525-ip%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9">1.5.2.5. IP路由选择</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1526-ipv6%E5%8D%8F%E8%AE%AE">1.5.2.6. IPV6协议</h4>
<ul>
<li>IPV6
<ul>
<li>IPV6地址
<ul>
<li>长度为128位，16位为1组，中间使用::分隔</li>
<li>二进制表示
<ul>
<li>10101010:10101010:10101010:10101010:10101010:10101010:10101010:10101010</li>
</ul>
</li>
<li>16进制表示
<ul>
<li>AABB:AABB:AABB:AABB:AABB:AABB:AABB:AABB</li>
</ul>
</li>
<li>省略表示，中间连续多个0的,使用::替换
<ul>
<li>AABB:0:0:0:0:0:0:AABB</li>
<li>AABB::AABB</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>未定义</td>
<td>0000...0000（128比特位）</td>
<td>::/128</td>
</tr>
<tr>
<td>环回地址</td>
<td>0000...0001</td>
<td>::1/128</td>
</tr>
<tr>
<td>唯一本地地址</td>
<td>1111 110</td>
<td>FC00::/7</td>
</tr>
<tr>
<td>链路本地单播地址</td>
<td>1111 1110 10</td>
<td>FE8O::/10</td>
</tr>
<tr>
<td>多播地址</td>
<td>11111111</td>
<td>FF00::/8</td>
</tr>
<tr>
<td>全局单播地址</td>
<td>其他</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="1527-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.5.2.7. 常用命令</h4>
<h5 id="15271-ping">1.5.2.7.1. ping</h5>
<ul>
<li>作用
<ul>
<li>用来检测网络的连通情况和分析网络速度；</li>
<li>根据域名得到服务器IP；</li>
<li>根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>$ ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.054 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.092 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.084 ms

</div></code></pre>
<ul>
<li>bytes值：数据包大小，也就是字节。</li>
<li>time值：响应时间，这个时间越小，说明你连接这个地址速度越快</li>
<li>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列</li>
<li>icmp_seq 序列号</li>
</ul>
<h5 id="15272-ifconfig">1.5.2.7.2. ifconfig</h5>
<p>ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<pre class="hljs"><code><div><span class="hljs-string">[root@localhost</span> <span class="hljs-string">~]#</span> <span class="hljs-string">ifconfig</span> <span class="hljs-string">eth0</span>
 
<span class="hljs-string">//</span> <span class="hljs-string">UP：表示“接口已启用”。</span>
<span class="hljs-string">//</span> <span class="hljs-string">BROADCAST</span> <span class="hljs-string">：表示“主机支持广播”。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RUNNING：表示“接口在工作中”。</span>
<span class="hljs-string">//</span> <span class="hljs-string">MULTICAST：表示“主机支持多播”。</span>
<span class="hljs-string">//</span> <span class="hljs-string">MTU:1500（最大传输单元）：1500字节</span>
<span class="hljs-attr">eth0:</span> <span class="hljs-string">flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</span> <span class="hljs-string">mtu</span> <span class="hljs-number">1500</span>
 
 
<span class="hljs-string">//</span> <span class="hljs-string">inet</span> <span class="hljs-string">：网卡的IP地址。</span>
<span class="hljs-string">//</span> <span class="hljs-string">netmask</span> <span class="hljs-string">：网络掩码。</span>
<span class="hljs-string">//</span> <span class="hljs-string">broadcast</span> <span class="hljs-string">：广播地址。</span>
<span class="hljs-string">inet</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.135</span> <span class="hljs-string">netmask</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> <span class="hljs-string">broadcast</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.255</span>
 
 
<span class="hljs-string">//</span> <span class="hljs-string">网卡的IPv6地址</span>
<span class="hljs-string">inet6</span> <span class="hljs-string">fe80::2aa:bbff:fecc:ddee</span> <span class="hljs-string">prefixlen</span> <span class="hljs-number">64</span> <span class="hljs-string">scopeid</span> <span class="hljs-number">0x20</span><span class="hljs-string">&lt;link&gt;</span>
 
<span class="hljs-string">//</span> <span class="hljs-string">连接类型：Ethernet</span> <span class="hljs-string">(以太网)</span> <span class="hljs-string">HWaddr</span> <span class="hljs-string">(硬件mac地址)</span>
<span class="hljs-string">//</span> <span class="hljs-string">txqueuelen</span> <span class="hljs-string">(网卡设置的传送队列长度)</span>
<span class="hljs-string">ether</span> <span class="hljs-number">00</span><span class="hljs-string">:aa:bb:cc:dd:ee</span> <span class="hljs-string">txqueuelen</span> <span class="hljs-number">1000</span> <span class="hljs-string">(Ethernet)</span>
 
 
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">packets</span> <span class="hljs-string">接收时，正确的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">bytes</span> <span class="hljs-string">接收的数据量。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">errors</span> <span class="hljs-string">接收时，产生错误的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">dropped</span> <span class="hljs-string">接收时，丢弃的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">overruns</span> <span class="hljs-string">接收时，由于速度过快而丢失的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">RX</span> <span class="hljs-string">frame</span> <span class="hljs-string">接收时，发生frame错误而丢失的数据包数。</span>
<span class="hljs-string">RX</span> <span class="hljs-string">packets</span> <span class="hljs-number">2825</span> <span class="hljs-string">bytes</span> <span class="hljs-number">218511</span> <span class="hljs-string">(213.3</span> <span class="hljs-string">KiB)</span>
<span class="hljs-string">RX</span> <span class="hljs-string">errors</span> <span class="hljs-number">0</span> <span class="hljs-string">dropped</span> <span class="hljs-number">0</span> <span class="hljs-string">overruns</span> <span class="hljs-number">0</span> <span class="hljs-string">frame</span> <span class="hljs-number">0</span>
 
 
 
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">packets</span> <span class="hljs-string">发送时，正确的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">bytes</span> <span class="hljs-string">发送的数据量。</span>
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">errors</span> <span class="hljs-string">发送时，产生错误的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">dropped</span> <span class="hljs-string">发送时，丢弃的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">overruns</span> <span class="hljs-string">发送时，由于速度过快而丢失的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">TX</span> <span class="hljs-string">carrier</span> <span class="hljs-string">发送时，发生carrier错误而丢失的数据包数。</span>
<span class="hljs-string">//</span> <span class="hljs-string">collisions</span> <span class="hljs-string">冲突信息包的数目。</span>
<span class="hljs-string">TX</span> <span class="hljs-string">packets</span> <span class="hljs-number">1077</span> <span class="hljs-string">bytes</span> <span class="hljs-number">145236</span> <span class="hljs-string">(141.8</span> <span class="hljs-string">KiB)</span>
<span class="hljs-string">TX</span> <span class="hljs-string">errors</span> <span class="hljs-number">0</span> <span class="hljs-string">dropped</span> <span class="hljs-number">0</span> <span class="hljs-string">overruns</span> <span class="hljs-number">0</span> <span class="hljs-string">carrier</span> <span class="hljs-number">0</span> <span class="hljs-string">collisions</span> <span class="hljs-number">0</span>
</div></code></pre>
<h5 id="15273-netstat">1.5.2.7.3. netstat</h5>
<h3 id="153-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90dns">1.5.3. 域名解析DNS</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>TCP/IP网络中，每一个互联的设备都有其唯一的IP地址，都可以通过IP地址访问到对方。但是IP地址不便于记忆，因此产生了一种方式，就是给每台计算机赋予唯一的主机名，可以通过主机名访问该主机名对应的IP地址的计算机。在这个背景下，便产生了一个可以有效管理主机名和IP地址之间对应关系的系统，那就是DNS系统。</p>
<p>域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。这里提到的分布式是指在Internet上的单个站点不能拥有所有的信息。</p>
<p>从应用的角度上看，对DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两个库函数gethostbyname(3)和gethostbyaddr(3)来访问的，它们在编译应用程序时与应用程序连接在一起。前者接收主机名字返回IP地址，而后者接收IP地址来寻找主机名字。解析器通过一个或多个名字服务器来完成这种相互转换。</p>
<h4 id="1531-dns-%E5%9F%BA%E7%A1%80">1.5.3.1. DNS 基础</h4>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/dns-layer.png?raw=true" alt="DNS层次结构"></p>
<p>每个结点有一个至多63个字符长的标识。这颗树的树根是没有任何标识的特殊结点。命名标识中一律不区分大写和小写。命名树上任何一个结点的域名就是将从该结点到最高层的域名串连起来，中间使用一个点“.”分隔这些域名（注意这和Unix文件系统路径的形成不同，文件路径是由树根依次向下的形成的）。域名树中的每个结点必须有一个唯一的域名，但域名树中的不同结点可使用相同的标识。</p>
<p>以点“.”结尾的域名称为绝对域名或完全合格的域名FQDN（FullQualifiedDomainName），例如sun.tuc.noao.edu.。如果一个域名不以点结尾，则认为该域名是不完全的。如何使域名完整依赖于使用的DNS软件。如果不完整的域名由两个或两个以上的标号组成，则认为它是完整的；或者在该域名的右边加入一个局部后缀。例如域名sun通过加上局部后缀.tuc.noao.edu.成为完整的。</p>
<ul>
<li>级域名被分为三个部分：
<ul>
<li>arpa是一个用作地址到名字转换的特殊域</li>
<li>7个3字符长的普通域。有些书也将这些域称为组织域。
<ul>
<li>com 商业组织</li>
<li>edu 教育机构</li>
<li>gov 其他美国政府部门</li>
<li>int 国际组织</li>
<li>mil 美国军事网点</li>
<li>net 网络</li>
<li>org 其他组织</li>
</ul>
</li>
<li>所有2字符长的域均是基于ISO3166中定义的国家代码，这些域被称为国家域，或地理域。</li>
</ul>
</li>
</ul>
<p>DNS的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到IP地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。</p>
<p><strong>域名</strong>:域名是为了识别主机名称和组织机构名称的一种具有分层的名称。比如:www.baidu.com
<img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/yuming.png?raw=true" alt="">
<strong>域名服务器</strong>:域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。根部所设置的DNS叫做根域名服务器。他对DNS的检索起着至关重要的作用。根域名服务器注册着根以下第一层域名服务器的IP地址。也就是说上一层注册着下一层的域名服务器的IP地址。根据每个域名服务器所管理的域名，如果下面再没有其他分层，就可以自由的指定主机名称或者子网名称。如果想修改分层的域名名称或者想重新修改域名服务器的IP地址，还必须向其上层的域名服务器进行追加或修改。
由于是分层设计，如果某一台域名服务器宕机，那么针对该域名的查询将会失效，一般设置两台以上域名服务器，以提高容灾能力，第一个查询失败，则转到另一个。</p>
<p><strong>域名查询</strong></p>
<ul>
<li>进行DNS查询的主机和软件叫做DNS解析器</li>
<li>查询过程</li>
</ul>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/dns-search.png?raw=true" alt="">
解析器为了查询IP地址，向域名服务器查询，接收这个请求的域名服务器先在自己的数据库中查找，没有查找到则向上一级查找，直至遍历完查找到，查找到则将数据缓存起来，下次使用可以从缓���里面获取。</p>
<h3 id="154-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEarp">1.5.4. 地址解析协议ARP</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1541-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">1.5.4.1. 基本原理</h4>
<p>DNS是通过访问名称获取到IP地址，但是有进行访问还需要获取到这个IP地址对应的MAC地址。</p>
<p>AP为IP地址到对应的硬件地址之间提供动态映射:32bit的IP地址和数据链路层使用的任何类型的地址.从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。 ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，ARP请求数据帧中包含目的主机的IP地址其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址.收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。发送IP数据报到目的主机</p>
<ul>
<li>查找流程:
<ul>
<li>主机A访问主机B</li>
<li>主机A广播发送一个ARP请求包，这个包包括主机B的IP地址</li>
<li>这个广播包将会被链路上所有的计算机接收并解析</li>
<li>如果请求包中的IP地址和自己的IP地址一致，那么这个节点将会把自己的MAC地址塞入ARP响应包并返回给主机A</li>
<li>主机A获取到主机B的MAC地址，就可以和主机B进行通信了。</li>
<li>主机A会将主机B的MAC地址进行缓存到本地，以供下次使用</li>
<li>这个缓存会按照一定机制被清除，也就是有过期时间。同时若请求失败，也会重新发起获取MAC地址请求。</li>
</ul>
</li>
</ul>
<p>在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48bit的值，标识不同的以太网或令牌环网络接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP/IP有自己的地址：32bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。</p>
<h4 id="1542-arp%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98">1.5.4.2. ARP高速缓存</h4>
<p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</p>
<pre class="hljs"><code><div>$arp -a
promote.cache-dns.local (192.168.1.1) at 1c:60:de:1c:aa:a6 [ether] on wlp8s0b1
promote.cache-dns.local (192.168.1.100) at 68:3e:34:e2:d7:fe [ether] on wlp8s0b1
</div></code></pre>
<p>48 bit的以太网地址用 6个十六进制的数来表示，中间以冒号隔开。</p>
<h4 id="1543-arp%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F">1.5.4.3. ARP分组格式</h4>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/arp-protocols.png?raw=true" alt="ARP分组格式"></p>
<ul>
<li>以太网报头中的前两个字段是以太网的源地址和目的地址。目的地址为全1的特殊地址是广播地址。电缆上的所有以太网接口都要接收广播的数据帧。</li>
<li>两个字节长的以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。s</li>
<li>形容词hardware(硬件)和protocol(协议)用来描述ARP分组中的各个字段。例如，一个ARP请求分组询问协议地址（这里是IP地址）对应的硬件地址（这里是以太网地址）。硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。协议类型字段表示要映射的协议地址类型。它的值为0x0800即表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同。</li>
<li>接下来的两个1字节的字段，硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。</li>
<li>操作字段指出四种操作类型，它们是ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）（我们在第5章讨论RARP）。这个字���必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。</li>
<li>接下来的四个字段是发送端的硬件地址（在本例中是以太网地址）、发送端的协议地址（IP地址）、目的端的硬件地址和目的端的协议地址。注意，这里有一些重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。</li>
<li>对于一个 ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的 ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为 2，最后把它发送回去</li>
</ul>
<h3 id="155-%E5%B9%BF%E6%92%AD%E5%92%8C%E5%A4%9A%E6%92%AD">1.5.5. 广播和多播</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>有三种IP地址：单播地址、广播地址和多播地址.</p>
<p>广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由 IP地址确定）内的两进程（由端口号确定）间存在一条连接.</p>
<ul>
<li>单播(unicast)
<ul>
<li>考虑包含多个主机的共享信道网络如以太网。每个以太网帧包含源主机和目的主机的以太网地址（48bit）。通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口</li>
<li>在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）</li>
</ul>
</li>
<li>广播
<ul>
<li>一个主机要向网上的所有其他主机发送帧</li>
</ul>
</li>
<li>多播(multicast)
<ul>
<li>处于单播和广播之间帧仅传送给属于多播组的多个主机</li>
</ul>
</li>
</ul>
<p><strong>主机对由信道传送过来帧的过滤过程</strong></p>
<p>首先，网卡查看由信道传送过来的帧，确定是否接收该帧，若接收后就将它传往设备驱动程序。通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧。另外，多数接口均被设置为混合模式，这种模式能接收每个帧的一个复制。作为一个例子，tcpdump使用这种模式。</p>
<p>目前，大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址，用十六进制可表示为z1:00:00:00:00:00（以太网广播地址ff:ff:ff:ff:ff:ff可看作是以太网多播地址的特例）。</p>
<p>如果网卡收到一个帧，这个帧将被传送给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序将进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（IP、ARP等等）。其次，进行多播过滤来检测该主机是否属于多播地址说明的多播组。</p>
<p>设备驱动程序随后将数据帧传送给下一层，比如，当帧类型指定为IP数据报时，就传往IP层。IP根据IP地址中的源地址和目的地址进行更多的过滤检测。如果正常，就将数据报传送给下一层（如TCP或UDP）。
每次UDP收到由IP传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。如果当前没有进程使用该目的端口号，就丢弃该数据报并产生一个ICMP不可达报文（TCP根据它的端口号作相似的过滤）。如果UDP数据报存在检验和错，将被丢弃。</p>
<p>使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。拿一个使用UDP广播应用作为例子。如果网内有50个主机，但仅有20个参与该应用，每次这20个主机中的一个发送UDP广播数据时，其余30个主机不得不处理这些广播数据报。一直到UDP层，收到的UDP广播数据报才会被丢弃。这30个主机丢弃UDP广播数据报是因为这些主机没有使用这个目的端口。</p>
<p>多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧</p>
<h4 id="1551-%E5%B9%BF%E6%92%AD">1.5.5.1. 广播</h4>
<h5 id="15511-%E5%8F%97%E9%99%90%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.1. 受限的广播</h5>
<h5 id="15512-%E6%8C%87%E5%90%91%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.2. 指向网络的广播</h5>
<h5 id="15513-%E6%8C%87%E5%90%91%E5%AD%90%E7%BD%91%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.3. 指向子网的广播</h5>
<h5 id="15514-%E6%8C%87%E5%90%91%E6%89%80%E6%9C%89%E5%AD%90%E7%BD%91%E7%9A%84%E5%B9%BF%E6%92%AD">1.5.5.1.4. 指向所有子网的广播</h5>
<h4 id="1552-%E5%A4%9A%E6%92%AD">1.5.5.2. 多播</h4>
<h5 id="15521-%E5%A4%9A%E6%92%AD%E7%BB%84%E5%9C%B0%E5%9D%80">1.5.5.2.1. 多播组地址</h5>
<h5 id="15522-%E5%A4%9A%E6%92%AD%E7%BB%84%E5%9C%B0%E5%9D%80%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2">1.5.5.2.2. 多播组地址到以太网地址的转换</h5>
<h3 id="156-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp">1.5.6. 用户数据报协议UDP</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系</p>
<p>UDP数据报封装成一份IP数据报的格式
<img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/udp.png?raw=true" alt="udp封装"></p>
<p>U D P不提供可靠性：它把应用程序传给 I P层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCPS。</p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。 即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。</p>
<ul>
<li>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>
<li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</li>
<li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</li>
<li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</li>
</ul>
<h4 id="1561-udp%E5%8D%8F%E8%AE%AE">1.5.6.1. udp协议</h4>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/udp-protocol.png?raw=true" alt="udp协议"></p>
<h4 id="1562-udp%E6%A0%A1%E9%AA%8C%E5%92%8C">1.5.6.2. udp校验和</h4>
<p>UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据。UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的.</p>
<h4 id="1563-%E6%9C%80%E5%A4%A7udp%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%95%BF%E5%BA%A6">1.5.6.3. 最大UDP数据报长度</h4>
<p>理论上，IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</p>
<ul>
<li>两个限制因素
<ul>
<li>应用程序可能会受到其程序接口的限制。socketAPI提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDPsocket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。</li>
<li>来自于TCP/IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li>
</ul>
</li>
</ul>
<h4 id="1564-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.5.6.4. 应用场景</h4>
<ul>
<li>面向数据报方式</li>
<li>网络数据大多为短消息</li>
<li>拥有大量Client</li>
<li>对数据安全性无特殊要求</li>
<li>网络负担非常重，但对响应速度要求高</li>
</ul>
<h3 id="157-tcp%E5%92%8Cudp%E5%B7%AE%E5%88%AB">1.5.7. TCP和UDP差别</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>TCP和UDP是传输层的两个具有代表性的传输层协议。TCP提供可靠的通信传输。UDP常被用于广播和细节控制交给应用的通信传输，比如可靠性保证，失败重传等策略由应用实现。
IP首部字段有一个字段标明传输层使用的是UDP还是TCP或者其他协议。</p>
<ul>
<li>
<p>TCP</p>
<ul>
<li>面向连接的，可靠的流协议。流指不间断的数据结构。</li>
<li>在发送数据之前，必须建立连接</li>
<li>提供复杂的功能，比如顺序控制，重发机制，流量控制</li>
<li>应用场景是需要可靠性传输的场景</li>
</ul>
</li>
<li>
<p>UDP</p>
<ul>
<li>不具有可靠性的数据报协议</li>
<li>不需要建立连接就能发送数据</li>
<li>没有TCP复杂的辅助功能，需要应用自己实现</li>
<li>应用场景是告诉传输和实行性有较高要求的���景，比如广播，IP电话等</li>
</ul>
</li>
<li>
<p>TCP编程的服务器端一般步骤是：</p>
<ul>
<li>创建一个socket，用函数socket()；</li>
<li>设置socket属性，用函数setsockopt(); * 可选</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind();</li>
<li>开启监听，用函数listen()；</li>
<li>接收客户端上来的连接，用函数accept()；</li>
<li>收发数据，用函数send()和recv()，或者read()和write();</li>
<li>关闭网络连接；</li>
<li>关闭监听；</li>
</ul>
</li>
<li>
<p>TCP编程的客户端一般步骤是：</p>
<ul>
<li>创建一个socket，用函数socket()；</li>
<li>设置socket属性，用函数setsockopt();* 可选</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选</li>
<li>设置要连接的对方的IP地址和端口等属性；</li>
<li>连接服务器，用函数connect()；</li>
<li>收发数据，用函数send()和recv()，或者read()和write();</li>
<li>关闭网络连接；</li>
</ul>
</li>
<li>
<p>UDP编程的服务器端一般步骤是：</p>
<ul>
<li>创建一个socket，用函数socket()；</li>
<li>设置socket属性，用函数setsockopt();* 可选</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind();</li>
<li>循环接收数据，用函数recvfrom();</li>
<li>关闭网络连接；</li>
</ul>
</li>
<li>
<p>UDP编程的客户端一般步骤是：</p>
<ul>
<li>创建一个socket，用函数socket()；</li>
<li>设置socket属性，用函数setsockopt();* 可选</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选</li>
<li>设置对方的IP地址和端口等属性;</li>
<li>发送数据，用函数sendto();</li>
<li>关闭网络连接；</li>
</ul>
</li>
</ul>
<p><strong>TCP0</strong></p>
<p>结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，你只调用了一次write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。（假设数据都能到达）但是，你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 这种情况是设置非阻塞I/O模型，会把内存耗尽，因为socket是存在内核中的。</p>
<p><strong>UDP</strong></p>
<p>UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。</p>
<p><strong>为什么</strong></p>
<p>其实，这种不同是由TCP和UDP的特性决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。
而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。</p>
<ul>
<li>
<p>套接字(Socket)</p>
<ul>
<li>操作系统提供的网络编程接口</li>
</ul>
</li>
<li>
<p>HTTP或者TCP中常出现的长连接，都是基于TCP来实现，也就是创建TCP连接以后不关闭，一直保持连接状态，下次发送数据的时候就可以不用重新建立连接，毕竟建立TCP连接是很费时的事情，不再通信时再关闭连接。</p>
</li>
</ul>
<h5 id="15701-%E7%AB%AF%E5%8F%A3">1.5.7.0.1. 端口</h5>
<p>数据链路中的MAC地址: 识别同一链路中的不同计算机
IP中的IP地址:识别TCP/IP网络中互联的主机和路由器
端口号:用于识别同一台计算机中不同的应用程序</p>
<p>端口号的范围万为0-65535之间
（1）公认端口（WellKnownPorts）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。
（2）注册端口（RegisteredPorts）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。
（3）动态和/或私有端口（Dynamicand/orPrivatePorts）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始</p>
<h3 id="158-tcp">1.5.8. TCP</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>TCP通信中的四元组:源IP，源端口，目标IP，目标端口</p>
<h4 id="1581-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80">1.5.8.1. 传输控制协议基础</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="15811-arq%E5%92%8C%E9%87%8D%E4%BC%A0">1.5.8.1.1. ARQ和重传</h5>
<p><a href="#menu" style="float:right">目录</a></p>
<p>ARQ(Automatic Repeat Request)自动重传</p>
<p>数据发送过程中,会存在数据丢失的问题,解决的方法是重发数据直到接收成功.
需要判断两点:</p>
<ul>
<li>接收方是否已经收到分组数据
<ul>
<li>通过返回ack给发送方解决
<ul>
<li>存在的问题
<ul>
<li>发送方要等待ack多长时间</li>
<li>如果ACK丢失怎么办
<ul>
<li>重新发送分组数据,接收方会多次收到同一个数据包,使用唯一序列号解决</li>
</ul>
</li>
<li>分组数据收到,但是数据出错怎么办
<ul>
<li>使用CRC校验数据,出错不回复ACK</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>接收方是否收到已经接收的数据
<ul>
<li>给每一个数据包添加唯一序列号</li>
</ul>
</li>
</ul>
<p>在设计ACK机制中,如果每次发送数据都要等待上一个数据包的ACK收到才发送,将会影响吞吐量.如果不等待立即发送,接收端可能没能力即时处理.</p>
<h5 id="15812-%E5%88%86%E7%BB%84%E7%AA%97%E5%8F%A3%E5%92%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">1.5.8.1.2. 分组窗口和滑动窗口</h5>
<p><a href="#menu" style="float:right" >目录</a></p>
<p>为解决上面的问题,给每一个发送的数据分组添加一个序列号.定义一个分组窗口作为已被发送方注入但还没完全确认(还没收到ACK)的分组的集合.窗口中的分组数量称为窗口大小.当窗口中的一个分组数据包收到ACK,将会被释放,仍未被发送的数据包将会得到发送,这就叫做滑动窗口(sliding windows).</p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/tcp-windows.png?raw=true" alt="TCP滑动窗口"></p>
<p>这个窗口在发送方和接收方都存在.在发送方,记录了哪些分组可被释放,哪些分组正在等待ACK,哪些分组还没被发送.在接收方,记录了哪些分组已经被接收和处理,哪些分组是下一步需要进行处理的,哪些分组即使被接收但是由于内存限制而被丢弃.</p>
<h5 id="15813-%E5%8F%98%E9%87%8F%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">1.5.8.1.3. 变量窗口:流量控制和拥塞控制</h5>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>流量控制
<ul>
<li>为了处理接收方的速率低于发送方发送数据的数率,在接收方跟不上时,降低发送方的发送速率</li>
<li>解决方案
<ul>
<li>基于速率控制,给发送方指定发送速率,适合流应用程序,可被用于广播和组播</li>
<li>基于窗口机制
<ul>
<li>窗口大小不固定</li>
<li>接收方需要通知发送方应当使用多大的窗口(称为窗口通知),发送方使用该值调整窗口大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="15814-tcp%E5%9F%BA%E7%A1%80">1.5.8.1.4. TCP基础</h5>
<p>TCP和UDP使用相同的网络层(IPV4和IPV6).TCP提供了一种面向连接的可靠字节流服务.在发送用户数据前,必须先建立连接.                                                                                                                                                                                                           TCP会把应用程序的数据字节转换成一组IP可以携带的分组.称为分组包(packetization).这些分组包含序列号.该序列号在TCP中实际代表的是每个分组的第一个字节在整个数据流的字节偏移.而不是分组号.应用程序的数据被打散成TCP认为的最佳大小的块来发送,一般使得每个报文段按照不会被分片的单个IP层数据报的大小来划分.如果是UDP,应用程序的每次写入就产生了一个UDP数据,其大小就是写入的那么大,接收端接收的也是那么大,而TCP会对应用程序的数据进行重新拆分发送.</p>
<p>TCP会对发送的数据进行校验和计算,以确保发送过程中数据不会出错.</p>
<p>当TCP发送一组报文段时,会设置一个重传计数器,等待对方的确认接收.但不会为每个报文段设置一个不同的重传计时器,发送一个窗口的数据,只设置一个计时器,当ACK到达时再更新超时.如果有一个确认没有即时收到,这个报文段就会被重传.</p>
<h5 id="15815-tcp%E5%A4%B4%E9%83%A8%E5%92%8C%E5%B0%81%E8%A3%85">1.5.8.1.5. TCP头部和封装</h5>
<p><a href="#menu" style="float:right">目录</a></p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/tcp-in-ip.png?raw=true" alt="TCP报文在IP报文中"></p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/tcp-protocol.png?raw=true" alt="TCP报文协议"></p>
<ul>
<li>源端口号
<ul>
<li>每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接</li>
</ul>
</li>
</ul>
<h4 id="1582-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">1.5.8.2. 连接管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/tcp/tcp-connect.png?raw=true" alt="TCP连接过程"></p>
<ul>
<li>
<p>三次连接</p>
<ul>
<li>客户端发送一个SYN报文，并指明自己想要连接的端口号和它的客户端初始序列号(ISN(C))</li>
<li>服务端返回响应报文，并带上它的初始序列号(SYN(S)),ACK为客户端的序列号+1</li>
<li>确认服务器的响应报文，回复Seq和ACK如图</li>
</ul>
</li>
<li>
<p>四次断开</p>
<ul>
<li>客户端发送给FIN报文请求关闭</li>
<li>服务端响应客户端关闭请求</li>
<li>服务端发送FIN报文请求关闭</li>
<li>客户端响应服务端关闭请求</li>
</ul>
</li>
<li>
<p>SYN攻击
在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击netstat -n -p TCP | grep SYN_RECV一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.
但是不能完全防范syn攻击</p>
</li>
<li>
<p>为什么要进行三次握手</p>
<ul>
<li>假如连接时没有第三次ACK回复。当客户端第一次SYN请求时，由于网络拥堵，客户端检测超时重新发送SYN请求，第二次服务端收到并回复ACK，此时连接建立。后来又收到客户端的第一次请求，服务端以为是新的请求，返回ACK，但是客户端并没有发新的连接请求，所以会忽略服务端的ACK，但是服务端认为这个连接是存在的，其实是一个无效连接，因此会占用服务端的连接资源。
假如有三次握手，服务端收到客户端的第一次请求并返回ACK之后，即使客户端忽略了该ACK响应，但是服务端超时未收到客户端的ACK将会断开本次连接。</li>
</ul>
</li>
<li>
<p>为什么需要四次挥手</p>
<ul>
<li>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送.</li>
</ul>
</li>
</ul>
<p><strong>连接时的11种状态</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLOSED</td>
<td>初始状态，表示TCP连接是“关闭着的”或“未打开的”。</td>
</tr>
<tr>
<td>LISTEN</td>
<td>表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</td>
</tr>
<tr>
<td>SYN_RCVD</td>
<td>表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>表示TCP连接已经成功建立。</td>
</tr>
<tr>
<td>FIN_WAIT_1</td>
<td>这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</td>
</tr>
<tr>
<td>FIN_WAIT_2</td>
<td>上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</td>
</tr>
<tr>
<td>CLOSING</td>
<td>这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</td>
</tr>
<tr>
<td>CLOSE_WAIT</td>
<td>表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</td>
</tr>
</tbody>
</table>
<h4 id="1583-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">1.5.8.3. 超时重传机制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1584-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">1.5.8.4. 数据流和窗口机制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1585-%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6">1.5.8.5. 阻塞控制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1586-tcp%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6">1.5.8.6. TCP保活机制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="16-%E7%BD%91%E7%BB%9Chttp">1.6. 网络HTTP</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTP是应用层协议,无需操心网络通信的具体细节,把联网的细节都交给了通用,可靠的因特网传输协议TCP/IP.</p>
<h3 id="161-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.6.1. 基本概念</h3>
<h4 id="1611-%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%B5%81%E7%A8%8B">1.6.1.1. 访问一个网站的流程</h4>
<ul>
<li>输入网址</li>
<li>DNS域名解析服务解析域名，获取域名对应的服务器IP地址</li>
<li>浏览器将端口号(如果有的话)从URL中解析出来</li>
<li>ARP地址解析协议根据IP查找服务端的MAC地址</li>
<li>TCP 3次连接流程，客户端和服务端建立连接</li>
<li>连接建立之后，客户端发送请求</li>
<li>服务端收到请求之后，进行业务处理，根据请求返回客户端的数据。</li>
<li>客户端收到服务端响应，渲染页面</li>
<li>如果是短连接，客户端将发送关闭连接请求。也就是四次挥手。</li>
</ul>
<h4 id="1612-%E8%B5%84%E6%BA%90">1.6.1.2. 资源</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>静态资源
<ul>
<li>文本</li>
<li>HTML文件</li>
<li>图片</li>
<li>音频等</li>
</ul>
</li>
<li>动态资源
<ul>
<li>根据请求动态生成的资源</li>
</ul>
</li>
</ul>
<h5 id="16121-%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8Bmime">1.6.1.2.1. 媒体类型(MIME)</h5>
<ul>
<li>
<p>因特网上有数千种不同的数据类型，http会给每种要通过web传输的对象都打上一个名为MIME类型（MIME type）的数据格式标签</p>
</li>
<li>
<p>web服务器会为所有http对象数据附加一个MIME类型。</p>
</li>
<li>
<p>当web浏览器从服务器中取回一个对象时，会去查看相关的MIME类型，看看他们是否知道如何处理这个对象。</p>
</li>
<li>
<p>大多数浏览器都可以处理数百种常见的对象类型：显示图片文件、解析并格式化html文件等等。</p>
</li>
<li>
<p>MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一个斜杠来分割。</p>
</li>
<li>
<p>常用的媒体类型(数百个)</p>
<ul>
<li>HTML文档 text/html</li>
<li>ASCII文本文档 text/plain</li>
<li>JPEG图片 image/jpeg</li>
<li>GIF动态图片 image/gif</li>
</ul>
</li>
</ul>
<h5 id="16122-url%E5%92%8C%E8%B5%84%E6%BA%90">1.6.1.2.2. URL和资源</h5>
<p><a href="#menu" style="float:right">目录</a></p>
<p>URI是一类更通用的资源标识符，URL是它的一个子集。URI由两个子集URL和URN构成。URL通过描述资源的位置类标识资源。URN则通过名字来识别。</p>
<p>URI = Universal Resource Identifier 统一资源标志符
URL = Universal Resource Locator 统一资源定位符
URN = Universal Resource Name 统一资源名称</p>
<ul>
<li>URL
<ul>
<li>第一部分就是访问资源所用的协议，比如Http,ftp</li>
<li>第二部分就是资源所在的服务器网站，比如www.baidu.com</li>
<li>第三部分，资源在服务器中的位置，比如 /xxx/xx.pic</li>
</ul>
</li>
</ul>
<p>目前，基本所有的URI都为URL，URN还在实验阶段。</p>
<p>URL通用格式：</p>
<pre class="hljs"><code><div>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:port/path;&lt;param&gt;?&lt;query&gt;#&lt;frag&gt;
</div></code></pre>
<table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>方案</td>
<td>访问资源时的协议</td>
<td>无</td>
</tr>
<tr>
<td>用户</td>
<td>用户名</td>
<td>匿名</td>
</tr>
<tr>
<td>密码</td>
<td>访问密码</td>
<td></td>
</tr>
<tr>
<td>主机</td>
<td>访问资源所在的宿主主机的IP地址</td>
<td>无</td>
</tr>
<tr>
<td>端口</td>
<td>资源所在应用的端口</td>
<td>无</td>
</tr>
<tr>
<td>路径</td>
<td>资源在服务器上的访问路径</td>
<td>无</td>
</tr>
<tr>
<td>参数</td>
<td>参数之间使用(;)分隔</td>
<td></td>
</tr>
<tr>
<td>查询</td>
<td>查询字符串？a=1234;b=234</td>
<td></td>
</tr>
<tr>
<td>片段</td>
<td>一小片或者一部分资源的名字，不会将其发送给服务器，仅在客户端内部使用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="1613-http%E6%8A%A5%E6%96%87">1.6.1.3. HTTP报文</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="16131-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">1.6.1.3.1. 请求报文和响应报文</h5>
<ul>
<li>起始行
<ul>
<li>报文的第一行</li>
<li>在请求报文中说明要做什么</li>
<li>在响应报文中说明出现了什么情况</li>
</ul>
</li>
<li>首部字段
<ul>
<li>起始行后零个或者多个的首部字段</li>
<li>字段包括一个名字和值,中间使用&quot;:&quot;隔开,Content-type: text/html</li>
<li>首部以空行作为结尾</li>
</ul>
</li>
<li>主体
<ul>
<li>实际传输的数据,任意的二进制数据(图片,音频等)或者文本等信息</li>
</ul>
</li>
</ul>
<p><strong>请求报文格式</strong></p>
<pre class="hljs"><code><div>&lt;method&gt; &lt;request-url&gt; &lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</div></code></pre>
<p><strong>响应报文格式</strong></p>
<pre class="hljs"><code><div>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</div></code></pre>
<p><strong>例子</strong></p>
<pre class="hljs"><code><div>HTTP/2.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]

</div></code></pre>
<ul>
<li>method: 请求方法，GET，POST等</li>
<li>request-url: 请求资源在服务器内的URL</li>
<li>version: HTTP版本 ， 格式： http/1.1</li>
<li>headers：请求头和响应头,格式： Connection: close</li>
<li>status: 状态码，401/404</li>
<li>reason-phrase: 原因短语,状态码的简要说明</li>
<li>body: 实际数据部分，可以承载很多类型的数据，比如图片，音频，视频等</li>
</ul>
<h5 id="16132-%E9%A6%96%E9%83%A8">1.6.1.3.2. 首部</h5>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型：</p>
<ul>
<li>通用首部字段（General Header Fields）
请求报文和响应报文两方都会使用的首部。</li>
<li>请求首部字段（Request Header Fields）
从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>响应首部字段（Response Header Fields）
从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>
<li>实体首部字段（Entity Header Fields）
针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>
</ul>
<p>如果首部内容过长，可以分行写，但是前面必须有空格或者制表符。</p>
<p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">首部官方说明：https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a></p>
<ul>
<li>
<p>通用首部</p>
<ul>
<li>Date：报文创建时间</li>
<li>Connection：客户端和服务器连接的有关选项</li>
<li>Via：报文经过的中间节点（代理、网关）</li>
<li>Cache-control：缓存</li>
</ul>
</li>
<li>
<p>请求首部</p>
<ul>
<li>From：客户端用户的E-mail地址</li>
<li>Host：接受请求的服务器的主机名和端口</li>
<li>Referer：当前请求的URL</li>
<li>UA-Color：客户端显示器颜色信息</li>
<li>UA-OS：客户端操作系统及版本</li>
<li>Accept：告诉服务器能够发送的媒体类型</li>
<li>Accept-Charset：告诉服务器能够发送的字符集</li>
<li>Accept-Encoding：告诉服务器能够发送的编码方式</li>
<li>Accept-Language：告诉服务器能够发送的语言</li>
<li>Expect：要求服务器的行为</li>
<li>If-Match：实体标记与文档当前的标记相匹配，则获取该文档</li>
<li>If-Modified-Since：除非在某个指定日期后资源被修改过，否则限制该请求</li>
<li>If-None-Match：实体标记与文档当前的标记不匹配，则获取该文档</li>
<li>If-Unmodified-Since：除非在某个指定日期后资源没有被修改过，否则限制该请求</li>
<li>Authorization：包含客户端提供给服务端，以便进行安全认证的数据</li>
<li>Cookie：客户端需要发送的cookie</li>
<li>Cookie2：客户端支持的cookie版本</li>
</ul>
</li>
<li>
<p>响应首部</p>
<ul>
<li>Server：服务器应用软件名称及版本</li>
<li>Accept-Range：服务器可以接受的范围类型</li>
<li>Set-Cookie：设置cookie</li>
</ul>
</li>
<li>
<p>实体首部</p>
<ul>
<li>Allow：对该实体可执行的请求方法</li>
<li>Location：资源的新地址，重定向中常用到</li>
<li>Content-Language：理解主体应该使用的语言</li>
<li>Content-Length：主体的长度</li>
<li>Content-Encoding：对主体实行的编码方式</li>
<li>Content-Range：在整个资源中实体表示的字节范围</li>
<li>Content-Type：主体的类型</li>
<li>ETag：与实体相关的实体标记</li>
<li>Expires：实体不再有效，需要再次获取该实体的时间</li>
<li>Last-Modified：实体最后一次被修改的时间</li>
</ul>
</li>
</ul>
<h5 id="16133-%E6%96%B9%E6%B3%95">1.6.1.3.3. 方法</h5>
<ul>
<li>
<p>GET</p>
<ul>
<li>通常用于向服务器请求资源</li>
<li>GET请求的参数将会拼接在URL后面，因此如果是密码等参数，会存在安全性问题</li>
<li>GET请求的URL有长度限制问题，不是协议本身限制，是浏览器限制，每个浏览器都不同</li>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
</li>
<li>
<p>POST</p>
<ul>
<li>向服务器写入数据请求。</li>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求,一般也是web服务器的限制</li>
</ul>
</li>
<li>
<p>HEAD</p>
<ul>
<li>服务器响应只返回首部，不返回body数据</li>
<li>在不获取资源的情况下了解资源的类型</li>
<li>通过查看状态码，查看资源是否存在</li>
<li>查看首部，测试资源是否被修改</li>
</ul>
</li>
<li>
<p>PUT</p>
<ul>
<li>向服务器写入数据请求。</li>
</ul>
</li>
<li>
<p>TRACE</p>
<ul>
<li>用于回环测试</li>
<li>每个请求可能经过网关，代理，防火墙等，测试经过这些之后报文发生了啥变化</li>
<li>最后接收到的服务器将会返回TRACE响应，响应主体为原始请求报文</li>
</ul>
</li>
<li>
<p>OPTIONS</p>
<ul>
<li>查看资源支持的方法，通过响应头中的Allow: GET,POST</li>
</ul>
</li>
<li>
<p>DELETE</p>
<ul>
<li>请求删除资源</li>
</ul>
</li>
</ul>
<h5 id="16134-%E7%8A%B6%E6%80%81%E7%A0%81">1.6.1.3.4. 状态码</h5>
<ul>
<li>
<p>1xx 信息性状态码</p>
<ul>
<li>100/Continue: 说明收到了请求的初始部分，请客户端继续</li>
<li>101 Switching Protocols ：说明服务器正在根据客户端的指定，将协议切换成Udate首部所列的协议</li>
</ul>
</li>
<li>
<p>2xx 正常</p>
<ul>
<li>200 OK,请求正常</li>
<li>201 Created	已创建</li>
<li>202 Accepted	接受</li>
<li>203 Non-Authoritative information	非权威信息</li>
<li>204 NO Content,请求处理成功，但是返回的请求主体中没有内容。</li>
<li>205 Reset Content	重置内容</li>
<li>206 Partial Content	部分内容</li>
</ul>
</li>
<li>
<p>3xx 重定向</p>
<ul>
<li>301 Moved Permanenty ,永久重定向，该状态标识请求的资源已经分配新的URL，以后使用新的URI进行访问。Location返回新的URI</li>
<li>302 Found,临时性重定向,该状态标识请求的资源已经分配新的URL，希望用户本次使用新的URI进行访问。</li>
<li>303 See Other,URI已经更新，应使用GET方法使用新的uri获取资源。</li>
<li>304 Not Modified,客户端发送附带条件的请求时(首部：If-match,If-Modified-Sinch,If-None-Match,If-Range,If-Unmodified-Since),服务端允许请求访问资源，但未满足条件的情况，此时响应不包含任何主体。</li>
<li>305 Use Proxy	使用代理</li>
<li>307 Temporary Redirect	临时重发</li>
</ul>
</li>
<li>
<p>4xx 客户端错误</p>
<ul>
<li>400 Bad Request,错误的请求，请求报文存在语法错误。</li>
<li>401 Unauthorzied,用户认证失败</li>
<li>402 Payment Required	必需的支付</li>
<li>403 Forbidden,被拒绝访问</li>
<li>404 Not Found ,无法找到资源，可能路径\方法\请求参数有问题</li>
<li>405 Method Not Allowed	方法不被允许</li>
<li>406 Not Acceptable	不可接受的</li>
<li>407 Proxy Authentication Required	需要代理验证</li>
<li>408 Request Timeout	请求超时</li>
<li>409 Confilict	冲突</li>
<li>410 Gone	不存在</li>
<li>411 Length Required	长度必需</li>
<li>412 Precondition Failed	先决条件失败</li>
<li>413 Request Entity Too Large	请求实体太大</li>
<li>414 Request-URI Too Long	请求URI太长</li>
<li>415 Unsupported Media Type	不支持的媒体类型</li>
<li>416 Requested Range Not Satisfiable	请求范围不被满足</li>
<li>417 Expectation Failed	期望失败</li>
</ul>
</li>
<li>
<p>5xx 服务器错误</p>
<ul>
<li>500 Internal Server Error,服务器内部错误，比如抛出异常。</li>
<li>501 Not Implemented	服务端没有实现</li>
<li>502 bad gateway,网关错误</li>
<li>503 Service Unavailable,服务不可用，常见场景是网关正常，但是底下的服务不正常。</li>
<li>504 Gateway Timeout	网关超时</li>
<li>505 HTTP Version Not Supported	HTTP协议版本不支持</li>
</ul>
</li>
</ul>
<h4 id="1614-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">1.6.1.4. 连接管理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输，TCP收到数据流之后，会将数据流砍成被称作段的小���据块。并将段封装在IP分组中，通过因特网进行传输。</p>
<ol>
<li>HTTP协议与TCP/IP协议的关系</li>
</ol>
<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>
<ol start="2">
<li>如何理解HTTP协议是无状态的</li>
</ol>
<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
<h5 id="16141-%E5%AF%B9tcp%E6%80%A7%E8%83%BD%E7%9A%84%E8%80%83%E8%99%91">1.6.1.4.1. 对TCP性能的考虑</h5>
<p>HTTP是TCP的上层，主要通信实现由TCP/IP层实现，因此影响性能的主要也是这两层。
影响性能主要以下几点</p>
<ul>
<li>首次访问时的DNS域名解析，可能花费数十秒，后续访问会进行缓存。</li>
<li>TCP连接建立过程</li>
</ul>
<h5 id="16142-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5">1.6.1.4.2. 持久连接</h5>
<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>
<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<ul>
<li>HTTP1.0方式
<ul>
<li>keep-alive实现 ,keep-Alive 也是首部字段,由服务器响应决定
<ul>
<li>keep-Alive： max=5,timeout=120</li>
<li>max:服务器能接受的最大长连接数</li>
<li>timeout: 服务器希望连接在活跃状态的时间</li>
</ul>
</li>
<li>客户端请求时包含头部: Connection: keep-Alive.请求将一条连接保持在打开状态</li>
<li>服务端响应若返回头部: Connection: keep-Alive，则说明支持持久连接，否则将关闭本次连接。</li>
</ul>
</li>
<li>HTTP1.1方式
<ul>
<li>默认情况下激活，也就是默认情况下保持长连接</li>
<li>客户端若收到的响应中包含首部信息: Connection: close，将会关闭连接。</li>
<li>客户端和服务端可以随时关闭连接</li>
<li>客户端发送一个请求首部  Connection: close之后将不能在该连接上发送信息。</li>
<li>HTTP1.1的代理必须能够分别管理客户端和服务端的持久连接。</li>
</ul>
</li>
</ul>
<h6 id="161421-tcp%E8%BF%9E%E6%8E%A5">1.6.1.4.2.1. TCP连接</h6>
<p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p>
<p><img src="http://static.codeceo.com/images/2015/08/a25fb124b65178c39c04e428d1913a15.png" alt="经典的三次握手示意图"></p>
<p><img src="http://static.codeceo.com/images/2015/08/f05cb2b32b06337cbd4abe7567dcbbcd.png" alt="经典的四次握手关闭图"></p>
<p><strong>TCP短连接</strong></p>
<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>
<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>
<p><strong>TCP长连接</strong></p>
<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<ul>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ul>
<p><strong>长连接短连接操作过程</strong></p>
<ul>
<li>短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接</li>
<li>长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接</li>
</ul>
<p><strong>长连接和短连接的优点和缺点</strong></p>
<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>
<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>
<p><strong>什么时候用长连接，短连接？</strong></p>
<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>
<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<h4 id="1615-%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96">1.6.1.5. 版本变化</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>HTTP 0.9</strong></p>
<p>HTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。</p>
<p>HTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP 0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。</p>
<p>HTTP 0.9协议文档：
http://www.w3.org/Protocols/HTTP/AsImplemented.html</p>
<p><strong>HTTP 1.0</strong></p>
<p>HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP 0.9 增加了如下主要特性：</p>
<p>请求与响应支持头域
响应对象以一个响应状态行开始
响应对象不只限于超文本
开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法
支持长连接（但默认还是使用短连接），缓存机制，以及身份认证</p>
<p><strong>HTTP 1.1</strong></p>
<p>HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。HTTP 1.1是目前主流的HTTP协议版本，因此这里就多花一些笔墨介绍一下HTTP 1.1的特性。</p>
<p>HTTP 1.1引入了许多关键性能优化：keepalive连接，chunked编码传输，字节范围请求，请求流水线等</p>
<ul>
<li>
<p>Persistent Connection（keepalive连接）
允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，一遍未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为止。
在HTTP1.0中使用长连接需要添加请求头 Connection: Keep-Alive，而在HTTP 1.1 所有的连接默认都是长连接，除非特殊声明不支持（ HTTP请求报文首部加上Connection: close ）</p>
</li>
<li>
<p>chunked编码传输
该编码将实体分块传送并逐块标明长度,直到长度为0块表示传输结束, 这在实体长度未知时特别有用(比如由数据库动态产生的数据)</p>
</li>
<li>
<p>字节范围请求
HTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。该功能通过在请求消息中引入了range头域来实现，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码206（Partial Content）</p>
</li>
<li>
<p>Pipelining（请求流水线）
A client that supports persistent connections MAY &quot;pipeline&quot; its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.（摘自http://www.ietf.org/rfc/rfc2616.txt）</p>
</li>
</ul>
<p>另外，HTTP 1.1还新增了如下特性：</p>
<ul>
<li>请求消息和响应消息都应支持Host头域</li>
<li>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。因此，Host头的引入就很有必要了。</li>
<li>新增了一批Request method ,HTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT方法</li>
<li>缓存处理,HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。</li>
</ul>
<p><strong>HTTP 2.0</strong></p>
<p>HTTP 2.0是下一代HTTP协议，目前应用还非常少。主要特点有：</p>
<ul>
<li>多路复用（二进制分帧）
HTTP 2.0最大的特点: 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li>
</ul>
<p>HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p>
<ul>
<li>
<p>头部压缩
当一个客户端向相同服务器请求许多资源时，像来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息。</p>
</li>
<li>
<p>随时复位
HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</p>
</li>
<li>
<p>服务器端推流: Server Push
客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</p>
</li>
<li>
<p>优先权和依赖
每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
</li>
</ul>
<h3 id="162-https">1.6.2. HTTPS</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性  。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面</p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/computer-base/http/https-layer.png?raw=true" alt="https网络层">
TLS为传输层安全,和SSL非常类似.</p>
<p>简单的讲HTTPS是在HTTP协议的基础上，增加了保密措施的一种协议。所以其主要作用是保证通信的安全，其主要解决了如下几个问题：</p>
<ul>
<li>防止第三方冒充服务器。</li>
<li>防止第三方拦截通信报文，窃取通信中请求报文、响应报文的内容。</li>
<li>防止第三方拦截通信报文，篡改报文内容。</li>
</ul>
<p><strong>三个思考</strong></p>
<ul>
<li>为什么用了 HTTPS 就是安全的？</li>
<li>HTTPS 的底层原理如何实现？</li>
<li>用了 HTTPS 就一定安全吗？</li>
</ul>
<p><strong>目标</strong></p>
<ul>
<li>服务器认证 (客户端知道它们是在与真正的而不是伪造的服务器通话)；</li>
<li>客户端认证 (服务器知道它们是在与真正的而不是伪造的客户端通话)；</li>
<li>完整性 (客户端和服务器的数据不会被修改)；</li>
<li>加密 (客户端和服务器的对话是私密的，无需担心被窃听)；</li>
<li>效率 (一个运行的足够快的算法，以便低端的客户端和服务器使用)；</li>
<li>普适性 (基本上所有的客户端和服务器都支持这些协议)；</li>
<li>管理的可扩展性 (在任何地方的任何人都可以立即进行安全通信)；</li>
<li>适应性 (能够支持当前最知名的安全方法)；</li>
<li>在社会上的可行性 (满足社会的政治文化需要)；</li>
</ul>
<h4 id="1621-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E7%9B%AE%E6%A0%87">1.6.2.1. HTTP协议的缺点以及改进目标</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTP 协议虽然使用极为广泛, 但是却存在不小的安全缺陷, 主要是其数据的明文传送和消息完整性检测的缺乏, 而这两点恰好是网络支付, 网络交易等新兴应用中安全方面最需要关注的 。
关于 HTTP协议的明文数据传输, 攻击者最常用的攻击手法就是网络嗅探, 试图从传输过程当中分析出敏感的数据, 例如管理员对 Web 程序后台的登录过程等等, 从而获取网站管理权限, 进而渗透到整个服务器的权限。即使无法获取到后台登录信息, 攻击者也可以从网络中获取普通用户的隐秘信息, 包括手机号码, 身份证号码, 信用卡号等重要资料, 导致严重的安全事故。进行网络嗅探攻击非常简单, 对攻击者的要求很低。使用网络发布的任意一款抓包工具, 一个新手就有可能获取到大型网站的用户信息  。
另外,HTTP协议在传输客户端请求和服务端响应时, 唯一的数据完整性检验就是在报文头部包含了本次传输数据的长度, 而对内容是否被篡改不作确认。 因此攻击者可以轻易的发动中间人攻击, 修改客户端和服务端传输的数据, 甚至在传输数据中插入恶意代码, 导致客户端被引导至恶意网站被植入木马  。</p>
<ul>
<li>不安全访问的问题
<ul>
<li>客户端向服务端发起请求
<ul>
<li>此时请求报文有可能被截获，泄漏请求信息</li>
<li>请求有可能被截获，并冒充服务器，给其响应</li>
</ul>
</li>
<li>服务端向客户端发起响应
<ul>
<li>此时请求报文有可能被截获，泄漏响应信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>改进目标</strong>
HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。设计目标主要有三个。</p>
<ul>
<li>数据保密性
<ul>
<li>保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么   。</li>
</ul>
</li>
<li>数据完整性
<ul>
<li>及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收  。</li>
</ul>
</li>
<li>身份校验安全性
<ul>
<li>保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方   。</li>
</ul>
</li>
</ul>
<h4 id="1622-%E5%AF%86%E7%A0%81%E5%9F%BA%E7%A1%80">1.6.2.2. 密码基础</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>密码
<ul>
<li>对文本进行编码的算法</li>
</ul>
</li>
<li>密钥
<ul>
<li>改变密码行为的数字化参数</li>
</ul>
</li>
<li>对称密钥加密
<ul>
<li>编解码都是使用同一个密钥</li>
</ul>
</li>
<li>非对称加密
<ul>
<li>编解码使用不同的密钥</li>
</ul>
</li>
<li>数字签名
<ul>
<li>对报文进行签名,以说明是谁编写的报文,同时证明报文未被篡改过</li>
<li>是附加在报文上的特苏加密校验码</li>
<li>用来验证报文未被伪造或者篡改的校验和</li>
</ul>
</li>
<li>数字证书
<ul>
<li>由一个可信的组织验证和签发的识别信息</li>
<li>证书的只要内容
<ul>
<li>对象的名称(人,服务器,组织等)</li>
<li>证书发布者(由谁为证书担保)</li>
<li>来自证书发布者的数字签名</li>
<li>有效期</li>
<li>公开密钥</li>
<li>所用签名算法的描述性信息</li>
<li>其他扩展信息</li>
</ul>
</li>
<li>大部分信息都遵循标准格式X509 v3
<ul>
<li>字段
<ul>
<li>版本号（integer）</li>
<li>序列号（integer）</li>
<li>签名算法（object）</li>
<li>颁布者（set）</li>
<li>有效期（utc_time）</li>
<li>主体（set）</li>
<li>主体公钥（bit_string）</li>
<li>主体公钥算法（object）</li>
<li>签名值（bit_string）</li>
</ul>
</li>
<li>基于X509 v3证书的签名
<ul>
<li>web服务器证书</li>
<li>客户端电子邮件证书</li>
<li>软件代码签名证书</li>
<li>证书颁发机构证书</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>明文经过编码器编码(加密)之后变成密文,再经过解码器解码(解密)之后恢复成明文.</li>
</ul>
<p><strong>用证书对服务器进行认证</strong>
通过HTTPS建立了一个安全Web事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。服务器证书中包含很多字段，其中包括：Web站点的名称和主机名；Web站点的公开密钥；签名颁发机构的名称；来自签名颁发机构的签名</p>
<p>浏览器收到证书时会对签名颁发机构进行检査。如果这个机构是个很有权威的公共签名机构，浏览器可能已经知道其公开密钥了， 因为浏览器会预先安装很多签名颁发机构的证书。下图中说明了如何通过其数字签名来验证证书的完整性</p>
<p><img src="https://github.com/lgjlife/Java-Study/blob/master/pic/computer-base/http/sign-process.png?raw=true" alt="浏览器验证证书过程"></p>
<p>如果对签名颁发机构一无所知，浏览器就无法确定是否应该信任这个签名颁发机构，它通常会向用户显示一个对话框，看看他是否相信这个签名发布者。签名发布者可能是本地的IT部门或软件厂商</p>
<h4 id="1623-https%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%B9%E8%BF%9B">1.6.2.3. HTTPS协议的改进</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>双向的身份认证</strong></p>
<ul>
<li>客户端和服务端在传输���据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下  :
<ul>
<li>客户端发起 SSL 握手消息给服务端要求连接。</li>
<li>服务端将证书发送给客户端。</li>
<li>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</li>
<li>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则��客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</li>
</ul>
</li>
</ul>
<p><strong>数据传输的机密性</strong>
客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密   。</p>
<p><strong>防止重放攻击</strong>
SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。
可以看到，鉴于电子商务等安全上的需求，HTTPS对比HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性   。</p>
<h4 id="1624-https%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.6.2.4. HTTPS实现原理</h4>
<p>HTTPS就是在安全的传输层上发送的HTTP。HTTPS没有将未加密的HTTP报文发送给TCP，并通过世界范围内的因特网进行传输，而是在将HTTP报文发送给TCP之前，先将其发送给了一个安全层，对其进行加密</p>
<p>HTTP安全层是通过SSL及其现代替代协议TLS来实现的。我们遵循常见的用法，用术语SSL来表示SSL或者TLS</p>
<p>安全HTTP是可选的。因此，对Web服务器发起请求时，我们需要有一种方式来告知Web服务器去执行HTTP的安全协议版本，这是在URL的方案中实现的。
通常情况下，非安全HTTP的URL方案前缀为http，如下所示：http://, 在安全HTTPS协议中，URL的方案前缀为https，如下所示：https://
　　请求一个客户端(比如Web浏览器)对某Web资源执行某事务时，它会去检査 URL的方案：如果URL的方案为http，客户端就会打开一条到服务器端口80(默认情况下)的连接，并向其发送老的HTTP命令；如果URL的方案为https，客户端就会打开一条到服务器端口443(默认情况下)的连接，然后与服务器“握手”，以二进制格式与服务器交换一些SSL安全参数，附上加密的HTTP命令</p>
<p>SSL是个二进制协议，与HTTP完全不同，其流量是承载在另一个端口上的(SSL通常是由端口443承载的)。如果SSL和HTTP流量都从端口80到达，大部分Web服务器会将二进制SSL流量理解为错误的HTTP并关闭连接。将安全服务进一步整合到HTTP层中去就无需使用多个目的端口了，在实际中这样不会引发严重的问题</p>
<p>在未加密HTTP中，客户端会打开一条到Web服务器端口80的TCP连接，发送一条请求报文，接收一条响应报文，关闭连接</p>
<p>由于SSL安全层的存在，HTTPS中这个过程会略微复杂一些。在HTTPS中，客户端首先打开一条到Web服务器端口443(安全HTTP的默认端口)的连接。一且建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥。握手完成之后，SSL初始化就完成了，客户端就可以将请求报文发送给安全层了。在将这些报文发送给TCP之前，要先对其进行加密</p>
<p>HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段</p>
<ul>
<li>证书验证阶段
<ul>
<li>浏览器发起 HTTPS 请求</li>
<li>服务端返回 HTTPS 证书</li>
<li>客户端验证证书是否合法，如果不合法则提示告警</li>
</ul>
</li>
<li>数据传输阶段
<ul>
<li>当证书验证合法后，在本地生成随机数</li>
<li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li>
<li>服务端通过私钥对随机数进行解密</li>
<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li>
</ul>
</li>
</ul>
<p><strong>HTTPS双向认证过程：</strong></p>
<ul>
<li>浏览器发送一个连接请求给安全服务器。</li>
<li>服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。</li>
<li>客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。</li>
<li>接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。</li>
<li>服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。</li>
<li>客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。</li>
<li>服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。</li>
<li>浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。</li>
<li>服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。</li>
<li>服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。</li>
</ul>
<p><strong>HTTPS单向认证过程：</strong></p>
<ul>
<li>客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</li>
<li>服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</li>
<li>客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的&quot;发行者的数字签名&quot;，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开;如果合法性验证通过，将继续进行第四步。</li>
<li>用户端随机产生一个用于后面通讯的&quot;对称密码&quot;，然后用服务器的公钥(服务器的公钥从步骤②中的服务器的证书中获得)对其加密，然后将加密后的&quot;预主密码&quot;传给服务器。</li>
<li>如果服务器要求客户的身份认证(在握手过程中为可选)，用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的&quot;预主密码&quot;一起传给服务器。</li>
<li>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表(CRL)中。检验如果没有通过，通讯立刻中断;如果验证通过，服务器将用自己的私钥解开加密的&quot;预主密码 &quot;，然后执行一系列步骤来产生主通讯密码(客户端也将通过同样的方法产生相同的主通讯密码)。</li>
<li>服务器和客户端用相同的主密码即&quot;通话密码&quot;，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</li>
<li>客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</li>
<li>服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</li>
<li>SSL的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</li>
</ul>
<p><strong>双向认证：</strong></p>
<ul>
<li>浏览器发送请求给服务器，服务器首先返回证书；</li>
<li>浏览器比对服务器返回证书是否由信赖的CA中心签发，以及证书里的消息如：域名和公钥，通过后证明此服务器是安全的目标服务器，此时浏览器得到服务器的公钥；</li>
<li>浏览器发送客户端证书给服务器进行验证，通过后建立连接，此时服务器获得客户端的公钥；</li>
<li>客户端用各自的公钥、私钥发送对称秘钥，之后的通信就用对称秘钥进行加解密。（公钥和私钥为不对称秘钥，性能开销大于对称秘钥）</li>
</ul>
<p><strong>单向认证：</strong></p>
<ul>
<li>浏览器发送请求给服务器，服务器首先返回证书；</li>
<li>浏览器比对服务器返回证书是否由信赖的CA中心签发，以及证书里的消息如：域名和公钥，通过后证明此服务器是安全的目标服务器，此时浏览器得到服务器的公钥；</li>
<li>客户端用服务端公钥传送对称秘钥， 后续就用对称秘钥进行加解密再传送数据。</li>
</ul>
<p><strong>单向认证和双向认证的区别：</strong>
双向认证则是需要服务端与客户端提供身份认证，只能是服务端允许的客户能去访问，安全性相对于要高一些；
SSL单向认证只要求站点部署了ssl证书就行，任何用户都可以去访问(IP被限制除外等)，只是服务端提供了身份认证；</p>
<p><strong>加密方式</strong></p>
<p>为了达到以上的目的，最容易想到的就是加密了。而加密的方式一般情况下可以分为3中形式。</p>
<ul>
<li>对称加密算法：加密、解密用同一个密钥，速度快。</li>
<li>非对称加密算法：加密、解密用不同的密钥。公、私钥对。私钥加密的，所有公钥都可以解密，公钥加密的，只有私钥可以解密。</li>
<li>Hash算法：一种单向加密，理论上不可解密。
那么在HTTPS认证过程中都用到那种加密方式了呢？
答案是以上3种均都利用上了。</li>
</ul>
<p><strong>通信内容加密</strong></p>
<p>既然HTTP通信过程中，请求报文、响应报文均可能被窃取，这里只要把request、response加密就可以了。</p>
<p>这个加密用哪种方式呢？</p>
<ul>
<li>对称算法：需要客户端、服务端拿到相同的密钥用来加密、解密，要达到同步必然需要通信。如果说事先在客户端和服务端预安装好这个密钥，则服务端需要管理海量的密钥，显然是不现实的。</li>
<li>非对称算法：加密请求报文时，看上去并没有问题，但是在响应时，由于加密是服务器利用私钥加密的，所以所有拥有其公钥的客户端都可以解密，这样就有可能被其他有其公钥客户端窃取报文并进行解密窥探响应信息。并且由于是非对称算法，速度比较慢。</li>
<li>Hash算法：这个算法不可解密，传过去也没有什么用。
由于非对称算法，所有有公钥的客户端都可以解密响应报文，其不能够被选择，Hash算法更是没有用武之地，所以只剩下对称算法可以考虑，那么怎么解决密钥的同步问题呢？</li>
</ul>
<p>既然同步密钥也需要通信，那么还是加密呗，但是如果还用对称加密，则变成鸡生蛋、蛋生鸡的问题了。</p>
<p><strong>给对称算法的密钥加密</strong></p>
<p>HTTPS是将这个密钥用非对称的算法进行加密（实际上，只是加密了生成这个密钥的一部分原料）。</p>
<p>在服务端保存这个一个密钥。
在所有的客户端保存着服务器的密钥对应的公钥。
这个密钥由客户端生成，用公钥加密，传给服务端，这样只有服务端有密钥可以解密，即使报文被拦截，也无法解密。
这样看上去就没有什么问题了，但是实际情况中，客户端不可能知道所有服务的公钥，只要访问某个https网站的时候，才需要知道这个公钥。所以这个公钥在客户端访问服务端的时候，由服务端发给客户端就可以了。</p>
<p>这时，有人问了，这个公钥不需要加密了么？当然没有必要了，其他客户端只需访问这个网站就会得这些信息，不用拦截其他人这么麻烦，其公钥是颁发给大家的，不需要保密。</p>
<p>最后一个问题，怎么防止第三方冒充目标服务器呢？黑客给你发一个他的公钥，之后的加密全都变得没有意义。</p>
<p><strong>证书</strong></p>
<p>服务端为了向客户端证明自己，会给客户端发一个凭证，这里的这个凭证就是证书。其证书不仅用证明服务其身份的作用，其本身还必须带有防伪造的能力。</p>
<p>这里一般是服务器向第三方颁发证书的机构申请一个证明自己的证书，利用这个证书证明自己的身份，��且客户端会根据这个颁证的机构的算法去进行防伪验证，看看证书是否伪造，如果不是伪造的，则没有问题。</p>
<p>这个防伪的验证算法是什么呢？</p>
<ul>
<li>颁发证书时，会根据申请方的信息用hash类的加密算法生成摘要信息，客户端也会用这个算法生成摘要，与其进行对比。</li>
<li>并对这个摘要进行非对称加密，防止对其篡改</li>
<li>将加密后的摘要信息、生成摘要的加密算法、和证书的基本信息放在一起，作为证书颁发给申请方，</li>
<li>客户端利用颁证机构的公钥，对其加密后的摘要进行解密。
这里的客户端的公钥是怎么来的呢，由于颁证机构并不多，操作系统里对一些信用良好的机构进行了信任处理，将其公钥事先安装好了。</li>
</ul>
<p><strong>认证流程</strong></p>
<ul>
<li>服务提供者向办证机构申请证书。</li>
<li>将证书发布到web服务中</li>
<li>客户端向服务端发起申请，并发起一个随机数a。</li>
<li>服务端将证书返回客户端证明自己，并发会一个随机数b。</li>
<li>客户端根据证书的颁发机构，拿到预装的公钥，对其摘要进行解密</li>
<li>客户端根据证书中的摘要算法，进行客户端的摘要计算，并将计算结果和解密后的摘要进行比较</li>
<li>如果不一致，说明证书是伪造或被篡改过，立即停止通信</li>
<li>如果一致，则生成第三个随机数c，并用a、b、c生成对称加密算法的密钥，并用证书中的公钥（对应服务其的密钥）对c进行加密，然后将c发给服务端</li>
<li>服务端用密钥将c解密，并用a、b、c生成对称加密算法的密钥。</li>
<li>之后的通信将报文进行签名，并与报文一起进行对称加密（防止他人恶意篡改信息，以试错方式进行密钥的破解，以增加破解难度）</li>
</ul>
<p><strong>为什么数据传输是用对称加密？</strong></p>
<ul>
<li>首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li>
<li>另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li>
</ul>
<p><strong>为什么需要 CA 认证机构颁发证书？</strong></p>
<p>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。</p>
<p>首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。</p>
<p>“中间人攻击”的具体过程如下：
<a href="https://static.blog.leapmie.com/2019/11/2410496311.png">中间人攻击</a></p>
<ul>
<li>过程原理：
<ul>
<li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向正规网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
<li>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</li>
</ul>
</li>
</ul>
<p><strong>浏览器是如何确保 CA 证书的合法性？</strong></p>
<ul>
<li>证书包含什么信息？
<ul>
<li>颁发机构信息</li>
<li>公钥</li>
<li>公司信息</li>
<li>域名</li>
<li>有效期</li>
<li>指纹</li>
</ul>
</li>
<li>证书的合法性依据是什么？
<ul>
<li>首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。</li>
</ul>
</li>
<li>浏览器如何验证证书的合法性？
<ul>
<li>浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：
<ul>
<li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li>
<li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</li>
<li>判断证书是否被篡改。需要与 CA 服务器进行校验；</li>
<li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率</li>
</ul>
</li>
<li>以上任意一步都满足的情况下浏览器才认为证书是合法的。</li>
</ul>
</li>
</ul>
<p>既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？
其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。</p>
<p><strong>只有认证机构可以生成证书吗？</strong></p>
<p>如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问</p>
<p><strong>本���随机数被窃取怎么办？</strong></p>
<p>证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？</p>
<p>其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。</p>
<p><strong>用了 HTTPS 会被抓包吗？</strong></p>
<p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。</p>
<p>但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p>
<p><strong>既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</strong></p>
<p>HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。</p>
<p><strong>总结</strong></p>
<p>以下用简短的Q&amp;A形式进行全文总结：
Q: HTTPS 为什么安全？
A: 因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。</p>
<p>Q: HTTPS 的传输过程是怎样的？
A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。</p>
<p>Q: 为什么需要证书？
A: 防止”中间人“攻击，同时可以为网站提供身份证明。</p>
<p>Q: 使用 HTTPS 会被抓包吗？
A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p>
<h4 id="1625-%E4%B8%8Ehttp%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB">1.6.2.5. 与HTTP原理区别</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTPS 主要由两部分组成：HTTP + SSL / TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。</p>
<p><strong>HTTP 原理</strong></p>
<ul>
<li>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容   。</li>
<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容  。
HTTPS 原理</li>
<li>客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器   ；</li>
<li>服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数   ；</li>
<li>客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器   ；</li>
<li>客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法）   ；</li>
<li>客户端将所有握手消息的 MAC 值发送给服务器  ；</li>
<li>服务器将所有握手消息的 MAC 值发送给客户端  。</li>
</ul>
<h4 id="1626-%E4%BC%98%E7%BC%BA%E7%82%B9">1.6.2.6. 优缺点</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>优点
<ul>
<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器   ；</li>
<li>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性   。</li>
<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本   。</li>
</ul>
</li>
<li>缺点
<ul>
<li>相同网络环境下，HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。此外，HTTPS 协议还会影响缓存，增加数据开销和功耗  。</li>
<li>HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用   。</li>
<li>最关键的是，SSL 证书的信用链体系并不安全。特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行  。</li>
<li>成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。在大规模用户访问应用的场景下，服务器需要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。随着云计算技术的发展，数据中心部署的服务器使用成本在规模增加后逐步下降，相对于用户访问的安全提升，其投入成本已经下降到可接受程度。</li>
</ul>
</li>
</ul>
<h3 id="163-http%E7%BB%93%E6%9E%84">1.6.3. HTTP结构</h3>
<h4 id="1631-web%E6%9C%8D%E5%8A%A1%E5%99%A8">1.6.3.1. WEB服务器</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1632-%E4%BB%A3%E7%90%86">1.6.3.2. 代理</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1633-%E7%BC%93%E5%AD%98">1.6.3.3. 缓存</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1634-%E7%BD%91%E5%85%B3">1.6.3.4. 网关</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="164-%E8%AF%86%E5%88%AB%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8">1.6.4. 识别,认证与安全</h3>
<h4 id="1641-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%86%E5%88%AB%E4%B8%8Ecookie%E6%9C%BA%E5%88%B6">1.6.4.1. 客户端识别与Cookie机制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>HTTP是无状态的协议,也就是说WEB服务器不能判定当前发出请求的是哪个客户端发出的.</p>
<p><strong>可以使用的用户识别机制</strong></p>
<ul>
<li>承载用户身份信息的HTTP首部
<ul>
<li>From : 用户的email地址</li>
<li>User-Agent: 用户的浏览器软件</li>
<li>Referer: 用户是从这个页面上的链接跳转</li>
<li>Authorization: 用户名和密码</li>
<li>Client-IP: 客户端的IP地址</li>
<li>X-Forward-For: 客户端的IP地址</li>
<li>Cookie: 服务器产生的ID标签</li>
</ul>
</li>
<li>客户端IP地址
<ul>
<li>问题
<ul>
<li>客户端IP地址描述的是机器的IP.如果同一个用户不同的机器就无法区分</li>
<li>有些IP地址是动态分配的</li>
<li>防火墙转换IP</li>
<li>通过代理访问,IP发生改变,服务端看到的是代理的IP地址</li>
</ul>
</li>
</ul>
</li>
<li>用户登录,用认证的方式来识别用户</li>
<li>胖URL,一种在url中嵌入识别信息的技术</li>
</ul>
<h5 id="16411-cookie">1.6.4.1.1. Cookie</h5>
<ul>
<li>
<p>Cokie类型</p>
<ul>
<li>会话Cookie
<ul>
<li>存储在内存中,关闭浏览器会消失</li>
</ul>
</li>
<li>持久Cookie
<ul>
<li>存储在硬盘中,重启时数据仍然存在</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cookie是由服务器生成,添加到请求的响应中.响应头部的首部字段Set-Cookie或者Set-Cookie(扩展).</p>
</li>
</ul>
<p>请求中添加两个cookie</p>
<pre class="hljs"><code><div><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/main"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{

    response.setStatus(<span class="hljs-number">401</span>);
    response.setHeader(<span class="hljs-string">"WWW-Authentication"</span>,<span class="hljs-string">""</span>);

    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"my-key"</span>,<span class="hljs-string">"my-value"</span>);
    cookie.setMaxAge(<span class="hljs-number">100</span>);
    cookie.setComment(<span class="hljs-string">"test"</span>);
    cookie.setDomain(<span class="hljs-string">"domain"</span>);
    cookie.setHttpOnly(<span class="hljs-keyword">true</span>);
    cookie.setPath(<span class="hljs-string">"/aa"</span>);
    cookie.setSecure(<span class="hljs-keyword">true</span>);
    cookie.setVersion(<span class="hljs-number">1</span>);
    
    Cookie cookie1 = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"my-key1"</span>,<span class="hljs-string">"my-value1"</span>);
    cookie1.setMaxAge(<span class="hljs-number">100</span>);
    cookie1.setComment(<span class="hljs-string">"test"</span>);

    
    response.addCookie(cookie);
    response.addCookie(cookie1);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"main"</span>;
}
</div></code></pre>
<p>响应头部</p>
<pre class="hljs"><code><div><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">401</span> 
<span class="hljs-attr">WWW-Authentication:</span> 
<span class="hljs-attr">Set-Cookie:</span> <span class="hljs-string">my-key=my-value;</span> <span class="hljs-string">Max-Age=100;</span> <span class="hljs-string">Expires=Mon,</span> <span class="hljs-number">02</span><span class="hljs-string">-Dec-2019</span> <span class="hljs-number">18</span><span class="hljs-string">:52:57</span> <span class="hljs-string">GMT;</span> <span class="hljs-string">Domain=domain;</span> <span class="hljs-string">Path=/aa;</span> <span class="hljs-string">Secure;</span> <span class="hljs-string">HttpOnly</span>
<span class="hljs-attr">Set-Cookie:</span> <span class="hljs-string">my-key1=my-value1;</span> <span class="hljs-string">Max-Age=100;</span> <span class="hljs-string">Expires=Mon,</span> <span class="hljs-number">02</span><span class="hljs-string">-Dec-2019</span> <span class="hljs-number">19</span><span class="hljs-string">:21:44</span> <span class="hljs-string">GMT</span>

<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;charset=UTF-8</span>
<span class="hljs-attr">Content-Language:</span> <span class="hljs-string">en-US</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">135</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">02</span> <span class="hljs-string">Dec</span> <span class="hljs-number">2019</span> <span class="hljs-number">18</span><span class="hljs-string">:51:17</span> <span class="hljs-string">GMT</span>

</div></code></pre>
<p>浏览器会记住从服务器返回的Set-Cookie或Set-Cookie2首部中的cookie内容,当再次访问该站点(主域名)时,将会携带该cookie信息返回给服务器.</p>
<p>这里的cookie是不可跨域的,因此一个域名的cookie不会传到其他域名的服务器.</p>
<p><strong>cookie属性</strong></p>
<ul>
<li>name
<ul>
<li>为一个cookie的名称。</li>
</ul>
</li>
<li>value
<ul>
<li>为一个cookie的值。</li>
</ul>
</li>
<li>expires属性
<ul>
<li>指定了cookie的生存期，默认情况下cookie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户退出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个用毫秒数表示的过期日期或时间点，expires默认为设置的expires的当前时间。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。</li>
<li>如果max-age属性为正数，则表示该cookie会在max-age秒之后自动失效。浏览器会将max-age为正数的cookie持久化，即写到对应的cookie文件中。无论客户关闭了浏览器还是电脑，只要还在max-age秒之前，登录网站时该cookie仍然有效。</li>
<li>如果max-age为负数，则表示该cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该cookie即失效。max-age为负数的Cookie，为临时性cookie，不会被持久化，不会被写到cookie文件中。cookie信息保存在浏览器内存中，因此关闭浏览器该cookie就消失了。cookie默认的max-age值为-1。</li>
<li>‍如果max-age为0，则表示删除该cookie。cookie机制没有提供删除cookie的方法，因此通过设置该cookie即时失效实现删除cookie的效果。失效的Cookie会被浏览器从cookie文件或者内存中删除。</li>
<li>如果不设置expires或者max-age这个cookie默认是Session的，也就是关闭浏览器该cookie就消失了。</li>
<li>这里要说明一下：Session的cookie在ie6下，如果用户实在网页上跳转打开页面或新开窗口（包括target=&quot;_blank&quot;，鼠标右键新开窗口），都是在同一个Session内。如果用户新开浏览器程序或者说是进程再打开当前的页面就不是同一个Session。其他浏览器只要你Session存在，还是同一个Session，cookie还能共享。在前段时间的项目中ie6下吃了很大一个亏。</li>
</ul>
</li>
<li>domain属性
<ul>
<li>domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。</li>
<li>例如让位于a.sodao.com的服务器能够读取b.sodao.com设置的cookie值。如果b.sodao.com的页面创建的cookie把它的path属性设置为&quot;/&quot;，把domain属性设置成&quot;.sodao.com&quot;，那么所有位于b.sodao.com的网页和所有位于a.sodao.com的网页，以及位于sodao.com域的其他服务器上的网页都可以访问这个cookie。</li>
</ul>
</li>
<li>path属性
<ul>
<li>它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联</li>
</ul>
</li>
<li>secure属性
<ul>
<li>它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输；</li>
</ul>
</li>
<li>HttpOnly属性
<ul>
<li>HttpOnly 属性限制了 cookie 对 HTTP 请求的作用范围。特别的，该属性指示用户代理忽略那些通过&quot;非 HTTP&quot; 方式对 cookie 的访问（比如浏览器暴露给js的接口）。注意 HttpOnly 属性和 Secure 属性相互独立：一个 cookie 既可以是 HttpOnly 的也可以有 Secure 属性。</li>
</ul>
</li>
</ul>
<p><strong>其他信息</strong></p>
<ul>
<li>cookie的传输
<ul>
<li>浏览器将cookie信息以name-value对的形式存储于本地，每当请求新文档时，浏览器将发送Cookie，目的是让Server可以通过HTTP请求追踪客户。所以从WEB性能的角度来说我们要尽量的减小cookie，以达到传输性能的最大化。</li>
</ul>
</li>
<li>cookie的编码和解码
<ul>
<li>由于cookie的名/值中的值不允许包含分号，逗号和空格符，为了最大化用户代理和服务器的兼容性，任何被存储为 cookie 值的数据都应该被编码，例如用我们前端熟知的js全局函数encodeURIComponent编码和decodeURIComponent解码。</li>
</ul>
</li>
<li>cookie作为客户端存储
<ul>
<li>前面说了每当请求新文档时，浏览器将发送Cookie到服务器，导致WEB性能下降。所以不建议将cookie作为客户端存储一种实现方案，替代方案参见：JavaScript本地存储实践（html5的localStorage和ie的userData）等。</li>
</ul>
</li>
<li>同名的 cookie
<ul>
<li>同名的 cookie，不同的 domain 或不同的 path，属不同的 cookie；同名的 cookie，相同的 domain 且相同的 path，不同的 expires，属同一个 cookie。</li>
</ul>
</li>
</ul>
<p><strong>提高cookie安全性的几种方式</strong></p>
<p>cookie存储在浏览器端（用户本地），一些别有用心的人能够通过浏览器截获cookie（脚本、利用工具抓取等）。</p>
<ul>
<li>
<p>cookie不安全的表现形式</p>
<ul>
<li>cookie欺骗
<ul>
<li>但这时就会去考虑了，既然如此，为何不加密呢？加密后就算拿到cookie不是也没有用么？关键问题就在这里了，一些别有用心的人不需要知道这个cookie的具体含义，只需要将这个cookie向服务器提交（模拟身份验证），身份验证通过之后，就可以冒充被窃取cookie对应用户来访问网站，甚至获取到用户的隐私信息，对于用户的隐私造成非常严重的危害，这种方式就叫做cookie欺骗。</li>
</ul>
</li>
<li>cookie截获
<ul>
<li>cookie以纯文本的形式在浏览器和服务器之间传递，在web通信时极容易被非法用户截获和利用。非法用户截获cookie后，在cookie的有效时间内重新发放给服务器，那么这个非法用户就拥有了这个合法用户的所有权限。</li>
</ul>
</li>
<li>Flash的内部代码隐患
<ul>
<li>Flash中有一个getURL()函数，Flash利用它自动打开指定的页面。那么这个就意味着，你在观看Flash动画时，在Flash的内部可以悄无声息的打开一个极小的不易发现的包含特殊操作的页面，可以是木马，可以向远端输入当前cookie或者用户信息，这是非常危险的，由于这个是Flash内部的操作，所以网站无法禁止，要想避免，尽量打开本地防火墙以及访问正规网站。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提高cookie安全性的几种方式</p>
<ul>
<li>对保存到cookie里面的敏感信息必须加密</li>
<li>设置HttpOnly为true
<ul>
<li>该属性值的作用就是防止Cookie值被页面脚本读取。</li>
<li>但是设置HttpOnly属性，HttpOnly属性只是增加了攻击者的难度，Cookie盗窃的威胁并没有彻底消除，因为cookie还是有可能传递的过程中被监听捕获后信息泄漏。</li>
</ul>
</li>
<li>设置Secure为true
<ul>
<li>给Cookie设置该属性时，只有在https协议下访问的时候，浏览器才会发送该Cookie。</li>
<li>把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。</li>
</ul>
</li>
<li>给Cookie设置有效期
<ul>
<li>如果不设置有效期，万一用户获取到用户的Cookie后，就可以一直使用用户身份登录。</li>
<li>在设置Cookie认证的时候，需要加入两个时间，一个是“即使一直在活动，也要失效”的时间，一个是“长时间不活动的失效时间”，并在Web应用中，首先判断两个时间是否已超时，再执行其他操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1642-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6">1.6.4.2. 基本认证机制</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1643-%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81">1.6.4.3. 摘要认证</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="165-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81">1.6.5. 实体和编码</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>实体是实际传输的实体数据,首部是描述性信息,首部之后以空行结尾.</p>
<h4 id="1651-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8">1.6.5.1. 实体首部</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<table>
<thead>
<tr>
<th>首部</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Type</td>
<td>实体所承载对象的类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体长度大小</td>
</tr>
<tr>
<td>Content-Language</td>
<td>与所传送对象最相配的人类语言</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>对象数据所做的任意变换</td>
</tr>
<tr>
<td>Content-Location</td>
<td>一个备用位置,请求时可以通过它获得对象</td>
</tr>
<tr>
<td>Content-Range</td>
<td>如果这是部分实体,这个首部说明它是整体的哪个部分</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主题内容的校验和</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>所传输内容在服务器上创建和最后修改的时间</td>
</tr>
<tr>
<td>Expires</td>
<td>实体数据将要失效的时间</td>
</tr>
<tr>
<td>Allow</td>
<td>该资源所允许的请求方法</td>
</tr>
<tr>
<td>Etag</td>
<td>这份文档的特定实例唯一验证码,没有正式定义为实体首部</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指出应该如何缓存该文档,没有正式定义为实体首部</td>
</tr>
</tbody>
</table>
<p>accept相关首部</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>内容压缩编码类型</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可以接受的语言</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
</tr>
</tbody>
</table>
<h4 id="1652-http%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">1.6.5.2. HTTP的媒体类型</h4>
<p>当浏览器发起http请求时，有一个关于媒体格式的请求头字段，浏览器会根据请求链接的内容帮我们自动加上，那就是Accept字段，它的作用告诉WEB服务器自己接受的MIME类型，属于请求头，而服务器接收到该信息后，使用Content-Type 应答头通知客户端它选择的MIME类型，属于实体头，服务端不返回Content-Type字段时浏览器会按Accept字段里的属性顺序对返回的数据进行解析。Content-Type也可以用在请求头信息中，用来指定报文主体的类型。</p>
<ul>
<li>MIME类型的数据格式标签（MultIpurpose Internet Mail Extension）</li>
<li>最初用于电子邮件系统之间搬移，多用途互联网邮件扩展</li>
<li>MIME类型是一种文本标记，表示一种主要的对象类型和一种子类型，通过相应报头content-type传递</li>
</ul>
<h3 id="166-%E5%9B%BD%E9%99%85%E5%8C%96">1.6.6. 国际化</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="167-web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1">1.6.7. WEB主机托管</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="168-%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">1.6.8. 重定向和负载均衡</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h2 id="17-web-socket">1.7. WEB Socket</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<p>我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。
这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。
WebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。</p>
<h3 id="171-websocket%E4%B8%8Ehttp">1.7.1. websocket与http</h3>
<p>WebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过<strong>http协议</strong>传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。</p>
<p>WebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：</p>
<p>WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；
WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。</p>
<p>HTTP实现实时推送用到的轮询，轮询分两种：长轮询和短轮询（传统轮询）</p>
<ul>
<li>短轮询：浏览器定时向服务器发送请求，服务器收到请求不管是否有数据到达都直接响应 请求，隔特定时间，浏览器又会发送相同的请求到服务器， 获取数据响应
<ul>
<li>缺点：数据交互的实时性较低，服务端到浏览器端的数据反馈效率低</li>
</ul>
</li>
<li>长轮询：浏览器发起请求到服务器，服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断
<ul>
<li>缺点：服务器没有数据到达时，http连接会停留一段时间，造成服务器资源浪费，数据交互的实时性也很低
无论是长轮询还是短轮询，浏览���都要先发起对服务器的连接，才能接收数据，并且实时交互性很低。</li>
</ul>
</li>
</ul>
<p>然而，WebSocket的出现解决了轮询实时交互性和全双工的问题。
在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。
WebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。</p>
<p><strong>相比HTTP长连接，WebSocket有以下特点：</strong></p>
<ul>
<li>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</li>
<li>HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。</li>
</ul>
<h3 id="172-%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F">1.7.2. 数据帧格式</h3>
<p>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p>
<p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>
<ul>
<li>发送端：将��息切割成多个帧，并发送给服务端；</li>
<li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li>
</ul>
<p>本节的重点，就是讲解数据帧的格式。详细定义可参考 RFC6455-5.2节 。</p>
<p><strong>数据帧格式概览</strong>
下面给出了WebSocket数据帧的统一格式。熟悉TCP/IP协议的同学对这样的图应该不陌生。</p>
<p>从左到右，单位是比特。比如FIN、RSV1各占据1比特，opcode占据4比特。
内容包括了标识、操作代码、掩码、数据、数据长度等。</p>
<pre class="hljs"><code><div> 0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</div></code></pre>
<p><strong>数据帧格式详解</strong>
针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>
<ul>
<li>
<p><strong>FIN</strong>：1个比特。
如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
</li>
<li>
<p><strong>RSV1, RSV2, RSV3</strong>：各占1个比特。
一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>
</li>
<li>
<p><strong>Opcode</strong>: 4个比特。
操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：
%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。
%x1：表示这是一个文本帧（frame）
%x2：表示这是一个二进制帧（frame）
%x3-7：保留的操作代码，用于后续定义的非控制帧。
%x8：表示连接断开。
%x9：表示这是一个ping操作。
%xA：表示这是一个pong操作。
%xB-F：保留的操作代码，用于后续定义的控制帧。
Mask: 1个比特。</p>
</li>
</ul>
<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>
<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>
<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>
<p>掩码的算法、用途在下一小节讲解。</p>
<ul>
<li><strong>Payload length</strong>：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</li>
</ul>
<p>假设数Payload length === x，如果</p>
<p>x为0~126：数据的长度为x字节。
x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。
x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。
此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>
<ul>
<li><strong>Masking-key</strong>：0或4字节（32位）</li>
</ul>
<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>
<p>备注：载荷数据的长度，不包括mask key的长度。</p>
<ul>
<li><strong>Payload data</strong>：(x+y) 字节</li>
</ul>
<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>
<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>
<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>
<p><strong>掩码算法</strong>
掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>
<p>首先，假设：
original-octet-i：为原始数据的第i字节。
transformed-octet-i：为转换后的数据的第i字节。
j：为i mod 4的结果。
masking-key-octet-j：为mask key第j字节。
算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<pre class="hljs"><code><div>j = i MOD 4
transformed-octet-i = original-octet-i XOR masking-key-octet-j
</div></code></pre>
<h3 id="173-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92">1.7.3. 数据传递</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>
<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<p><strong>数据分片</strong>
WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。
FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。
此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<p><strong>数据分片例子</strong>
直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p>第一条消息
FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。
第二条消息
FIN=0，opcode=0x1，表示发���的是文本类型，且消息还没发送完成，还有后续的数据帧。
FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。
FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。
Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;
Server: (process complete message immediately) Hi.
Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;
Server: (listening, new message containing text started)
Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;
Server: (listening, payload concatenated to previous message)
Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;
Server: (process complete message) Happy new year to you too!</p>
<h3 id="174-%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%8C%81%E5%BF%83%E8%B7%B3">1.7.4. 连接保持+心跳</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>
<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<p>发送方-&gt;接收方：ping
接收方-&gt;发送方：pong
ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>
<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>
<p>ws.ping('', false, true);</p>
<h3 id="175-sec-websocket-keyaccept%E7%9A%84%E4%BD%9C%E7%94%A8">1.7.5. Sec-WebSocket-Key/Accept的作用</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p>
<p>作用大致归纳如下：</p>
<p>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）
确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）
用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）
可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。
Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。
强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</p>
<h3 id="176-%E6%95%B0%E6%8D%AE%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8">1.7.6. 数据掩码的作用</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>
<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p>
<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>
<p><strong>代理缓存污染攻击</strong>
下面摘自2010年关于安全的一段讲话。其中提到了代理服务器在协议实现上的缺陷可能导致的安全问题。猛击出处。</p>
<pre class="hljs"><code><div>“We show, empirically, that the current version of the WebSocket consent mechanism is vulnerable to proxy cache poisoning attacks. Even though the WebSocket handshake is based on HTTP, which should be understood by most network intermediaries, the handshake uses the esoteric “Upgrade” mechanism of HTTP [5]. In our experiment, we find that many proxies do not implement the Upgrade mechanism properly, which causes the handshake to succeed even though subsequent traffic over the socket will be misinterpreted by the proxy.”

[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C.
Jackson, &quot;Talking to Yourself for Fun and Profit&quot;, 2010,
</div></code></pre>
<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>
<ul>
<li>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）</li>
<li>受害者、受害者想要访问的资源（简称“正义资源”）</li>
<li>受害者实际想要访问的服务器（简称“正义服务器”）</li>
<li>中间代理服务器</li>
</ul>
<p>攻击步骤一：</p>
<ul>
<li>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。</li>
<li>协议升级请求 实际到达 代理服务器。</li>
<li>代理服务器 将协议升级请求转发到 邪恶服务器。</li>
<li>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。</li>
</ul>
<p>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</p>
<p>攻击步骤二：</p>
<ul>
<li>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）</li>
<li>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。</li>
<li>代理服务器 向 邪恶服务器 请求 邪恶资源。</li>
<li>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。</li>
</ul>
<p>到这里，受害者可以登场了：</p>
<ul>
<li>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。</li>
<li>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。</li>
<li>代理服务器 将 邪恶资源 返回给 受害者。</li>
<li>受害者 卒。</li>
</ul>
<p>附：前面提到的精心构造的“HTTP请求报文”。</p>
<pre class="hljs"><code><div>Client → Server:
POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: &lt;connection-key&gt;
Server → Client:
HTTP/1.1 200 OK
Sec-WebSocket-Accept: &lt;connection-key&gt;
</div></code></pre>
<p><strong>当前解决方案</strong>
最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</p>
<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>
<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>
<h3 id="177-websocket%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">1.7.7. WebSocket运行流程</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>在客户端，new WebSocket实例化一个新的WebSocket客户端对象，请求类似 ws://yourdomain:port/path 的服务端WebSocket URL，客户端WebSocket对象会自动解析并识别为WebSocket请求，并连接服务端端口，执行双方握手过程，客户端发送数据格式类似：</p>
<pre class="hljs"><code><div>GET /webfin/websocket/ HTTP/<span class="hljs-number">1.1</span>GET /webfin/websocket/ HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-attr">Host</span>: localhost
<span class="hljs-attr">Upgrade</span>: websocket
<span class="hljs-attr">Connection</span>: Upgrade
Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==
Origin: http:<span class="hljs-comment">//localhost:8080</span>
Sec-WebSocket-Version: <span class="hljs-number">13</span>
</div></code></pre>
<p>可以看到，客户端发起的WebSocket连接报文类似传统HTTP报文，Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。</p>
<p>服务端收到报文后返回的数据格式类似：</p>
<pre class="hljs"><code><div>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> Switching Protocols
<span class="hljs-attr">Upgrade</span>: websocket
<span class="hljs-attr">Connection</span>: Upgrade
Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=
</div></code></pre>
<p>Sec-WebSocket-Accept的值是服务端采用与客户端一致的密钥计算出来后返回客户端的，HTTP/1.1 101 Switching Protocols表示服务端接受WebSocket协议的客户端连接，经过这样的请求-响应处理后，两端的WebSocket连接握手成功, 后续就可以进行TCP通讯了。用户可以查阅WebSocket协议栈了解WebSocket客户端和服务端更详细的交互数据格式。</p>
<h3 id="178-springboot--websocket%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B">1.7.8. SpringBoot + WebSocket实现案例</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>服务端实现方式</li>
<li>第一种是用“@ServerEndPoint”注解来实现，实现简单；</li>
<li>第二种稍显麻烦，但是可以添加拦截器在WebSocket连接建立和断开前进行一些额外操作。</li>
</ul>
<p>不管用哪种实现方式，都需要先导入jar包（如下），其中version根据实际springboot版本选择，避免冲突</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</div></code></pre>
<h4 id="1781-%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.7.8.1. 第一种实现方法</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>（1）WebSocket 业务逻辑实现。参数传递采用路径参数的方法，通过以下方式获取参数：</p>
<ul>
<li>@ServerEndpoint(&quot;/testWebSocket/{id}/{name}&quot;)</li>
<li>public void onOpen(Session session, @PathParam(&quot;id&quot;) long id, @PathParam(&quot;name&quot;) String name)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;

<span class="hljs-keyword">import</span> javax.websocket.OnClose;
<span class="hljs-keyword">import</span> javax.websocket.OnError;
<span class="hljs-keyword">import</span> javax.websocket.OnMessage;
<span class="hljs-keyword">import</span> javax.websocket.OnOpen;
<span class="hljs-keyword">import</span> javax.websocket.Session;
<span class="hljs-keyword">import</span> javax.websocket.server.ServerEndpoint;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@ServerEndpoint</span>(<span class="hljs-string">"/testWebSocket/{id}/{name}"</span>)
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWebSocket</span> </span>{

    <span class="hljs-comment">// 用来记录当前连接数的变量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> onlineCount = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;TestWebSocket&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;TestWebSocket&gt;();

    <span class="hljs-comment">// 与某个客户端的连接会话，需要通过它来与客户端进行数据收发</span>
    <span class="hljs-keyword">private</span> Session session;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestWebSocket<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    
　　<span class="hljs-meta">@OnOpen</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session, @PathParam(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">long</span> id, @<span class="hljs-title">PathParam</span><span class="hljs-params">(<span class="hljs-string">"name"</span>)</span> String name) <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">this</span>.session = session;
        System.out.println(<span class="hljs-keyword">this</span>.session.getId());
        webSocketSet.add(<span class="hljs-keyword">this</span>);
        LOGGER.info(<span class="hljs-string">"Open a websocket. id={}, name={}"</span>, id, name);
    }
    
    <span class="hljs-meta">@OnClose</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>{
        webSocketSet.remove(<span class="hljs-keyword">this</span>);
        LOGGER.info(<span class="hljs-string">"Close a websocket. "</span>);
    }
    
    <span class="hljs-meta">@OnMessage</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message, Session session)</span> </span>{
        LOGGER.info(<span class="hljs-string">"Receive a message from client: "</span> + message);
    }
    
    <span class="hljs-meta">@OnError</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Session session, Throwable error)</span> </span>{
        LOGGER.error(<span class="hljs-string">"Error while websocket. "</span>, error);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.session.isOpen()) {
            <span class="hljs-keyword">this</span>.session.getBasicRemote().sendText(<span class="hljs-string">"Send a message from server. "</span>);
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOnlineCount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> onlineCount;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOnlineCount</span><span class="hljs-params">()</span> </span>{
        TestWebSocket.onlineCount++;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subOnlineCount</span><span class="hljs-params">()</span> </span>{
        TestWebSocket.onlineCount--;
    }
}
</div></code></pre>
<p>（2）配置ServerEndpointExporter，配置后会自动注册所有“@ServerEndpoint”注解声明的Websocket Endpoint</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> </span>{

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title">serverEndpointExporter</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerEndpointExporter();
    }
    
}
</div></code></pre>
<h4 id="1782-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1.7.8.2. 第二种实现方法</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>（1）WebSocket 业务逻辑实现。参数传递采用类似GET请求的方式传递，服务端的参数在拦截器中获取之后通过attributes传递给WebSocketHandler。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;
<span class="hljs-keyword">import</span> org.springframework.web.socket.CloseStatus;
<span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketHandler;
<span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketMessage;
<span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketSession;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWebSocketController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketHandler</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger onlineCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArrayList&lt;WebSocketSession&gt; sessions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestWebSocketController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        sessions.add(session);
        <span class="hljs-keyword">int</span> onlineNum = addOnlineCount();
        LOGGER.info(<span class="hljs-string">"Oprn a WebSocket. Current connection number: "</span> + onlineNum);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterConnectionClosed</span><span class="hljs-params">(WebSocketSession session, CloseStatus status)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        sessions.remove(session);
        <span class="hljs-keyword">int</span> onlineNum = subOnlineCount();
        LOGGER.info(<span class="hljs-string">"Close a webSocket. Current connection number: "</span> + onlineNum);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(WebSocketSession wsSession, WebSocketMessage&lt;?&gt; message)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        LOGGER.info(<span class="hljs-string">"Receive a message from client: "</span> + message.toString());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTransportError</span><span class="hljs-params">(WebSocketSession session, Throwable exception)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        LOGGER.error(<span class="hljs-string">"Exception occurs on webSocket connection. disconnecting...."</span>);
        <span class="hljs-keyword">if</span> (session.isOpen()) {
            session.close();
        }
        sessions.remove(session);
        subOnlineCount();
    }

    <span class="hljs-comment">/*
     * 是否支持消息拆分发送：如果接收的数据量比较大，最好打开(true), 否则可能会导致接收失败。
     * 如果出现WebSocket连接接收一次数据后就自动断开，应检查是否是这里的问题。
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsPartialMessages</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOnlineCount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> onlineCount.get();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addOnlineCount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> onlineCount.incrementAndGet();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subOnlineCount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> onlineCount.decrementAndGet();
    }

}
</div></code></pre>
<p>（2）HandShake 拦截器实现</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.http.server.ServerHttpRequest;
<span class="hljs-keyword">import</span> org.springframework.http.server.ServerHttpResponse;
<span class="hljs-keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;
<span class="hljs-keyword">import</span> org.springframework.web.socket.WebSocketHandler;
<span class="hljs-keyword">import</span> org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHandShakeInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSessionHandshakeInterceptor</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestHandShakeInterceptor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    
    <span class="hljs-comment">/*
     * 在WebSocket连接建立之前的操作，以鉴权为例
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">beforeHandshake</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response, 
            WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        
        LOGGER.info(<span class="hljs-string">"Handle before webSocket connected. "</span>);
        
        <span class="hljs-comment">// 获取url传递的参数，通过attributes在Interceptor处理结束后传递给WebSocketHandler</span>
        <span class="hljs-comment">// WebSocketHandler可以通过WebSocketSession的getAttributes()方法获取参数</span>
        ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request;
        String id = serverRequest.getServletRequest().getParameter(<span class="hljs-string">"id"</span>);
        String name = serverRequest.getServletRequest().getParameter(<span class="hljs-string">"name"</span>);

        <span class="hljs-keyword">if</span> (tokenValidation.validateSign()) {
            LOGGER.info(<span class="hljs-string">"Validation passed. WebSocket connecting.... "</span>);
            attributes.put(<span class="hljs-string">"id"</span>, id);
            attributes.put(<span class="hljs-string">"name"</span>, name);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.beforeHandshake(request, response, wsHandler, attributes);
        } <span class="hljs-keyword">else</span> {
            LOGGER.error(<span class="hljs-string">"Validation failed. WebSocket will not connect. "</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHandshake</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response,
            WebSocketHandler wsHandler, Exception ex)</span> </span>{
        <span class="hljs-comment">// 省略</span>
    }

}
</div></code></pre>
<p>（3）WebSocket 配置类实现（注册WebSocket实现类，绑定接口，同时将实现类和拦截器绑定）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
<span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;
<span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;
<span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

<span class="hljs-keyword">import</span> TestWebSocketController;
<span class="hljs-keyword">import</span> TestHandShakeInterceptor;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebMvc</span>
<span class="hljs-meta">@EnableWebSocket</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketConfigurer</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TestWebSocketController testWebSocketController;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> </span>{
        registry.addHandler(TestWebSocketController, <span class="hljs-string">"/testWebSocket"</span>)
                .addInterceptors(<span class="hljs-keyword">new</span> TestHandShakeInterceptor()).setAllowedOrigins(<span class="hljs-string">"*"</span>);
    }

}
</div></code></pre>
<h4 id="1783-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">1.7.8.3. 补充说明</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p>（1）在WebSocket实现过程中，尤其是通过“@ServerEndpoint”实现的时候，可能会出现注入失败的问题，即注入的Bean为null的问题。可以通过手动注入的方式来解决，需要改造实现类和SpringBoot启动类，如下：</p>
<pre class="hljs"><code><div><span class="hljs-meta">@ServerEndpoint</span>(<span class="hljs-string">"testWebsocket"</span>)
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketController</span> </span>{

    <span class="hljs-keyword">private</span> TestService testService;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;
    
    <span class="hljs-meta">@OnOpen</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> </span>{
        testService = applicationContext.getBean(TestService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    }

    <span class="hljs-meta">@OnClose</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-meta">@OnMessage</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message, Session session)</span> </span>{}

    <span class="hljs-meta">@OnError</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Session session, Throwable error)</span> </span>{}

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> </span>{
        WebSocketController.applicationContext = applicationContext;
    }
    
}
</div></code></pre>
<p>启动类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;

<span class="hljs-keyword">import</span> WebSocketController;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
<span class="hljs-comment">//        SpringApplication.run(Application.class, args);</span>
        SpringApplication springApplication = <span class="hljs-keyword">new</span> SpringApplication(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        ConfigurableApplicationContext configurableApplicationContext = springApplication.run(args);
        WebSocketController.setApplicationContext(configurableApplicationContext);  <span class="hljs-comment">// 解决WebSocket不能注入的问题</span>
    }

}
</div></code></pre>
<h4 id="1784-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0js%E6%96%B9%E5%BC%8F%E5%92%8Cjava-websocketclient%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">1.7.8.4. 客户端的实现，js方式和java WebSocketClient两种方式</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>js方式实现</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'viewport'</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"send()"</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"closeWebSocket()"</span>&gt;</span>关闭WebSocket连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">var</span> websocket = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">//判断当前浏览器是否支持WebSocket</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'WebSocket'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) {
        <span class="hljs-comment">// 不带参数的写法</span>
        websocket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://127.0.0.1:18080/testWebsocket"</span>);
        <span class="hljs-comment">// 通过路径传递参数的方法（服务端采用第一种方法"@ServerEndpoint"实现）</span>
        websocket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://127.0.0.1:18080/testWebsocket/23/Lebron"</span>);
        <span class="hljs-comment">// 通过类似GET请求方式传递参数的方法（服务端采用第二种方法"WebSocketHandler"实现）</span>
        websocket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://127.0.0.1:18080/testWebsocket?id=23&amp;name=Lebron"</span>);
    }
    <span class="hljs-keyword">else</span> {
        alert(<span class="hljs-string">'当前浏览器 Not support websocket'</span>)
    }

    <span class="hljs-comment">//连接发生错误的回调方法</span>
    websocket.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        setMessageInnerHTML(<span class="hljs-string">"WebSocket连接发生错误"</span>);
    };

    <span class="hljs-comment">//连接成功建立的回调方法</span>
    websocket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        setMessageInnerHTML(<span class="hljs-string">"WebSocket连接成功"</span>);
    }

    <span class="hljs-comment">//接收到消息的回调方法</span>
    websocket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        setMessageInnerHTML(event.data);
    }

    <span class="hljs-comment">//连接关闭的回调方法</span>
    websocket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        setMessageInnerHTML(<span class="hljs-string">"WebSocket连接关闭"</span>);
    }

    <span class="hljs-comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span>
    <span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        closeWebSocket();
    }

    <span class="hljs-comment">//将消息显示在网页上</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMessageInnerHTML</span>(<span class="hljs-params">innerHTML</span>) </span>{
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'message'</span>).innerHTML += innerHTML + <span class="hljs-string">'&lt;br/&gt;'</span>;
    }

    <span class="hljs-comment">//关闭WebSocket连接</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeWebSocket</span>(<span class="hljs-params"></span>) </span>{
        websocket.close();
    }

    <span class="hljs-comment">//发送消息</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> message = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'text'</span>).value;
        websocket.send(message);
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<p><strong>Java WebSocketClient实现</strong></p>
<p>（1）WebSocketClient 实现类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.net.URI;

<span class="hljs-keyword">import</span> org.java_websocket.client.WebSocketClient;
<span class="hljs-keyword">import</span> org.java_websocket.drafts.Draft;
<span class="hljs-keyword">import</span> org.java_websocket.handshake.ServerHandshake;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWebSocketClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSocketClient</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestWebSocketClient<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestWebSocketClient</span><span class="hljs-params">(URI serverUri)</span> </span>{
        <span class="hljs-keyword">super</span>(serverUri);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestWebSocketClient</span><span class="hljs-params">(URI serverUri, Draft protocolDraft)</span> </span>{
        <span class="hljs-keyword">super</span>(serverUri, protocolDraft);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(ServerHandshake serverHandshake)</span> </span>{
        LOGGER.info(<span class="hljs-string">"Open a WebSocket connection on client. "</span>);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg0, String arg1, <span class="hljs-keyword">boolean</span> arg2)</span> </span>{
        LOGGER.info(<span class="hljs-string">"Close a WebSocket connection on client. "</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String msg)</span> </span>{
        LOGGER.info(<span class="hljs-string">"WebSocketClient receives a message: "</span> + msg);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Exception exception)</span> </span>{
        LOGGER.error(<span class="hljs-string">"WebSocketClient exception. "</span>, exception);
    }

}
</div></code></pre>
<p>（2）WebSocketClient 发送数据</p>
<pre class="hljs"><code><div>String serverUrl = <span class="hljs-string">"ws://127.0.0.1:18080/testWebsocket"</span>
URI recognizeUri = <span class="hljs-keyword">new</span> URI(serverUrl);
client = <span class="hljs-keyword">new</span> TestWebSocketClient(recognizeUri, <span class="hljs-keyword">new</span> Draft_6455());
client.connect();
client.send(<span class="hljs-string">"This is a message from client. "</span>);
</div></code></pre>
<h2 id="18-unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B">1.8. Unix环境编程</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="181-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.8.1. 基本概念</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<ul>
<li>
<p><strong>内核</strong>
管理和分配计算机资源(CPU,内存等)的核心层软件</p>
</li>
<li>
<p><strong>内核任务</strong></p>
<ul>
<li>进程调度，Linux是抢占式多任务操作系统，内核需要协调好多个任务的执行。`</li>
<li>内存管理</li>
<li>提供文件系统</li>
<li>创建和终止进程</li>
<li>对设备的访问</li>
<li>联网</li>
<li>提供系统应用调用API接口</li>
</ul>
</li>
<li>
<p><strong>内核态和用户态</strong></p>
<ul>
<li>可将虚拟内存区域划分为用户空间和内核空间两部分</li>
<li>在用户态下只能访问用户空间，试图访问内核空间将会报硬件错误</li>
<li>在内核态下两者都可以访问到</li>
</ul>
</li>
<li>
<p><strong>文件描述符</strong></p>
<ul>
<li>Linux下一切皆是文件，每打开一个文件或者Socket,都会获得一个文件描述符(整型)来唯一标识。</li>
</ul>
</li>
<li>
<p><strong>进程</strong></p>
<ul>
<li>进程是正在执行的程序实例，执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账数据结构，以记录与进程有关的各种信息（比如，进程ID，用户ID，组ID以及终止状态）</li>
<li>进程内存布局
<ul>
<li>文本: 程序的指令</li>
<li>数据: 程序使用的静态变量</li>
<li>堆:程序可从该区域动态分配额外的内存</li>
<li>栈:随函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</li>
</ul>
</li>
<li>创建进程和执行程序
<ul>
<li>fork进行创建</li>
<li>内核通过对父进程的复制来创建子进程</li>
<li>子进程从父进程处继承数据段、栈段、以及堆段的副本，即使修改也不会互相影响，两者之间的内存空间是独立的</li>
</ul>
</li>
<li>进程IP
<ul>
<li>每一个进程都有一个唯一标识符PID，如果有父进程，还有一个父进程PPID</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="182-io%E6%A8%A1%E5%9E%8B">1.8.2. IO模型</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p><strong>概念理解</strong>
在进行网络编程时，我们常常见到同步(Sync)/异步(Async)，阻塞(Block)/非阻塞(Unblock)四种调用方式：</p>
<ul>
<li>
<p>同步</p>
<ul>
<li>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</li>
<li>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</li>
</ul>
</li>
<li>
<p>异步：</p>
<ul>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
<li>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</li>
</ul>
</li>
<li>
<p>阻塞</p>
<ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</li>
<li>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</li>
</ul>
</li>
<li>
<p>非阻塞</p>
<ul>
<li>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li>
</ul>
</li>
</ul>
<p><strong>对象的阻塞模式和阻塞函数调用</strong>
对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状 态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>
<ul>
<li>同步，就是我调用一个功能，该功能没有结束前，我死等结果。</li>
<li>异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</li>
<li>阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</li>
<li>非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者</li>
</ul>
<p>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！
阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！</p>
<p>对于举个简单c/s 模式：</p>
<p>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回这个期间客户端浏览器不能干任何事
异步：请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕
同步和异步都只针对于本机SOCKET而言的。
同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。
阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪;</p>
<p>而同步和异步是指访问数据的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写二个阶段,同步的读写必须阻塞),异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待&quot;通知&quot;)</p>
<p><strong>Linux下的五种I/O模型</strong></p>
<ul>
<li>阻塞I/O（blocking I/O）</li>
<li>非阻塞I/O （nonblocking I/O）</li>
<li>I/O复用(select 和poll) （I/O multiplexing）</li>
<li>信号驱动I/O （signal driven I/O (SIGIO)）</li>
<li>异步I/O （asynchronous I/O (the POSIX aio_functions)）
前四种都是同步，只有最后一种才是异步IO。</li>
</ul>
<p><strong>阻塞I/O模型：</strong>
<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3808372216,1260325684&amp;fm=26&amp;gp=0.jpg" alt=""></p>
<ul>
<li>简介：进程会一直阻塞，直到数据拷贝完成</li>
</ul>
<p>应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。</p>
<p>阻塞I/O模型图：在调用recv()/recvfrom（）函数时，发生在内核中等待数据和复制数据的过�����。</p>
<p>当调用recv()函数时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。当数据准备好后，将数据从系统缓冲区复制到用户空间，然后该函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数就会处于等待状态。</p>
<p>当使用socket()函数和WSASocket()函数创建套接字时，默认的套接字都是阻塞的。这意味着当调用Windows Sockets API不能立即完成时，线程处于等待状态，直到操作完成。</p>
<p>并不是所有Windows Sockets API以阻塞套接字为参数调用都会发生阻塞。例如，以阻塞模式的套接字为参数调用bind()、listen()函数时，函数会立即返回。将可能阻塞套接字的Windows Sockets API调用分为以下四种:</p>
<p>1．输入操作： recv()、recvfrom()、WSARecv()和WSARecvfrom()函数。以阻塞套接字为参数调用该函数接收数据。如果此时套接字缓冲区内没有数据可读，则调用线程在数据到来前一直睡眠。</p>
<p>2．输出操作： send()、sendto()、WSASend()和WSASendto()函数。以阻塞套接字为参数调用该函数发送数据。如果套接字缓冲区没有可用空间，线程会一直睡眠，直到有空间。</p>
<p>3．接受连接：accept()和WSAAcept()函数。以阻塞套接字为参数调用该函数，等待接受对方的连接请求。如果此时没有连接请求，线程就会进入睡眠状态。</p>
<p>4．外出连接：connect()和WSAConnect()函数。对于TCP连接，客户端以阻塞套接字为参数，调用该函数向服务器发起连接。该函数在收到服务器的应答前，不会返回。这意味着TCP连接总会等待至少到服务器的一次往返时间。</p>
<p>使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。</p>
<p>阻塞模式套接字的不足表现为，在大量建立好的套接字线程之间进行通信时比较困难。当使用“生产者-消费者”模型开发网络程序时，为每个套接字都分别分配一个读线程、一个处理数据线程和一个用于同步的事件，那么这样无疑加大系统的开销。其最大的缺点是当希望同时处理大量套接字时，将无从下手，其扩展性很差</p>
<p><strong>非阻塞IO模型</strong>
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564857412314&amp;di=0d854bfa102034baf1b415032bb0cff8&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.victorchu.info%2F%25E9%259D%259E%25E9%2598%25BB%25E5%25A1%259EIO.jpeg%3FimageView2%2F2%2Fw%2F800%2Fh%2F600%2Fq%2F75%257Cimageslim" alt=""></p>
<p>简介：非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；</p>
<p>我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。</p>
<p>把SOCKET设置为非阻塞模式，即通知系统内核：在调用Windows Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。图所示，一个非阻塞模式套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此，该函数立即返回WSAEWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中，recv()函数返回成功指示，应用程序开始处理数据。</p>
<p>当使用socket()函数和WSASocket()函数创建套接字时，默认都是阻���的。在创建套接字之后，通过调用ioctlsocket()函数，将该套接字设置为非阻塞模式。Linux下的函数是:fcntl().</p>
<p>套接字设置为非阻塞模式后，在调用Windows Sockets API函数时，调用函数会立即返回。大多数情况下，这些函数调用都会调用“失败”，并返回WSAEWOULDBLOCK错误代码。说明请求的操作在调用期间内没有时间完成。通常，应用程序需要重复调用该函数，直到获得成功返回代码。</p>
<p>需要说明的是并非所有的Windows Sockets API在非阻塞模式下调用，都会返回WSAEWOULDBLOCK错误。例如，以非阻塞模式的套接字为参数调用bind()函数时，就不会返回该错误代码。当然，在调用WSAStartup()函数时更不会返回该错误代码，因为该函数是应用程序第一调用的函数，当然不会返回这样的错误代码。</p>
<p>要将套接字设置为非阻塞模式，除了使用ioctlsocket()函数之外，还可以使用WSAAsyncselect()和WSAEventselect()函数。当调用该函数时，套接字会自动地设置为非阻塞方式。</p>
<p>由于使用非阻塞套接字在调用函数时，会经常返��WSAEWOULDBLOCK错误。所以在任何时候，都应仔细检查返回代码并作好对“失败”的准备。应用程序连续不断地调用这个函数，直到它返回成功指示为止。上面的程序清单中，在While循环体内不断地调用recv()函数，以读入1024个字节的数据。这种做法很浪费系统资源。</p>
<p>要完成这样的操作，有人使用MSG_PEEK标志调用recv()函数查看缓冲区中是否有数据可读。同样，这种方法也不好。因为该做法对系统造成的开销是很大的，并且应用程序至少要调用recv()函数两次，才能实际地读入数据。较好的做法是，使用套接字的“I/O模型”来判断非阻塞套接字是否可读可写。</p>
<p>非阻塞模式套接字与阻塞模式套接字相比，不容易使用。使用非阻塞模式套接字，需要编写更多的代码，以便在每个Windows Sockets API函数调用中，对收到的WSAEWOULDBLOCK错误进行处理。因此，非阻塞套接字便显得有些难于使用。</p>
<p>但是，非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势。这种套接字在使用上存在一定难度，但只要排除了这些困难，它在功能上还是非常强大的。通常情况下，可考虑使用套接字的“I/O模型”，它有助于应用程序通过异步方式，同时对一个或多个套接字的通信加以管理。</p>
<p><strong>IO复用模型：</strong>
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564857181158&amp;di=13d24a895a5417ce847d6768a8f6f0f3&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D770609745%2C3299491672%26fm%3D214%26gp%3D0.jpg" alt=""></p>
<p>简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；</p>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<p><strong>信号驱动IO</strong>
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564857276750&amp;di=a736eec5e67ae951a456a8882f3b968d&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F201904%2F20190420195009891716.png" alt=""></p>
<p>简介：两次调用，两次返回；</p>
<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p><strong>异步IO模型</strong>
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564857069930&amp;di=25759da9819bd9b52f14476aea277376&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190624%2Ff5b1176ce6e241f48403c7e999d91b69.jpeg" alt=""></p>
<p>简介：数据拷贝的时候进程无需阻塞。</p>
<p>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作</p>
<p>同步IO引起进程阻塞，直至IO操作完成。
异步IO不会引起进程阻塞。
IO复用是先通过select调用阻塞。</p>
<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=176532706,1323700702&amp;fm=26&amp;gp=0.jpg" alt=""></p>
<h3 id="183-selectpollepoll%E6%AF%94%E8%BE%83">1.8.3. select&amp;poll&amp;epoll比较</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1831-%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88">1.8.3.1. 整体概览</h4>
<p><strong>水平触发和边缘触发</strong></p>
<ul>
<li>水平触发通知
<ul>
<li>如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪</li>
<li>也就是说主动去(轮询)检查文件描述符状态</li>
<li>select,poll,epoll</li>
<li>可以任意时刻去检查文件描述符状态，因此不需要每次尽可能多的读取数据。</li>
</ul>
</li>
<li>边缘触发通知
<ul>
<li>如果文件描述符自上次状态检查以来有了新的I/O活动，此时需要触发通知。</li>
<li>select,信号驱动IO模型</li>
<li>I/O事件发生时才会收到通知型</li>
<li>当收到通知时，应当尽可能多的读取字节，因为只有下一次I/O来时才能收到通知。</li>
</ul>
</li>
</ul>
<h4 id="1832-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93">1.8.3.2. 对比总结</h4>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
<p><strong>select：</strong>
select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<ul>
<li>
<p>单个进程可监视的fd数量被限制，即能监听端口的大小有限。
一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
</li>
<li>
<p>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：
当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
</li>
<li>
<p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
</li>
<li>
<p>select函数</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</span>
</span></div></code></pre>
<ul>
<li>参数
<ul>
<li>readfds 用来检测输入是否就绪的文件描述符集合</li>
<li>writefds 输出</li>
<li>exceptfds 异常情况是否发生</li>
<li>timeout  超时时间结构体</li>
</ul>
</li>
<li>返回值
<ul>
<li>0 ：超时</li>
<li>-1 ：发生错误</li>
<li>大于1：就绪状态的描述符的总数，包括读写异常三个参数</li>
</ul>
</li>
</ul>
<p><strong>poll：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<ul>
<li>
<p>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p>
</li>
<li>
<p>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
</li>
<li>
<p>poll 函数</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(struct pollfd fds[],<span class="hljs-keyword">nfds_t</span> nfds,<span class="hljs-keyword">int</span> timeout)</span>

struct pollfd</span>{
    <span class="hljs-comment">//文件描述符</span>
    <span class="hljs-keyword">int</span> fd;
    <span class="hljs-comment">//请求事件位掩码</span>
    short events; 
    <span class="hljs-comment">//返回事件位源码</span>
    short revents;
}
</div></code></pre>
<ul>
<li>参数
<ul>
<li>nfds 指定fds的元素个数，nfds_t实际为无符号整形</li>
<li>fds-fd 文件描述符</li>
<li>fds-events 需要做检查的事件位掩码，调用者初始化</li>
<li>fds-revents 发生了事件的位掩码，内核设置并返回</li>
<li>timeout
<ul>
<li>-1 : 一直阻塞直到有一个文件描述符发生事件</li>
<li>0: 不阻塞，全部检查完即使没有事件也返回</li>
<li>大于0:最多阻塞时间</li>
</ul>
</li>
</ul>
</li>
<li>返回:同select</li>
</ul>
<p><strong>select poll区别</strong></p>
<ul>
<li>
<p>select 检查的文件描述符有数量上限(FD_SETZIZE),LINUX默认为1024，修改需要重新编译内核。poll没有限制</p>
</li>
<li>
<p>select的fd_set同时也是保存调用结果的地方，如果多次调用select需要每次都要进行初始化。poll是两个参数存放检查和就绪的文件描述符，从而避免每次都要进行初始化。</p>
</li>
<li>
<p>select提供的超时精度比poll高</p>
</li>
</ul>
<p><strong>select poll 问题</strong></p>
<ul>
<li>每次调用select和epoll都要向内核传入需要检查的文件描述符，检测是否处于就绪状态。当检查的文件描述符较多时，将会很耗时</li>
<li>select 和 poll调用完成以后，程序必须检查返回的数据结构中的每一个元素，以此查明哪个文件描述符处于就绪态。</li>
<li>每次调用select和epoll都要向内核传入需要检查的文件描述符，检查完成，又从内核返回应用，如果文件描述符过多，复制也很耗时。</li>
</ul>
<p><strong>epoll:</strong>
epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p>
<ul>
<li>
<p>适用场景:</p>
<ul>
<li>同时处理许多客户端的服务器;</li>
<li>需要监视大量的文件描述符，但大部分属于空闲状态，只有少数文件描述符处于就绪状态。</li>
</ul>
</li>
<li>
<p>epoll水平触发和边缘触发的区别</p>
<ul>
<li>例子
<ul>
<li>套接字上有输入到来</li>
<li>调用一次epoll_wait(),无论采用的是水平触发还是边缘触发，该调用都会告诉我们套接字已经给处于就绪态</li>
<li>再次调用epoll_wait()</li>
</ul>
</li>
<li>说明
<ul>
<li>如果是水平触发通知，第二个epoll_wait()会告诉我们套接字已经给处于就绪态</li>
<li>如果是边缘触发通知，将会被阻塞，因为没有新的输入进来</li>
</ul>
</li>
</ul>
</li>
<li>
<p>epoll边缘触发通知机制的程序基本框架</p>
<ul>
<li>让所有监视的文件描述符都成为非阻塞</li>
<li>通过epoll_wait()取得就绪状态的描述符列表</li>
<li>针对每一个处于就绪状态文件描述符，不断进行IO处理直到相关的系统调用(例如read,write,recv,send,accept)返回EAGAIN或EWOULDBLOCK错误</li>
</ul>
</li>
</ul>
<p>epoll的接口非常简单，一共就三个函数：</p>
<ol>
<li>
<p>int epoll_create(int size);
创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
</li>
<li>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：
EPOLL_CTL_ADD：注册新的fd到epfd中；
EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
EPOLL_CTL_DEL：从epfd中删除一个fd；
第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> epoll_data {
    <span class="hljs-keyword">void</span> *ptr;
    <span class="hljs-keyword">int</span> fd;
    <span class="hljs-keyword">__uint32_t</span> u32;
    <span class="hljs-keyword">__uint64_t</span> u64;
} <span class="hljs-keyword">epoll_data_t</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> {</span>
    <span class="hljs-keyword">__uint32_t</span> events; <span class="hljs-comment">/* Epoll events */</span>
    <span class="hljs-keyword">epoll_data_t</span> data; <span class="hljs-comment">/* User data variable */</span>
};

</div></code></pre>
<p>events可以是以下几个宏的集合：
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<ol start="3">
<li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ol>
<p>4、关于ET、LT两种工作模式：
可以得出这样的结论:
ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.</p>
<p>那么究竟如何来使用epoll呢？其实非常简单。
通过在包含一个头文件#include &lt;sys/epoll.h&gt; 以及几个简单的API将可以大大的提高你的网络服务器的支持人数。</p>
<p>首先通过create_epoll(int maxfds)来创建一个epoll的句柄，其中maxfds为你epoll所支持的最大句柄数。这个函数会返回一个新的epoll句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。</p>
<p>之后在你的网络主循环里面，每一帧的调用epoll_wait(int epfd, epoll_event events, int max events, int timeout)来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：
nfds = epoll_wait(kdpfd, events, maxevents, -1);
其中kdpfd为用epoll_create创建之后的句柄，events是一个epoll_event*的指针，当epoll_wait这个函数操作成功之后，epoll_events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout是 epoll_wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件范围，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则范围。一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率。</p>
<p>epoll_wait范围之后应该是一个循环，遍利所有的事件。</p>
<p>几乎所有的epoll程序都使用下面的框架：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span>( ; ; )
    {
        nfds = epoll_wait(epfd,events,<span class="hljs-number">20</span>,<span class="hljs-number">500</span>);
        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nfds;++i)
        {
            <span class="hljs-keyword">if</span>(events[i].data.fd==listenfd) <span class="hljs-comment">//有新的连接</span>
            {
                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="hljs-comment">//accept这个连接</span>
                ev.data.fd=connfd;
                ev.events=EPOLLIN|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="hljs-comment">//将新的fd添加到epoll的监听队列中</span>
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="hljs-comment">//接收到数据，读socket</span>
            {
                n = <span class="hljs-built_in">read</span>(sockfd, <span class="hljs-built_in">line</span>, MAXLINE)) &lt; <span class="hljs-number">0</span>    <span class="hljs-comment">//读</span>
                ev.data.ptr = md;     <span class="hljs-comment">//md为自定义类型，添加数据</span>
                ev.events=EPOLLOUT|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="hljs-comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span>
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="hljs-comment">//有数据待发送，写socket</span>
            {
                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="hljs-comment">//取数据</span>
                sockfd = md-&gt;fd;
                send( sockfd, md-&gt;ptr, <span class="hljs-built_in">strlen</span>((<span class="hljs-keyword">char</span>*)md-&gt;ptr), <span class="hljs-number">0</span> );        <span class="hljs-comment">//发送数据</span>
                ev.data.fd=sockfd;
                ev.events=EPOLLIN|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="hljs-comment">//修改标识符，等待下一个循环时接收数据</span>
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">//其他的处理</span>
            }
        }
    }

</div></code></pre>
<p>完整的服务端例子</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPEN_MAX 100</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTENQ 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SERV_PORT 5000</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFTIM 1000</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock)</span>
</span>{
    <span class="hljs-keyword">int</span> opts;
    opts=fcntl(sock,F_GETFL);
    <span class="hljs-keyword">if</span>(opts&lt;<span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"fcntl(sock,GETFL)"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    opts = opts|O_NONBLOCK;
    <span class="hljs-keyword">if</span>(fcntl(sock,F_SETFL,opts)&lt;<span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"fcntl(sock,SETFL,opts)"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span>
</span>{
    <span class="hljs-keyword">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;
    <span class="hljs-keyword">ssize_t</span> n;
    <span class="hljs-keyword">char</span> line[MAXLINE];
    <span class="hljs-keyword">socklen_t</span> clilen;


    <span class="hljs-keyword">if</span> ( <span class="hljs-number">2</span> == argc )
    {
        <span class="hljs-keyword">if</span>( (portnumber = atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span> )
        {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Usage:%s portnumber/a/n"</span>,argv[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Usage:%s portnumber/a/n"</span>,argv[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }



    <span class="hljs-comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件</span>

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>,<span class="hljs-title">events</span>[20];</span>
    <span class="hljs-comment">//生成用于处理accept的epoll专用的文件描述符</span>

    epfd=epoll_create(<span class="hljs-number">256</span>);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span>
    listenfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//把socket设置为非阻塞方式</span>

    <span class="hljs-comment">//setnonblocking(listenfd);</span>

    <span class="hljs-comment">//设置与要处理的事件相关的文件描述符</span>

    ev.data.fd=listenfd;
    <span class="hljs-comment">//设置要处理的事件类型</span>

    ev.events=EPOLLIN|EPOLLET;
    <span class="hljs-comment">//ev.events=EPOLLIN;</span>

    <span class="hljs-comment">//注册epoll事件</span>

    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);
    bzero(&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));
    serveraddr.sin_family = AF_INET;
    <span class="hljs-keyword">char</span> *local_addr=<span class="hljs-string">"127.0.0.1"</span>;
    inet_aton(local_addr,&amp;(serveraddr.sin_addr));<span class="hljs-comment">//htons(portnumber);</span>

    serveraddr.sin_port=htons(portnumber);
    bind(listenfd,(sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));
    listen(listenfd, LISTENQ);
    maxi = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> ( ; ; ) {
        <span class="hljs-comment">//等待epoll事件的发生</span>

        nfds=epoll_wait(epfd,events,<span class="hljs-number">20</span>,<span class="hljs-number">500</span>);
        <span class="hljs-comment">//处理所发生的所有事件</span>

        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nfds;++i)
        {
            <span class="hljs-keyword">if</span>(events[i].data.fd==listenfd)<span class="hljs-comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span>

            {
                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen);
                <span class="hljs-keyword">if</span>(connfd&lt;<span class="hljs-number">0</span>){
                    perror(<span class="hljs-string">"connfd&lt;0"</span>);
                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
                }
                <span class="hljs-comment">//setnonblocking(connfd);</span>

                <span class="hljs-keyword">char</span> *str = inet_ntoa(clientaddr.sin_addr);
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"accapt a connection from "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;
                <span class="hljs-comment">//设置用于读操作的文件描述符</span>

                ev.data.fd=connfd;
                <span class="hljs-comment">//设置用于注测的读操作事件</span>

                ev.events=EPOLLIN|EPOLLET;
                <span class="hljs-comment">//ev.events=EPOLLIN;</span>

                <span class="hljs-comment">//注册ev</span>

                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events&amp;EPOLLIN)<span class="hljs-comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span>

            {
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"EPOLLIN"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
                <span class="hljs-keyword">if</span> ( (sockfd = events[i].data.fd) &lt; <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">if</span> ( (n = read(sockfd, line, MAXLINE)) &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (errno == ECONNRESET) {
                        close(sockfd);
                        events[i].data.fd = <span class="hljs-number">-1</span>;
                    } <span class="hljs-keyword">else</span>
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"readline error"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
                    close(sockfd);
                    events[i].data.fd = <span class="hljs-number">-1</span>;
                }
                line[n] = <span class="hljs-string">'/0'</span>;
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"read "</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;
                <span class="hljs-comment">//设置用于写操作的文���描述符</span>

                ev.data.fd=sockfd;
                <span class="hljs-comment">//设置用于注测的写操作事件</span>

                ev.events=EPOLLOUT|EPOLLET;
                <span class="hljs-comment">//修改sockfd上要处理的事件为EPOLLOUT</span>

                <span class="hljs-comment">//epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span>

            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="hljs-comment">// 如果有数据发送</span>

            {
                sockfd = events[i].data.fd;
                write(sockfd, line, n);
                <span class="hljs-comment">//设置用于读操作的文件描述符</span>

                ev.data.fd=sockfd;
                <span class="hljs-comment">//设置用于注测的读操作事件</span>

                ev.events=EPOLLIN|EPOLLET;
                <span class="hljs-comment">//修改sockfd上要处理的事件为EPOLIN</span>

                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p><strong>select、poll、epoll 区别总结：</strong></p>
<ul>
<li>支持一个进程所能打开的最大连接数</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td>
</tr>
<tr>
<td>poll</td>
<td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td>
</tr>
</tbody>
</table>
<ul>
<li>FD剧增后带来的IO效率问题</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody>
</table>
<ul>
<li>消息传递方式</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong>
综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<ul>
<li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</li>
</ul>
<h2 id="19-shell">1.9. Shell</h2>
<p><a href="#menu" style="float:right">目录</a></p>
<h3 id="191-%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85">1.9.1. 文件安装</h3>
<h4 id="1911-deb%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">1.9.1.1. deb文件操作</h4>
<p>dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如Ubuntu、Knoppix 等。
以下是一些 Dpkg 的普通用法：</p>
<pre class="hljs"><code><div>1、dpkg -i &lt;package.deb&gt;
安装一个 Debian 软件包，如你手动下载的文件。
2、dpkg -c &lt;package.deb&gt;
列出 &lt;package.deb&gt; 的内容。
3、dpkg -I &lt;package.deb&gt;
从 &lt;package.deb&gt; 中提取包裹信息。
4、dpkg -r &lt;package&gt;
移除一个已安装的包裹。
5、dpkg -P &lt;package&gt;
完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。
6、dpkg -L &lt;package&gt;
列出 &lt;package&gt; 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb 文件的内容。
7、dpkg -s &lt;package&gt;
显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。
8、dpkg-reconfigure &lt;package&gt;
重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)。
</div></code></pre>
<h3 id="192-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.9.2. 常用命令</h3>
<h4 id="1921-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">1.9.2.1. 系统信息</h4>
<ul>
<li>man command 查看命令的信息</li>
<li>date 显示当前日期和时间</li>
<li>cal 显示当月的日历</li>
<li>uptime 系统从开机到现在的时间</li>
<li>w 显示当前登录的用户</li>
<li>whoami 查看当前的用户名</li>
<li>finger user 显示user相关信息</li>
<li>uname -a 显示内核信息</li>
<li>cat /proc/cpuinfo 查看cpu信息</li>
<li>cat /proc/meminfo 查看内存信息</li>
<li>df 显示磁盘占用信息</li>
<li>du 显示目录空间占用情况</li>
<li>free 显示内存以及交换区占用情况</li>
<li>lsof　列出系统打开的文件句柄</li>
<li>scp 是 Linux 系统中功能强大的文件传输命令，可以实现从远程到本地，以及从本地到远程的双向文件传输
<ul>
<li>scp robert@19.168.1.1:/home/robert/test.txt .</li>
<li>scp ./test.txt robert@19.168.1.1:/home/robert</li>
</ul>
</li>
<li>grep : 文本内容查找命令，可以利用它打印匹配的上下几行</li>
<li>awk 是 Linux 系统下强大的文本分析工具 ，相对于 grep 的查找、 sed 的编辑， awk 在对数据分析井生成报告时，显得尤为强大。它把文件逐行读入，以空格为默认分隔符将每行切片，也可以以任何字符为分隔符，把切开的部分进行各种分析和处理，在分析和处理的过程中支持脚本式的编程。</li>
<li>sed：文本编辑和替换。</li>
<li>tr ： 字符替换。</li>
<li>cut ： 选取命令，分析一段数据并取出我们想要的部分。</li>
<li>wc ： 统计字数和行数等。</li>
<li>sort：排序。</li>
<li>uniq ： 去重或者分组统计 。</li>
<li>zip ： 压缩成 zip 格式的压缩包或者解压。</li>
<li>tar：创建或者解压 tar 格式的包。</li>
</ul>
<p><strong>ulimit命令</strong>
Linux ulimit命令用于控制shell程序的资源。</p>
<pre class="hljs"><code><div>$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 39575
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 39575
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited

</div></code></pre>
<pre class="hljs"><code><div>-a 　显示目前资源限制的设定。
-c &lt;core文件上限&gt; 　设定core文件的最大值，单位为区块。
-d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。
-f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。
-H 　设定资源的硬性限制，也就是管理员所设下的限制。
-m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。
-n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。
-p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。
-s &lt;堆叠大小&gt; 　指定堆叠的上限，单位为KB。
-S 　设定资源的弹性限制。
-t &lt;CPU时间&gt; 　指定CPU使用时间的上限，单位为秒。
-u &lt;程序数目&gt; 　用户最多可开启的程序数目。
-v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。
</div></code></pre>
<pre class="hljs"><code><div>ulimit -u 500 //设置单一用户程序上限
</div></code></pre>
<h4 id="1922-proc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.2.2. /proc 文件系统</h4>
<p>Linux 系统 内 核提供了通过／proc 文件系统查看运行时系统内核内的数据结构的能力，也可
以改变系统内核的参数设置。</p>
<p>显示 CPU 信息 ：cat /proc/cpuinfo</p>
<p>显示 内存信息 ：cat /proc/meminfo</p>
<p>显示详细的内存映射信息 ：cat /proc/zoneinfo</p>
<p>显示磁盘映射信息：cat /proc/mounts</p>
<p>查看系统的平均负载 ：cat /proc/loadavg</p>
<h4 id="1923-ssh">1.9.2.3. SSH</h4>
<ul>
<li>ssh user@host 以用户user连接到host</li>
<li>ssh -p password user@host 以用户user连接到host</li>
</ul>
<h4 id="1924-%E7%BD%91%E7%BB%9C">1.9.2.4. 网络</h4>
<ul>
<li>ping host 查看网络状况</li>
<li>wget file-address 下载文件</li>
<li>wget -c file-address 断点续传</li>
</ul>
<h4 id="1925-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1.9.2.5. 进程管理</h4>
<ul>
<li>
<p>ps 显示当前的活动进程</p>
<ul>
<li>-A 显示所有进程</li>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下所有进程</li>
<li>c 显示进程真实名称</li>
<li>e 显示环境变量</li>
<li>f 显示进程间的关系</li>
<li>r 显示当前终端运行的进程</li>
<li>-aux 显示所有包含其它使用的进程</li>
<li>ps -aux|grep nginx</li>
</ul>
</li>
<li>
<p>top 显示正在运行的进程的信息</p>
</li>
<li>
<p>kill pid</p>
</li>
<li>
<p>killall *.xx 杀掉.xx结尾的文件</p>
</li>
<li>
<p>bg 列出已经停止或后台的作业</p>
</li>
<li>
<p>fg 将最近的作业带到前台</p>
</li>
<li>
<p>fg n 将作业n带到前台</p>
</li>
</ul>
<h4 id="1926-%E5%BF%AB%E6%8D%B7%E9%94%AE">1.9.2.6. 快捷键</h4>
<ul>
<li>Ctrl+C 停止当前命令</li>
<li>Ctrl+Z 停止当前命令,使用fg恢复</li>
<li>Ctrl+D 注销当前会话</li>
<li>Ctrl+W 删除当前行中的字</li>
<li>Ctrl+U 删除整行</li>
<li>!! 重复上次的命令</li>
<li>exit 注销当前的会话</li>
</ul>
<h4 id="1927-%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8">1.9.2.7. 查看端口占用</h4>
<ul>
<li>lsof -i:端口号</li>
<li>netstat -tunlp|grep 端口号
<ul>
<li>用于显示tcp，udp的端口和进程等相关情况，如下图</li>
<li>-t  仅显示和tcp相关的</li>
<li>-u 仅显示和udp相关的</li>
<li>-n 不限时别名，能显示数字的全部转换为��字</li>
<li>-l   仅显示出于Listen(监听)状态的</li>
<li>-p  显示建立这些连接的程序名</li>
</ul>
</li>
</ul>
<h4 id="1928-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3">1.9.2.8. 文件相关</h4>
<ul>
<li>
<p>路径</p>
<ul>
<li>/   根路径</li>
<li>.   当前目录</li>
<li>.. 上一级目录</li>
<li>~/  当前用户目录</li>
<li>cd  path  进入路径</li>
<li>cd -  返回上一级目录</li>
<li>pwd 显示当前绝对路径</li>
</ul>
</li>
<li>
<p>文件列表</p>
<ul>
<li>ls 只列出当前目录文件名称</li>
<li>ls -l 包含文件权限等信息</li>
<li>ls -a 包含&quot;.&quot;开头的隐藏文件</li>
<li>ls -F 区分文件和目录</li>
<li>ls -R 递归显示目录</li>
<li>ls -l  aa 只显示带aa的列表，“?”单个字符，&quot;*&quot;多个字符</li>
</ul>
</li>
<li>
<p>文件压缩</p>
<ul>
<li>tar cf file.tar file... 压缩文件</li>
<li>tar xf file.tar 解压缩</li>
<li>tar czf file.tar.gz file... 使用gzip压缩</li>
<li>tar xzf file.tar.gz 解压缩tar.gz文件</li>
<li>tar cjf file.tar.bz2</li>
<li>tar xjf file.tar.bz2</li>
<li>gzip filename 压缩 filename为filename.gz</li>
<li>gzip -d file.gz</li>
</ul>
</li>
<li>
<p>wc [option] file..</p>
<ul>
<li>-c 统计字节数</li>
<li>-l 统计行数</li>
<li>-m 统计字符数</li>
<li>-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</li>
</ul>
</li>
<li>
<p>查找文件位置</p>
<ul>
<li>which command    查看可执行文件的位置。</li>
<li>whereis file 查看文件的位置。</li>
<li>locate  配合数据库查看文件位置。</li>
<li>find pathname -options [-print -exec -ok ...]   实际搜寻硬盘查询文件名称。</li>
</ul>
</li>
<li>
<p>处理文件</p>
<ul>
<li>touch 创建文件</li>
<li>mkdir 创建目录</li>
<li>cp source  dest 复制文件，加  -r 用于复制目录</li>
<li>rm 删除，-r 删除目录 -f 强制删除文件</li>
<li>mv source dest 重命名/复制文件</li>
</ul>
</li>
<li>
<p>查看文件</p>
<ul>
<li>file xxx 查看文件类型</li>
<li>cat 打印文件数据，-n 加上行号， -b 只给有文本的加上行号</li>
</ul>
</li>
<li>
<p>文件权限</p>
<ul>
<li>文件权限包括用户(U)-组(G)-其他用户(O),包括读(4-r)写(2-w)执行(1-x)权限。</li>
<li>chmod u+x file 用户添加执行权限</li>
<li>chmod u-x file 用户去除执行权限</li>
<li>chmod 111 file 所有的都为执行权限</li>
<li>chmod 721 file 用户有读写执行，组用户有写，其他用户有执行权限</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>-rw-rw-r-- 1 lgj lgj  1215779 Jun 28 18:08  1.mp4
</div></code></pre>
<ul>
<li>文件链接：给文件创建虚拟副本
<ul>
<li>符号链接:仅保存引用，文件内容和原文件不一样，和源文件同步更新,仅可读，不可修改，即使修改文件权限。</li>
<li>硬链接: 保存引用和文件信息，和源文件同步更新，可以修改。</li>
<li>使用cp 复制链接文件时，复制的文件仍然保留和源文件之间的链接关系，一般不这么做。</li>
<li>ln source dest ,加-s 时创建的是软连接。
*查看文件</li>
<li>more 只显示一页，按页翻页。空格键翻页。</li>
<li>less 按行翻行，方向键，可向前和向后翻。</li>
<li>tail -n 2 file 实时查看文件后2行数据，动态更新。</li>
<li>head -5 file 查看看文件前5行数据</li>
</ul>
</li>
</ul>
<h4 id="1929-%E7%9B%91%E6%B5%8B%E7%A8%8B%E5%BA%8F">1.9.2.9. 监测程序</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19291-%E6%8E%A2%E6%9F%A5%E8%BF%9B%E7%A8%8B">1.9.2.9.1. 探查进程</h5>
<ul>
<li>ps 命令
<ul>
<li>-A 显示所有进程</li>
<li>-N 显示与指定参数不符的所有进程</li>
<li>-a 显示除控制进程（ session leader① ）和无终端进程外的所有进程</li>
<li>-d 显示除控制进程外的所有进程</li>
<li>-e 显示所有进程</li>
<li>-C cmdlist 显示包含在cmdlist列表中的进程</li>
<li>-G grplist 显示组ID在grplist列表中的进程</li>
<li>-U userlist 显示属主的用户ID在userlist列表中的进程</li>
<li>-g grplist 显示会话或组ID在grplist列表中的进程②</li>
<li>-p pidlist 显示PID在pidlist列表中的进程</li>
<li>-s sesslist 显示会话ID在sesslist列表中的进程</li>
<li>-t ttylist 显示终端ID在ttylist列表中的进程</li>
<li>-u userlist 显示有效用户ID在userlist列表中的进程</li>
<li>-F 显示更多额外输出（相对-f参数而言）</li>
<li>-O format 显示默认的输出列以及format列表指定的特定列</li>
<li>-M 显示进程的安全信息</li>
<li>-c 显示进程的额外调度器信息</li>
<li>-f 显示完整格式的输出</li>
<li>-j 显示任务信息</li>
<li>-l 显示长列表</li>
<li>-o format 仅显示由format指定的列</li>
<li>-y 不要显示进程标记（ process flag，表明进程状态的标记）</li>
<li>-Z 显示安全标签（ security context） ① 信息</li>
<li>-H 用层级格式来显示进程（树状，用来显示父进程）</li>
<li>-n namelist 定义了WCHAN列显示的值</li>
<li>-w 采用宽输出模式，不限宽度显示</li>
<li>-L 显示进程中的线程</li>
<li>-V 显示ps命令的版本号</li>
</ul>
</li>
</ul>
<p>常用的参数是-ef,显示的信息为:</p>
<ul>
<li>UID：启动这些进程的用户。</li>
<li>PID：进程的进程ID。</li>
<li>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。</li>
<li>C：进程生命周期中的CPU利用率。</li>
<li>STIME：进程启动时的系统时间。</li>
<li>TTY：进程启动时的终端设备。</li>
<li>TIME：运行进程需要的累计CPU时间。</li>
<li>CMD：启动的程序名称。</li>
</ul>
<pre class="hljs"><code><div>UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Dec04 ?        00:00:24 /sbin/init splash
root         2     0  0 Dec04 ?        00:00:00 [kthreadd]

</div></code></pre>
<p>ps -l参数</p>
<ul>
<li>F：内核分配给进程的系统标记。</li>
<li>S：进程的状态（ O代表正在运行； S代表在休眠； R代表可运行，正等待运行； Z代表僵化，进程已结束但父进程已不存在； T代表停止）。</li>
<li>PRI：进程的优先级（越大的数字代表越低的优先级）。</li>
<li>NI：谦让度值用来参与决定优先级。,越大优先级越低,默认为0</li>
<li>ADDR：进程的内存地址。</li>
<li>SZ：假如进程被换出，所需交换空间的大致大小。</li>
<li>WCHAN：进程休眠的内核函数的地址。</li>
</ul>
<pre class="hljs"><code><div>F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 10646  5959  0  80   0 -  5429 wait   pts/2    00:00:00 bash
4 R  1000 20277 10646  0  80   0 -  6487 -      pts/2    00:00:00 ps

</div></code></pre>
<h5 id="19292-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B%E8%BF%9B%E7%A8%8B">1.9.2.9.2. 实时监测进程</h5>
<p>ps命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示某个特定时间点的信息。如果想观察那些频繁换进换出的内存的进程趋势，用ps命令就不方便了。top命令跟ps命令相似，能够显示进程信息，但它是实时显示的。</p>
<pre class="hljs"><code><div>top - 17:31:35 up 19:11,  1 user,  load average: 1.70, 1.04, 0.77
Tasks: 267 total,   1 running, 217 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4.9 us,  1.1 sy,  0.0 ni, 94.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 10174524 total,   527256 free,  5486668 used,  4160600 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  3808940 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 1842 lgj       20   0  642764 159804 113284 S   5.3  1.6  12:20.79 Xorg 
</div></code></pre>
<ul>
<li>top信息
<ul>
<li>PID：进程的ID。</li>
<li>USER：进程属主的名字。</li>
<li>PR：进程的优先级。</li>
<li>NI：进程的谦让度值。</li>
<li>VIRT：进程占用的虚拟内存总量。</li>
<li>RES：进程占用的物理内存总量。</li>
<li>SHR：进程和其他进程共享的内存总量。</li>
<li>S：进程的状态（ D代表可中断的休眠状态， R代表在运行状态， S代表休眠状态， T代表跟踪状态或停止状态， Z代表僵化状态）。</li>
<li>%CPU：进程使用的CPU时间比例。</li>
<li>%MEM：进程使用的内存占可用内存的比例。</li>
<li>TIME+：自进程启动到目前为止的CPU时间总量。</li>
<li>COMMAND：进程所对应的命令行名称，也就是启动的程序名。</li>
</ul>
</li>
</ul>
<h5 id="19293-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B">1.9.2.9.3. 结束进程</h5>
<p>在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准Unix进程信号。</p>
<table>
<thead>
<tr>
<th>信 号</th>
<th>名 称</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂起</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>结束运行</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>无条件终止</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>尽可能终止</td>
</tr>
<tr>
<td>17</td>
<td>STOP</td>
<td>无条件停止运行，但不终止</td>
</tr>
<tr>
<td>18</td>
<td>TSTP</td>
<td>停止或暂停，但继续在后台运行</td>
</tr>
<tr>
<td>19</td>
<td>CONT</td>
<td>在STOP或TSTP之后恢复执行</td>
</tr>
</tbody>
</table>
<p>在Linux上有两个命令可以向运行中的进程发出进程信号。</p>
<p><strong>kill命令</strong></p>
<p>kill命令可通过进程ID（ PID）给进程发信号。默认情况下， kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有
时并不好用。要发送进程信号，你必须是进程的属主或登录为root用户。</p>
<pre class="hljs"><code><div>$ kill 3940
$ kill -3 3940
</div></code></pre>
<p><strong>killall命令</strong></p>
<p>killall命令非常强大，它支持通过进程名而不是PID来结束进程。 killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用</p>
<pre class="hljs"><code><div># killall http*
#
</div></code></pre>
<p>上例中的命令结束了所有以http开头的进程.以root用户身份登录系统时，使用killall命令要特别小心，因为很容易就会误用通配符而结束了重要的系统进程。这可能会破坏文件系统。</p>
<h4 id="19210-%E7%9B%91%E6%B5%8B%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4">1.9.2.10. 监测磁盘空间</h4>
<h5 id="192101-df-%E5%91%BD%E4%BB%A4">1.9.2.10.1. df 命令</h5>
<p>df命令可以让你很方便地查看所有已挂载磁盘的使用情况。</p>
<pre class="hljs"><code><div>~$ df --<span class="hljs-built_in">help</span>
Usage: df [OPTION]... [FILE]...
</div></code></pre>
<pre class="hljs"><code><div>$ df
Filesystem     1K-blocks     Used Available Use% Mounted on
udev             5065648        0   5065648   0% /dev
tmpfs            1017456     1836   1015620   1% /run
/dev/sdb2       72417352 60574108   8121568  89% /

</div></code></pre>
<ul>
<li>设备的设备文件位置；</li>
<li>能容纳多少个1024字节大小的块；</li>
<li>已用了多少个1024字节大小的块；</li>
<li>还有多少个1024字节大小的块可用；</li>
<li>已用空间所占的比例；</li>
<li>设备挂载到了哪个挂载点上。</li>
</ul>
<p>df一个常用的参数是-h。它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节。</p>
<h5 id="192102-du-%E5%91%BD%E4%BB%A4">1.9.2.10.2. du 命令</h5>
<p>另一个有用的命令是du命令。 du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。
默认情况下， du命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说，这个输出会是一个比较长的列表。</p>
<pre class="hljs"><code><div>du [OPTION]... [FILE]...
or:  du [OPTION]... --files0-from=F

</div></code></pre>
<p>每行输出左边的数值是每个文件或目录占用的磁盘块数。注意，这个列表是从目录层级的最底部开始，然后按文件、子目录、目录逐级向上</p>
<p>常用参数</p>
<ul>
<li>-c：显示所有已列出文件总的大小。</li>
<li>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。</li>
<li>-s：显示每个输出参数的总计。</li>
</ul>
<h4 id="19211-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">1.9.2.11. 处理数据文件</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="192111-%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE">1.9.2.11.1. 排序数据</h5>
<p>sort命令按照会话指定的默认语言的排序规则对文本文件中的<strong>数据行</strong>排序。</p>
<pre class="hljs"><code><div>sort [OPTION]... [FILE]...
or:  sort [OPTION]... --files0-from=F

</div></code></pre>
<pre class="hljs"><code><div>$ cat txt
rr
bb
AA
aaI rf
BB
$ sort txt
AA
BB
aaI rf
bb
rr

</div></code></pre>
<p>如果数据行为数字,需要添加-n参数.</p>
<p>如果用-M参数， sort命令就能识别三字符的月份名</p>
<pre class="hljs"><code><div>Jan
Feb
Mar
Apr
May
Jun
Jul
Aug
Sep
Oct
Nov
Dec
</div></code></pre>
<ul>
<li>-b --ignore-leading-blanks 排序时忽略起始的空白</li>
<li>-C --check=quiet 不排序，如果数据无序也不要报告</li>
<li>-c --check 不排序，但检查输入数据是不是已排序；未排序的话，报告</li>
<li>-d --dictionary-order 仅考虑空白和字母，不考虑特殊字符</li>
<li>-f --ignore-case 默认情况下，会将大写字母排在前面；这个参数会忽略大小写</li>
<li>-g --general-number-sort 按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学计数法表示的值）</li>
<li>-i --ignore-nonprinting 在排序时忽略不可打印字符</li>
<li>-k --key=POS1[,POS2] 排序从POS1位置开始；如果指定了POS2的话，到POS2位置结束</li>
<li>-M --month-sort 用三字符月份名按月份排序</li>
<li>-m --merge 将两个已排序数据文件合并</li>
<li>-n --numeric-sort 按字符串数值来排序（并不转换为浮点数）</li>
<li>-o --output=file 将排序结果写出到指定的文件中</li>
<li>-R --random-sort 按随机生成的散列表的键值排序</li>
<li>--random-source=FILE 指定-R参数用到的随机字节的源文件</li>
<li>-r --reverse 反序排序（升序变成降序）</li>
<li>-S --buffer-size=SIZE 指定使用的内存大小</li>
<li>-s --stable 禁用最后重排序比较</li>
<li>-T --temporary-directory=DIR 指定一个位置来存储临时工作文件</li>
<li>-t --field-separator=SEP 指定一个用来区分键位置的字符</li>
<li>-u --unique 和-c参数一起使用时，检查严格排序；不和-c参数一起用时，仅输出第一例相似的两行</li>
<li>-z --zero-terminated 用NULL字符作为行尾，而不是用换行符</li>
</ul>
<h5 id="192112-%E6%90%9C%E7%B4%A2%E6%95%B0%E6%8D%AEgrep">1.9.2.11.2. 搜索数据grep</h5>
<p>需要在大文件中找一行数据，而这行数据又埋藏在文件的中间。这时并不需要手动翻看整个文件，用grep命令来帮助查找就行了</p>
<pre class="hljs"><code><div>grep [OPTION]... PATTERN [FILE]...

</div></code></pre>
<p>grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep的输出就是包含了匹配模式的行</p>
<p>如果要进行反向搜索（输出不匹配该模式的行），可加-v参数。</p>
<pre class="hljs"><code><div>$ grep -v t file1
one
four
five
$
</div></code></pre>
<p>如果要显示匹配模式的行所在的行号，可加-n参数。</p>
<pre class="hljs"><code><div>$ grep -n t file1
2:two
3:three
$
</div></code></pre>
<p>如果只要知道有多少行含有匹配的模式，可用-c参数。</p>
<pre class="hljs"><code><div>$ grep -c t file1
2
$
</div></code></pre>
<p>如果要指定多个匹配模式，可用-e参数来指定每个模式。</p>
<pre class="hljs"><code><div>$ grep -e t -e f file1
two
three
four
five
$
</div></code></pre>
<p>grep默认只查询匹配的一行，但是可以通过以下参数查询多行</p>
<pre class="hljs"><code><div>//查询上下
git log |grep &quot;xxxx&quot; -C 5

//查询往后 after
git log |grep &quot;xxxx&quot; -A 5

//查询往前 before
git log |grep &quot;xxxx&quot; -B 5
</div></code></pre>
<h5 id="192113-%E5%BD%92%E6%A1%A3%E6%95%B0%E6%8D%AE">1.9.2.11.3. 归档数据</h5>
<p>Unix和Linux上最广泛使用的归档工具是tar命令。tar命令最开始是用来将文件写到磁带设备上归档的，然而它也能把输出写到文件里，这种用法在Linux上已经普遍用来归档数据了。</p>
<pre class="hljs"><code><div>tar [OPTION...] [FILE]...
</div></code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>新建打包文件，同 -v 一起使用 查看过程中打包文件名</td>
</tr>
<tr>
<td>-x</td>
<td>解决文件， -C 解压到对应的文件目录。</td>
</tr>
<tr>
<td>-f</td>
<td>后面接要处理的文件</td>
</tr>
<tr>
<td>-j</td>
<td>通过bzip2方式压缩或解压，最后以.tar.br2 为后缀。压缩后大小小于.tar.gz</td>
</tr>
<tr>
<td>-z</td>
<td>通过gzip方式压缩或解压，最后以.tar.gz 为后缀</td>
</tr>
<tr>
<td>-v</td>
<td>压缩或解压过程中，显示出来过程</td>
</tr>
<tr>
<td>-t</td>
<td>查看打包文件中内容，重点文件名</td>
</tr>
<tr>
<td>-u</td>
<td>更新压缩文件中的内容。</td>
</tr>
<tr>
<td>-p</td>
<td>保留绝对路径，即允许备份数据中含有根目录</td>
</tr>
<tr>
<td>-P</td>
<td>保留数据原来权限及属性。</td>
</tr>
<tr>
<td>--exclude =FILE</td>
<td>压缩过程中，不要讲FILE打包</td>
</tr>
<tr>
<td>man tar</td>
<td>查看更多参数</td>
</tr>
</tbody>
</table>
<p>说明： -c/-x/-t/u 不可同时出现</p>
<ul>
<li>tar -jcv -f 压缩文件名称.tar.br2	压缩方式一</li>
<li>tar -jxv -f 压缩文件名称.tar.br2 -C 指定文件目录	解压文件方式一</li>
<li>tar -zcv -f 压缩文件名称.tar.gz	压缩方式二</li>
<li>tar -zxv -f 压缩文件名称.tar.gz	解压文件方式二</li>
<li>tar -tf 压缩文件名	查看文件名</li>
<li>tar -tvf 压缩文件	查看文件：所属权限、用户名用户组、日期等</li>
</ul>
<h3 id="193-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3. 环境变量</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1931-%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1. 什么是环境变量</h4>
<p>bash shell用一个叫作环境变量（ environment variable）的特性来存储有关shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序
或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>
<h5 id="19311-%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1.1. 全局环境变量</h5>
<p>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。</p>
<p>Linux系统在你开始bash会话时就设置了一些全局环境变量.系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。要查看全局变量，可以使用env或printenv命令
要显示个别环境变量的值，可以使用printenv命令，但是不要用env命令。</p>
<pre class="hljs"><code><div>printenv HOME
env HOME
<span class="hljs-comment">#或者</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span>
</div></code></pre>
<h5 id="19312-%E5%B1%80%E9%83%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.1.2. 局部环境变量</h5>
<p>局部环境变量只能在定义它们的进程中可见.Linux系统也默认定义了标准的局部环境变量。查看局部环境变量的列表有点复杂。遗憾的是，在Linux系统并没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义��量。所有通过printenv命令能看到的全局环境变量都出现在了set命令的输出中。但在set命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量。</p>
<p>命令env、 printenv和set之间的差异很细微。 set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。在这种情况下， env和printenv的输出是重复的。不过env命令有一个printenv没有的功能，这使得它要更有用一些。</p>
<h4 id="1932-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">1.9.3.2. 设置用户定义变量</h4>
<h5 id="19321-%E8%AE%BE%E7%BD%AE%E5%B1%80%E9%83%A8%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F">1.9.3.2.1. 设置局部用户变量</h5>
<p>可以在shell脚本文件中或者命令行页面使用name=val来定义局部变量.变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，bash shell就会把值当成一个单独的命令.如果值为多个单词,请用引号圈起来</p>
<pre class="hljs"><code><div>$ name=liang
$ echo $name
liang
</div></code></pre>
<h5 id="19322-%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">1.9.3.2.2. 设置全局变量</h5>
<p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。这个过程通过export命令来完成，变量名前面不需要加$。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">export</span> name
</div></code></pre>
<h4 id="1933-%E5%88%A0%E9%99%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.3. 删除环境变量</h4>
<p>可以用unset命令完成这个操作。在unset命令中引用环境变量时，记住不要使用$.如果你是在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。</p>
<p>在涉及环境变量名时，什么时候该使用$，什么时候不该使用$，实在让人摸不着头���。记住一点就行了：如果要用到变量，使用$；如果要操作变量，不使用$。这条规则的一个例外就是使用printenv显示某个变量的值。</p>
<h4 id="1934-%E9%BB%98%E8%AE%A4%E7%9A%84shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.4. 默认的shell环境变量</h4>
<p>默认情况下， bash shell会用一些特定的环境变量来定义系统环境。这些变量在你的Linux系统上都已经设置好了，只管放心使用。</p>
<p>变 量 描 述</p>
<ul>
<li>CDPATH 冒号分隔的目录列表，作为cd命令的搜索路径</li>
<li>HOME 当前用户的主目录</li>
<li>IFS shell用来将文本字符串分割成字段的一系列字符</li>
<li>MAIL 当前用户收件箱的文件名（ bash shell会检查这个文件，看看有没有新邮件）</li>
<li>MAILPATH 冒号分隔的当前用户收件箱的文件名列表（ bash shell会检查列表中的每个文件，看看有没有新邮件）</li>
<li>OPTARG getopts命令处理的最后一个选项参数值</li>
<li>OPTIND getopts命令处理的最后一个选项参数的索引号</li>
<li>PATH shell查找命令的目录列表，由冒号分隔</li>
<li>PS1 shell命令行界面的主提示符</li>
<li>PS2 shell命令行界面的次提示符</li>
<li>FUNCNEST 当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止）</li>
<li>GLOBIGNORE 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名</li>
<li>GROUPS 含有当前用户属组列表的数组变量</li>
<li>histchars 控制历史记录扩展，最多可有3个字符</li>
<li>HISTCMD 当前命令在历史记录中的编号</li>
<li>HISTCONTROL 控制哪些命令留在历史记录列表中</li>
<li>HISTFILE 保存shell历史记录列表的文件名（默认是.bash_history）</li>
<li>HISTFILESIZE 最多在历史文件中存多少行</li>
<li>HISTTIMEFORMAT 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳</li>
<li>HISTIGNORE 由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略</li>
<li>HISTSIZE 最多在历史文件中存多少条命令</li>
<li>HOSTFILE shell在补全主机名时读取的文件名称</li>
<li>HOSTNAME 当前主机的名称</li>
<li>HOSTTYPE 当前运行bash shell的机器</li>
<li>IGNOREEOF shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1）</li>
<li>INPUTRC Readline初始化文件名（默认是.inputrc）</li>
<li>LANG shell的语言环境类别</li>
<li>LC_ALL 定义了一个语言环境类别，能够覆盖LANG变量</li>
<li>LC_COLLATE 设置对字符串排序时用的排序规则</li>
<li>LC_CTYPE 决定如何解释出现在文件名扩展和模式匹配中的字符</li>
<li>LC_MESSAGES 在解释前面带有$的双引号字符串时，该环境变量决定了所采用的语言环境设置</li>
<li>LC_NUMERIC 决定着格式化数字时采用的语言环境设置</li>
<li>LINENO 当前执行的脚本的行号</li>
<li>LINES 定义了终端上可见的行数</li>
<li>MACHTYPE 用“ CPU公司系统”（ CPU-company-system）格式定义的系统类型</li>
<li>MAPFILE 一个数组变量，当mapfile命令未指定数组变量作为参数时，它存储了mapfile所读入的文本</li>
<li>MAILCHECK shell查看新邮件的频率（以秒为单位，默认值是60）</li>
<li>OLDPWD shell之前的工作目录</li>
<li>OPTERR 设置为1时， bash shell会显示getopts命令产生的错误</li>
<li>OSTYPE 定义了shell所在的操作系统</li>
<li>PIPESTATUS 含有前台进程的退出状态列表的数组变量</li>
<li>POSIXLY_CORRECT 设置了的话， bash会以POSIX模式启动</li>
<li>PPID bash shell父进程的PID</li>
<li>PROMPT_COMMAND 设置了的话，在命令行主提示符显示之前会执行这条命令</li>
<li>PROMPT_DIRTRIM 用来定义当启用了\w或\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换</li>
<li>PS3 select命令的提示符</li>
<li>PS4 如果使用了bash的-x选项，在命令行之前显示的提示信息</li>
<li>PWD 当前工作目录</li>
<li>RANDOM 返回一个0～ 32767的随机数（对其的赋值可作为随机数生成器的种子）</li>
<li>READLINE_LINE 当使用bind –x命令时，存储Readline缓冲区的内容</li>
<li>READLINE_POINT 当使用bind –x命令时，表示Readline缓冲区内容插入点的当前位置</li>
<li>REPLY read命令的默认变量</li>
<li>SECONDS 自从shell启动到现在的秒数（对其赋值将会重置计数器）</li>
<li>SHELL bash shell的全路径名</li>
<li>SHELLOPTS 已启用bash shell选项列表，列表项之间以冒号分隔</li>
<li>SHLVL shell的层级；每次启动一个新bash shell，该值增加1</li>
<li>TIMEFORMAT 指定了shell的时间显示格式</li>
<li>TMOUT select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示无限长</li>
<li>TMPDIR 目录名，保存bash shell创建的临时文件</li>
<li>UID 当前用户的真实用户ID（数字形式）</li>
</ul>
<h4 id="1935-%E8%AE%BE%E7%BD%AEpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.5. 设置PATH环境变量</h4>
<p>当你在shell命令行界面中输入一个外部命令时， shell必须搜索系统来找到对应的程序。 PATH环境变量定义了用于进行命令和程序查找的目录。应用程序放置可执行文件的目录常常不在PATH环境变量所包含的目录中。解决的办法是保证PATH环境变量包含了所有存放应用程序的目录。PATH中各个目录之间是用冒号分隔的。你只需引用原来的PATH值，然后再给这个字符串添加新目录就行了.</p>
<pre class="hljs"><code><div>PATH=<span class="hljs-variable">$PATH</span>:/XX/XX/XX
</div></code></pre>
<p>以上对PATH变量的修改只能持续到退出或重启系统。</p>
<h4 id="1936-%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">1.9.3.6. 定位系统环境变量</h4>
<p>在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。 bash检查的启动文件取决于你启动bash shell的方式。启动bash
shell有3种方式：</p>
<ul>
<li>登录时作为默认登录shell</li>
<li>作为非登录shell的交互式shell</li>
<li>作为运行脚本的非交互shell</li>
</ul>
<h5 id="19361-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%81%E4%B9%85%E5%8C%96">1.9.3.6.1. 环境变量持久化</h5>
<p>对全局环境变量来说（ Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中，但这可不是什么好主意。如果你升级了所用的发行版，
这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。
最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。</p>
<h4 id="1937-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F">1.9.3.7. 数组变量</h4>
<p>环境变量有一个很酷的特性就是，它们可作为数组使用。数组是能够存储多个值的变量。这些值可以单独引用，也可以作为整个数组来引用。要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。</p>
<pre class="hljs"><code><div><span class="hljs-comment">#定义</span>
mytest=(one two three four five)
<span class="hljs-comment">#打印第一个值</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$mytest</span>

<span class="hljs-comment">#按索引</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${mytest[2]}</span>
<span class="hljs-comment"># *所有数据</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${mytest[*]}</span>

<span class="hljs-comment">#修改某个索引</span>
mytest[2]=seven
<span class="hljs-comment"># unset命令删除数组中的某个值,该位置为空</span>
<span class="hljs-built_in">unset</span> mytest[2]

<span class="hljs-comment"># 删除整个数组的值</span>
<span class="hljs-built_in">unset</span> mytest
</div></code></pre>
<h3 id="194-%E7%90%86%E8%A7%A3linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">1.9.4. 理解Linux文件权限</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<p>系统中必须有一套能够保护文件免遭非授权用户浏览或修改的机制。 Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件和目录的安全性设置来访问文件。</p>
<h4 id="1941-linux-%E5%AE%89%E5%85%A8%E6%80%A7">1.9.4.1. Linux 安全性</h4>
<p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（ User ID，通常缩写为UID）来跟踪的。 UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。登录名是用户用来登录系统的最长八字符的字符串（字符可以是数字或字母），同时会关联一个对应的密码。</p>
<h5 id="19411-etcpasswd-%E6%96%87%E4%BB%B6">1.9.4.1.1. /etc/passwd 文件</h5>
<p>Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是/etc/passwd文件，它包含了一些与用户有关的信息</p>
<pre class="hljs"><code><div>cat /etc/passwd  
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
lgj:x:1000:1000:lgj,,,:/home/lgj:/bin/bash

</div></code></pre>
<p>root用户账户是Linux系统的管理员，固定分配给它的UID是0。就像上例中显示的， Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。</p>
<p>Linux为系统账户预留了500以下的UID值。有些服务甚至要用特定的UID才能正常工作。为普通用户创建账户时，大多数Linux系统会从500开始，将第一个可用UID分配给这个账户.</p>
<p>/etc/passwd文件的字段包含了如下信息：</p>
<ul>
<li>登录用户名</li>
<li>用户密码,/etc/passwd文件中的密码字段都被设置成了x</li>
<li>用户账户的UID（数字形式）</li>
<li>用户账户的组ID（ GID）（数字形式）</li>
<li>用户账户的文本描述（称为备注字段）</li>
<li>用户HOME目录的位置</li>
<li>用户的默认shell</li>
</ul>
<p>绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置在/etc/shadow）。只有特定的程序（比如登录程序）才能访问这个文件。</p>
<h5 id="19412-etcshadow-%E6%96%87%E4%BB%B6">1.9.4.1.2. /etc/shadow 文件</h5>
<p>/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。</p>
<pre class="hljs"><code><div>sudo cat /etc/shadow
root:!:17896:0:99999:7:::
daemon:*:17737:0:99999:7:::
bin:*:17737:0:99999:7:::
sys:*:17737:0:99999:7:::
lgj:$6$y3NHikSM$Av9t3R45Hji8COM1cWegzv0yyn7QeVCReWmh8mhvdhmWhxZsw2AqU9Ua2e7N523SkooLQPAkmqXx8Rhk8qdbL0:17896:0:99999:7:::

</div></code></pre>
<p>在/etc/shadow文件的每条记录中都有9个字段：</p>
<ul>
<li>与/etc/passwd文件中的登录名字段对应的登录名</li>
<li>加密后的密码</li>
<li>自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</li>
<li>多少天后才能更改密码</li>
<li>多少天后必须更改密码</li>
<li>密码过期前提前多少天提醒用户更改密码</li>
<li>密码过期后多少天禁用用户账户</li>
<li>用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</li>
<li>预留字段给将来使用
使用shadow密码系统后， Linux系统可以更好地控制用户密码。它可以控制用户多久更改一次密码，以及什么时候禁用该用户账户，如果密码未更新的话。</li>
</ul>
<h5 id="19413-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7">1.9.4.1.3. 添加新用户</h5>
<p>用来向Linux系统添加新用户的主要工具是useradd。这个命令简单快捷，可以一次性创建新用户账户及设置用户HOME目录结构。 useradd命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。可以使用加入了-D选项的useradd命令查看所用Linux系统中的这些默认值。在创建新用户时，如果你不在命令行中指定具体的值， useradd命令就会使用-D选项所显示的那些默认值。</p>
<pre class="hljs"><code><div>$ useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/sh
SKEL=/etc/skel
CREATE_MAIL_SPOOL=YES
</div></code></pre>
<ul>
<li>新用户会被添加到GID为100的公共组；</li>
<li>新用户的HOME目录将会位于/home/loginname；</li>
<li>新用户账户密码在过期后不会被禁用；</li>
<li>新用户账户未被设置过期日期；</li>
<li>新用户账户将bash shell作为默认shell；</li>
<li>系统会将/etc/skel目录下的内容复制到用户的HOME目录下；</li>
<li>系统为该用户账户在mail目录下创建一个用于接收邮件的文件。</li>
</ul>
<p>倒数第二个值很有意思。 useradd命令允许管理员创建一份默认的HOME目录配置，然后把它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系统文件。在Ubuntu Linux系统上， /etc/skel目录有下列文件：</p>
<pre class="hljs"><code><div> ls -al /etc/skel
total 40
drwxr-xr-x   2 root root  4096 Jul 25  2018 .
drwxr-xr-x 143 root root 12288 Dec  5 04:15 ..
-rw-r--r--   1 root root   220 Apr  5  2018 .bash_logout
-rw-r--r--   1 root root  3771 Apr  5  2018 .bashrc
-rw-r--r--   1 root root   807 Apr  5  2018 .profile
-rw-r--r--   1 root root  8980 Apr 16  2018 examples.desktop

</div></code></pre>
<p>它们是bash shell环境的标准启动文件。系统会自动将这些默认文件复制到你创建的每个用户的HOME目录。</p>
<p>参 数 描 述</p>
<ul>
<li>-b default_home 更改默认的创建用户HOME目录的位置</li>
<li>-e expiration_date 更改默认的新账户的过期日期</li>
<li>-f inactive 更改默认的新用户从密码过期到账户被禁用的天数</li>
<li>-g group 更改默认的组名称或GID</li>
<li>-s shell 更改默认的登录shell</li>
<li>-c comment 给新用户添加备注</li>
<li>-d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话）</li>
<li>-e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期</li>
<li>-f inactive_days 指定这个账户密码过期后多少天这个账户被禁用； 0表示密码一过期就立即禁用， 1表示禁用这个功能</li>
<li>-g initial_group 指定用户登录组的GID或组名</li>
<li>-G group ... 指定用户除登录组之外所属的一个或多个附加组</li>
<li>-k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录</li>
<li>-m 创建用户的HOME目录</li>
<li>-M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项）</li>
<li>-n 创建一个与用户登录名同名的新组</li>
<li>-r 创建系统账户</li>
<li>-p passwd 为用户账户指定默认密码</li>
<li>-s shell 指定默认的登录shell</li>
<li>-u uid 为账户指定唯一的UID</li>
</ul>
<h5 id="19414-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">1.9.4.1.4. 删除用户</h5>
<p>默认情况下， userdel命令会只删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。如果加上-r参数， userdel会删除用户的HOME目录以及邮件目录(需要小心,防止误删除文件)。然而，系统上仍可能存有已删除用户的其他文件。这在有些环境中会造成问题。</p>
<pre class="hljs"><code><div>userdel -r <span class="hljs-built_in">test</span>
</div></code></pre>
<h5 id="19415-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7">1.9.4.1.5. 修改用户</h5>
<p>用户账户修改工具</p>
<table>
<thead>
<tr>
<th>命 令</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>usermod</td>
<td>修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>
</tr>
<tr>
<td>passwd</td>
<td>修改已有用户的密码</td>
</tr>
<tr>
<td>chpasswd</td>
<td>从文件中读取登录名密码对，并更新密码</td>
</tr>
<tr>
<td>chage</td>
<td>修改密码的过期日期</td>
</tr>
<tr>
<td>chfn</td>
<td>修改用户账户的备注信息</td>
</tr>
<tr>
<td>chsh</td>
<td>修改用户账户的默认登录shell</td>
</tr>
</tbody>
</table>
<p><strong>usermod</strong></p>
<p>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如， -c修改备注字段， -e修改过期日期， -g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>
<ul>
<li>-l修改用户账户的登录名。</li>
<li>-L锁定账户，使用户无法登录。</li>
<li>-p修改账户的密码。</li>
<li>-U解除锁定，使用户能够登录。</li>
</ul>
<p><strong>passwd和chpasswd</strong></p>
<p>改变用户密码的一个简便方法就是用passwd命令。如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只有root用户才有权限改别人的密码。</p>
<p>如果需要为系统中的大量用户修改密码， chpasswd命令可以事半功倍。 chpasswd命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>
<pre class="hljs"><code><div># chpasswd &lt; users.txt
</div></code></pre>
<h4 id="1942-%E4%BD%BF%E7%94%A8linux%E7%BB%84">1.9.4.2. 使用Linux组</h4>
<p>用户账户在控制单个用户安全性方面很好用，但涉及在共享资源的一组用户时就捉襟见肘了。为了解决这个问题， Linux系统采用了另外一个安全概念——组（ group）。组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。除了GID，每个组还有唯一的组名。</p>
<h5 id="19421-etcgroup-%E6%96%87%E4%BB%B6">1.9.4.2.1. /etc/group 文件</h5>
<p>与用户账户类似，组信息也保存在系统的一个文件中。 /etc/group文件包含系统上用到的每个组的信息。</p>
<pre class="hljs"><code><div>$ cat /etc/group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:

</div></code></pre>
<ul>
<li>组名</li>
<li>组密码</li>
<li>GID</li>
<li>属于该组的用户列表</li>
</ul>
<h5 id="19422-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BB%84">1.9.4.2.2. 创建新组</h5>
<p>组密码允许非组内成员通过它临时成为该组成员。这个功能并不很普遍，但确实存在。千万不能通过直接修改/etc/group文件来添加用户到一个组，要用usermod命令.在添加用户到不同的组之前，首先得创建组。</p>
<p>groupadd命令可在系统上创建新组。</p>
<pre class="hljs"><code><div>groupadd  group_name
</div></code></pre>
<p>在创建新组时，默认没有用户被分配到该组。 groupadd命令没有提供将用户添加到组中的选项，但可以用usermod命令来弥补这一点。</p>
<pre class="hljs"><code><div>sermod -G group_name  user_name
</div></code></pre>
<p>-G选项会把这个新组添加到该用户账户的组列表里。</p>
<p>为用户账户分配组时要格外小心。如果加了-g选项，指定的组名会替换掉该账户的默认组。 -G选项则将该组添加到用户的属组的列表里，不会影响默认组。</p>
<h5 id="19423-%E4%BF%AE%E6%94%B9%E7%BB%84">1.9.4.2.3. 修改组</h5>
<p>在/etc/group文件中可以看到，需要修改的组信息并不多。 groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）。</p>
<pre class="hljs"><code><div>groupmod -n new_name old_name
</div></code></pre>
<p>修改组名时， GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，你可以随意改变组名而不会影响文件的安全性。</p>
<h4 id="1943-%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">1.9.4.3. 理解文件权限</h4>
<h5 id="19431-%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AC%A6">1.9.4.3.1. 使用文件权限符</h5>
<pre class="hljs"><code><div>$ ls -l
total 322056
-rw-rw-r--  1 lgj  lgj        19003 Aug 17 21:59  9be419dbly1g617zg1l6bj208q0dwq37.jpg
drwxrwxr-x  2 lgj lgj         4096 2019-09-03 15:12 test2
</div></code></pre>
<ul>
<li>-代表文件</li>
<li>d代表目录</li>
<li>l代表链接</li>
<li>c代表字符型设备</li>
<li>b代表块设备</li>
<li>n代表网络设备</li>
</ul>
<p>之后有3组三字符的编码。每一组定义了3种访问权限：</p>
<ul>
<li>r代表对象是可读的</li>
<li>w代表对象是可写的</li>
<li>x代表对象是可执行的</li>
</ul>
<p>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：</p>
<ul>
<li>对象的属主</li>
<li>对象的属组</li>
<li>系统其他用户</li>
</ul>
<p><strong>Linux文件权限码</strong></p>
<table>
<thead>
<tr>
<th>权 限</th>
<th>二进制值</th>
<th>八进制值</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>---</td>
<td>000</td>
<td>0</td>
<td>没有任何权限</td>
</tr>
<tr>
<td>--x</td>
<td>001</td>
<td>1</td>
<td>只有执行权限</td>
</tr>
<tr>
<td>-w-</td>
<td>010</td>
<td>2</td>
<td>只有写入权限</td>
</tr>
<tr>
<td>-wx</td>
<td>011</td>
<td>3</td>
<td>有写入和执行权限</td>
</tr>
<tr>
<td>r--</td>
<td>100</td>
<td>4</td>
<td>只有读取权限</td>
</tr>
<tr>
<td>r-x</td>
<td>101</td>
<td>5</td>
<td>有读取和执行权限</td>
</tr>
<tr>
<td>rw-</td>
<td>110</td>
<td>6</td>
<td>有读取和写入权限</td>
</tr>
<tr>
<td>rwx</td>
<td>111</td>
<td>7</td>
<td>有全部权限</td>
</tr>
</tbody>
</table>
<h4 id="1944-%E6%94%B9%E5%8F%98%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E7%BD%AE">1.9.4.4. 改变安全性设置</h4>
<p><strong>修改文件权限</strong></p>
<pre class="hljs"><code><div>chmod 723 filename
chmod u+x filename 
chmod g+r filename 
chmod o+r filename 
chmod g-r filename 
chmod o-r filename 
</div></code></pre>
<p><strong>改变所属关系</strong></p>
<p>Linux提供了两个命令来实现这个功能： chown命令用来改变文件的属主，chgrp命令用来改变文件的默认属组。</p>
<p>chown命令的格式如下。</p>
<pre class="hljs"><code><div>chown options owner[.group] file

chown dan.shared newfile
<span class="hljs-comment">#如果你不嫌麻烦，可以只改变一个目录的默认属组。</span>
chown .rich newfile
</div></code></pre>
<p>chown命令采用一些不同的选项参数。 -R选项配合通配符可以递归地改变子目录和文件的所属关系。 -h选项可以改变该文件的所有符号链接文件的所属关系
只有root用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须是原属组和目标属组的成员。</p>
<p>chgrp命令可以更改文件或目录的默认属组</p>
<pre class="hljs"><code><div>chgrp shared newfile
</div></code></pre>
<p>用户账户必须是这个文件的属主，除了能够更换属组之外，还得是新组的成员。现在shared组的任意一个成员都可以写这个文件了</p>
<h4 id="1945-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6">1.9.4.5. 共享文件</h4>
<p>创建新文件时， Linux会用你默认的UID和GID给文件分配权限。想让其他人也能访问文件，要么改变其他用户所在安全组的访问权限，要么就给文件分配一个包含其他用户的新默认属组</p>
<p>如果你想在大范围环境中创建文档并将文档与人共享，这会很烦琐。幸好有一种简单的方法可以解决这个问题。</p>
<p>Linux还为每个文件和目录存储了3个额外的信息位。</p>
<ul>
<li>设置用户ID（ SUID） ：当文件被用户使用时，程序会以文件属主的权限运行。</li>
<li>设置组ID（ SGID） ：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。</li>
<li>粘着位：进程结束后文件还驻留（粘着）在内存中。</li>
</ul>
<p>SGID位对文件共享非常重要。启用SGID位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组。</p>
<p>GID可通过chmod命令设置。它会加到标准3位八进制值之前（组成4位八进制值），或者在符号模式下用符号s。如果你用的是八进制模式，你需要知道这些位的位置</p>
<p><strong>chmod SUID、 SGID和粘着位的八进制值</strong></p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>八进制值</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
<td>所有位都清零</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
<td>粘着位置位</td>
</tr>
<tr>
<td>010</td>
<td>2</td>
<td>SGID位置位</td>
</tr>
<tr>
<td>011</td>
<td>3</td>
<td>SGID位和粘着位都置位</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>SUID位置位</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>SUID位和粘着位都置位</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>SUID位和SGID位都置位</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>所有位都置位</td>
</tr>
</tbody>
</table>
<p>要创建一个共享目录，使目录里的新文件都能沿用目录的属组，只需将该目录的SGID位置位。</p>
<pre class="hljs"><code><div>$ mkdir testdir
$ ls -l
drwxrwxr-x 2 rich rich 4096 Sep 20 23:12 testdir/
$ chgrp shared testdir
$ chmod g+s testdir
$ ls -l
drwxrwsr-x 2 rich shared 4096 Sep 20 23:12 testdir/
$ <span class="hljs-built_in">umask</span> 002
$ <span class="hljs-built_in">cd</span> testdir
$ touch testfile
$ ls -l
total 0
-rw-rw-r-- 1 rich shared 0 Sep 20 23:13 testfile
$
</div></code></pre>
<p>首先，用mkdir命令来创建希望共享的目录。然后通过chgrp命令将目录的默认属组改为包含所有需要共享文件的用户的组（你必须是该组的成员）。最后，将目录的SGID位置位，以保证目录中新建文件都用shared作为默认属组。
为了让这个环境能正常工作，所有组成员都需把他们的umask值设置成文件对属组成员可写。在前面的例子中， umask改成了002，所以文件对属组是可写的。
做完了这些，组成员就能到共享目录下创建新文件了。跟期望的一样，新文件会沿用目录的属组，而不是用户的默认属组。现在shared组的所有用户都能访问这个文件了。</p>
<h3 id="195-%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5. 管理文件系统</h3>
<p><a href="#menu" style="float:right">目录</a></p>
<h4 id="1951-linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.1. Linux 文件系统</h4>
<p><strong>ext文件系统</strong></p>
<p>Linux操作系统中引入的最早的文件系统叫作扩展文件系统（ extended filesystem，简记为ext）。它为Linux提供了一个基本的类Unix文件系统：使用虚拟目录来操作硬件设备，在物理设备上按定长的块来存储数据。</p>
<p>ext文件系统采用名为索引节点的系统来存放虚拟目录中所存储文件的信息。索引节点系统在每个物理设备中创建一个单独的表（称为索引节点表）来存储这些文件的信息。存储在虚拟目录中的每一个文件在索引节点表中都有一个条目。 ext文件系统名称中的extended部分来自其跟踪的每个文件的额外数据，包括：</p>
<h4 id="1952-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.2. 操作文件系统</h4>
<h4 id="1953-%E9%80%BB%E8%BE%91%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">1.9.5.3. 逻辑文件系统</h4>
<h3 id="196-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.6. Shell脚本编程</h3>
<h4 id="1961-%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4">1.9.6.1. 基本脚本命令</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19611-%E5%88%9B%E5%BB%BA-shell-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6">1.9.6.1.1. 创建 shell 脚本文件</h5>
<p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#!/bin/bash
</span></div></code></pre>
<p>在通常的shell脚本中，井号（ #）用作注释行。 shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外， #后面的惊叹号会告诉shell用哪个shell来运行脚本.</p>
<p>编写完成后,保存为test.sh,并修改文件权限为可执行文件.</p>
<pre class="hljs"><code><div><span class="hljs-comment">#用户权限增加执行</span>
chmod u+x test.sh
</div></code></pre>
<p>两种方式运行:
第一种:直接使用&quot;./&quot;命令</p>
<pre class="hljs"><code><div>./test.sh
</div></code></pre>
<p>第二种:直接让shell自动搜索该文件并执行.需要在环境变量中添加该执行脚本的目录</p>
<pre class="hljs"><code><div>
PATH=<span class="hljs-variable">$PATH</span>:/xxx/xxx
<span class="hljs-comment">#直接执行</span>
test.sh

</div></code></pre>
<h5 id="19612-%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%89%93%E5%8D%B0">1.9.6.1.2. 脚本中打印</h5>
<p>使用echo命令.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">echo</span> this is a <span class="hljs-built_in">test</span>!
</div></code></pre>
<p>echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来</p>
<p>echo 后面会自动换行,如果取消换行,可以使用-n参数.</p>
<h5 id="19613-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.6.1.3. 使用变量</h5>
<p>用户也可以自定义变量</p>
<ul>
<li>用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。用户变量区分大小写，所以变量Var1和变量var1是不同的</li>
<li>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格</li>
<li>hell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里， shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉</li>
<li>使用变量,在变量前加&quot;$&quot;,而引用变量来对其进行赋值时则不要使用美元符号</li>
</ul>
<pre class="hljs"><code><div>name=<span class="hljs-string">"libai"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>
</div></code></pre>
<h5 id="19614-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">1.9.6.1.4. 命令替换</h5>
<p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量.
有两种方法可以将命令输出赋给变量：</p>
<ul>
<li>反引号字符（`）</li>
<li>$()格式</li>
</ul>
<pre class="hljs"><code><div>testing='date'
testing=$(date)
echo &quot;The date and time are: &quot; $testing

today=$(date +%y%m%d)

</div></code></pre>
<p>+%y%m%d格式告诉date命令将日期显示为两位数的年月日的组合</p>
<h5 id="19615-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">1.9.6.1.5. 重定向输入和输出</h5>
<ul>
<li>输出重定向</li>
</ul>
<p>最基本的重定向将命令的输出发送到一个文件中,bash shell用大于号（&gt;）来完成这项功能,追加内容使用(&gt;&gt;)</p>
<pre class="hljs"><code><div>command &gt; test.txt
</div></code></pre>
<p>定向操作符创建了一个文件test.txt（通过默认的umask设置），并将命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>
<ul>
<li>输入重定向</li>
</ul>
<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件</p>
<h5 id="19616-%E7%AE%A1%E9%81%93">1.9.6.1.6. 管道</h5>
<p>有时需要将一个命令的输出作为另一个命令的输入,使用&quot;|&quot;.</p>
<pre class="hljs"><code><div>command1 | command2
</div></code></pre>
<p>不要以为由管道串起的两个命令会依次执行。 Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p>
<h5 id="19617-%E6%89%A7%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97">1.9.6.1.7. 执行数学运算</h5>
<p><strong>基本数学运算</strong></p>
<pre class="hljs"><code><div>var1=$[1 + 5]
var2=$[$var1 * 2]
var4=$[$var1 * ($var2 - $var3)]
</div></code></pre>
<p>上面的数学运算不支持浮点运算</p>
<p><strong>浮点操作</strong></p>
<h5 id="19618-%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC">1.9.6.1.8. 退出脚本</h5>
<p>shell中运行的每个命令都使用退出状态码（ exit status）告诉shell它已经运行完毕。退出状态码是一个0～ 255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用</p>
<p>默认情况下， shell脚本会以脚本中的最后一个命令的退出状态码退出。也可以主动调用exit命令退出.</p>
<p>Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由shell所执行的最后一条命令的退出状态码.</p>
<table>
<thead>
<tr>
<th>状 态 码</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>命令成功结束</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过Ctrl+C终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody>
</table>
<h4 id="1962-%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.6.2. 结构化命令</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19621-%E4%BD%BF%E7%94%A8-if-then-%E8%AF%AD%E5%8F%A5">1.9.6.2.1. 使用 if-then 语句</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span>
<span class="hljs-keyword">then</span>
   commands
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p>bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值， then部分的命令就不会被执行， bash shell会继续执行脚本中的下一个命令。 fi语句用来表示if-then语句到此结束</p>
<h5 id="19622-if-then-else-%E8%AF%AD%E5%8F%A5">1.9.6.2.2. if-then-else 语句</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span>
<span class="hljs-keyword">then</span>
    commands
<span class="hljs-keyword">else</span>
    commands
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p>当if语句中的命令返回退出状态码0时， then部分中的命令会被执行，这跟普通的if-then语句一样。当if语句中的命令返回非零退出状态码时， bash shell会执行else部分中的命令。</p>
<h5 id="19623-%E5%B5%8C%E5%A5%97-if">1.9.6.2.3. 嵌套 if</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> command1
<span class="hljs-keyword">then</span>
    commands
<span class="hljs-keyword">elif</span> command2
    <span class="hljs-keyword">then</span>
    more commands
<span class="hljs-keyword">fi</span>
</div></code></pre>
<h5 id="19624-test-%E5%91%BD%E4%BB%A4">1.9.6.2.4. test 命令</h5>
<p>if-then语句只能判断命令的退出状态码,不能判断其他,比如比较两个数值的大小.test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0.如果条件不成立， test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">test</span> condition
</div></code></pre>
<p>test命令可以判断三类条件：</p>
<ul>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ul>
<p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> [ condition ]
<span class="hljs-keyword">then</span>
commands
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p><strong>test命令的数值比较功能</strong></p>
<table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n1 -eq n2</td>
<td>检查n1是否与n2相等</td>
</tr>
<tr>
<td>n1 -ge n2</td>
<td>检查n1是否大于或等于n2</td>
</tr>
<tr>
<td>n1 -gt n2</td>
<td>检查n1是否大于n2</td>
</tr>
<tr>
<td>n1 -le n2</td>
<td>检查n1是否小于或等于n2</td>
</tr>
<tr>
<td>n1 -lt n2</td>
<td>检查n1是否小于n2</td>
</tr>
<tr>
<td>n1 -ne n2</td>
<td>检查n1是否不等于n2</td>
</tr>
</tbody>
</table>
<p>以上仅支持整数,不支持浮点数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -gt 5 ]
</div></code></pre>
<p><strong>字符串比较</strong></p>
<table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>str1 = str2</td>
<td>检查str1是否和str2相同</td>
</tr>
<tr>
<td>str1 != str2</td>
<td>检查str1是否和str2不同</td>
</tr>
<tr>
<td>str1 &lt; str2</td>
<td>检查str1是否比str2小</td>
</tr>
<tr>
<td>str1 &gt; str2</td>
<td>检查str1是否比str2大</td>
</tr>
<tr>
<td>-n str1</td>
<td>检查str1的长度是否非0</td>
</tr>
<tr>
<td>-z str1</td>
<td>检查str1的长度是否为0</td>
</tr>
</tbody>
</table>
<p>上面的使用大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$val1</span> \&gt; <span class="hljs-variable">$val2</span> ]
</div></code></pre>
<p>大于和小于顺序和sort命令所采用的不同。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。 sort命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。</p>
<p>test命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果你对数值使用了数学运算符号， shell会将它们当成字符串值，可能无法得到正确的结果。</p>
<p><strong>字符串大小</strong>
-n和-z可以检查一个变量是否含有数据。</p>
<p>if [ -n $val1 ]
判断val1变量是否长度非0
if [ -z $var2 ]
判断val2变量是否长度为0</p>
<p><strong>文件比较</strong></p>
<table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d file</td>
<td>检查file是否存在并是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>检查file是否存在</td>
</tr>
<tr>
<td>-f file</td>
<td>检查file是否存在并是一个文件</td>
</tr>
<tr>
<td>-r file</td>
<td>检查file是否存在并可读</td>
</tr>
<tr>
<td>-s file</td>
<td>检查file是否存在并非空</td>
</tr>
<tr>
<td>-w file</td>
<td>检查file是否存在并可写</td>
</tr>
<tr>
<td>-x file</td>
<td>检查file是否存在并可执行</td>
</tr>
<tr>
<td>-O file</td>
<td>检查file是否存在并属当前用户所有</td>
</tr>
<tr>
<td>-G file</td>
<td>检查file是否存在并且默认组与当前用户相同</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>检查file1是否比file2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>检查file1是否比file2旧</td>
</tr>
</tbody>
</table>
<h5 id="19625-%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95">1.9.6.2.5. 复合条件测试</h5>
<p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>
<ul>
<li>[ condition1 ] &amp;&amp; [ condition2 ]</li>
<li>[ condition1 ] || [ condition2 ]</li>
</ul>
<h5 id="19626-if-then-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">1.9.6.2.6. if-then 的高级特性</h5>
<p>bash shell提供了两项可在if-then语句中使用的高级特性：</p>
<ul>
<li>用于数学表达式的双括号</li>
<li>用于高级字符串处理功能的双方括号</li>
</ul>
<p>双括号命令的格式如下：</p>
<pre class="hljs"><code><div>(( expression ))
</div></code></pre>
<p>expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，双括号命令中会用到的其他运算符。</p>
<table>
<thead>
<tr>
<th>符 号</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>val++</td>
<td>后增</td>
</tr>
<tr>
<td>val--</td>
<td>后减</td>
</tr>
<tr>
<td>++val</td>
<td>先增</td>
</tr>
<tr>
<td>--val</td>
<td>先减</td>
</tr>
<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr>
<td>~</td>
<td>位求反</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr>
<td>&amp;</td>
<td>位布尔和</td>
</tr>
<tr>
<td>|</td>
<td>位布尔或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
<p>可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (( <span class="hljs-variable">$val1</span> ** 2 &gt; 90 ))
<span class="hljs-keyword">then</span>
(( val2 = <span class="hljs-variable">$val1</span> ** 2 ))
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The square of <span class="hljs-variable">$val1</span> is <span class="hljs-variable">$val2</span>"</span>
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：</p>
<pre class="hljs"><code><div>[[ expression ]]
</div></code></pre>
<p>双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——模式匹配（ pattern matching）。
双方括号在bash shell中工作良好。不过要小心，不是所有的shell都支持双方括号。</p>
<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$USER</span> == r* ]]
<span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello <span class="hljs-variable">$USER</span>"</span>
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Sorry, I do not know you"</span>
<span class="hljs-keyword">fi</span>
</div></code></pre>
<h5 id="19627-case-%E5%91%BD%E4%BB%A4">1.9.6.2.7. case 命令</h5>
<p>有了case命令，就不需要再写出所有的elif语句来不停地检查同一个变量的值了。 case命令会采用列表格式来检查单个变量的多个值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> variable <span class="hljs-keyword">in</span>
pattern1 | pattern2) commands1;;
pattern3) commands2;;
*) default commands;;
<span class="hljs-keyword">esac</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> <span class="hljs-variable">$USER</span> <span class="hljs-keyword">in</span>
rich | barbara)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Welcome, <span class="hljs-variable">$USER</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Please enjoy your visit"</span>;;
testing)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Special testing account"</span>;;
jessica)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Do not forget to log off when you're done"</span>;;
*)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Sorry, you are not allowed here"</span>;;
<span class="hljs-keyword">esac</span>
</div></code></pre>
<h4 id="1963-%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.6.3. 更多结构化命令</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19631-for%E5%91%BD%E4%BB%A4">1.9.6.3.1. for命令</h5>
<p>bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list
<span class="hljs-keyword">do</span>
commands
<span class="hljs-keyword">done</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> The next state is <span class="hljs-variable">$test</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p>如果字符串列表中包含单引号,就会出现问题,单引号之间的多个字符就被当作一个字符.
有两种办法可解决这个问题：</p>
<ul>
<li>使用转义字符（反斜线）来将单引号转义；</li>
<li>使用双引号来定义用到单引号的值。</li>
</ul>
<p>for循环假定每个值都是用空格分割的,但有的词语是多个单词组成的,比如人名.此时应该使用双引号圈起来.另外要注意的是，在某个值两边使用双引号时， shell并不会将双引号当成值的一部分。</p>
<p><strong>从变量读取列表</strong></p>
<pre class="hljs"><code><div>list=<span class="hljs-string">"Alabama Alaska Arizona Arkansas Colorado"</span>
<span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> <span class="hljs-variable">$list</span>
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Have you ever visited <span class="hljs-variable">$state</span>?"</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>从命令读取值</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$file</span>)
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Visit beautiful <span class="hljs-variable">$state</span>"</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>更改字段分隔符</strong>
IFS环境变量定义了bash shell用作字段分隔符的一系列字符.默认情况下， bash shell会将下列字符当作字段分隔符：</p>
<ul>
<li>空格</li>
<li>制表符</li>
<li>换行符</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">#将这个语句加入到脚本中，告诉bash shell在数据值中忽略空格和制表符</span>
IFS=$<span class="hljs-string">'\n'</span>
<span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$file</span>)
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Visit beautiful <span class="hljs-variable">$state</span>"</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p>在处理代码量较大的脚本时，可能在一个地方需要修改IFS的值，然后忽略这次修改，在脚本的其他地方继续沿用IFS的默认值。一个可参考的安全实践是在改变IFS之前保存原来的IFS值，之后再恢复它。这种技术可以这样实现：</p>
<pre class="hljs"><code><div>IFS.OLD=<span class="hljs-variable">$IFS</span>
IFS=$<span class="hljs-string">'\n'</span>
</div></code></pre>
<p>&lt;在代码中使用新的IFS值&gt;</p>
<pre class="hljs"><code><div>IFS=<span class="hljs-variable">$IFS</span>.OLD
</div></code></pre>
<p>这就保证了在脚本的后续操作中使用的是IFS的默认值。</p>
<p>自定义任意字符为分隔符</p>
<pre class="hljs"><code><div>IFS=a

<span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> bac

<span class="hljs-keyword">do</span> 
   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$val</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment">#输出</span>
b c
</div></code></pre>
<p>IFS=$'\n':;&quot;
这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。</p>
<p><strong>用通配符读取目录</strong></p>
<p>可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/<span class="hljs-built_in">test</span>/* /home/rich/test1/*
<span class="hljs-keyword">do</span>
<span class="hljs-keyword">if</span> [ -d <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> ]
<span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$file</span> is a directory"</span>
<span class="hljs-keyword">elif</span> [ -f <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> ]
<span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$file</span> is a file"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p>在Linux中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将$file变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。</p>
<h5 id="19632-c-%E8%AF%AD%E8%A8%80%E7%9A%84-for-%E5%91%BD%E4%BB%A4">1.9.6.3.2. C 语言的 for 命令</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (( i=1; i &lt;= 10; i++ ))
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The next number is <span class="hljs-variable">$i</span>"</span>
<span class="hljs-keyword">done</span>

<span class="hljs-keyword">for</span> (( a=1, b=10; a &lt;= 10; a++, b-- ))
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>"</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<h5 id="19633-while-%E5%91%BD%E4%BB%A4">1.9.6.3.3. while 命令</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span>命令的格式是：
<span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span>
<span class="hljs-keyword">do</span>
other commands
<span class="hljs-keyword">done</span>

</div></code></pre>
<p>while命令中定义的test command和if-then语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用test命令进行条件测试，比如测试变量值。
while命令的关键在于所指定的test command的退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化， while循环就将一直不停地进行下去。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$var1</span> -gt 0 ]
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span>
var1=$[ <span class="hljs-variable">$var1</span> - 1 ]
<span class="hljs-keyword">done</span>

</div></code></pre>
<p>while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span>
[ <span class="hljs-variable">$var1</span> -ge 0 ]
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"This is inside the loop"</span>
var1=$[ <span class="hljs-variable">$var1</span> - 1 ]
<span class="hljs-keyword">done</span>
</div></code></pre>
<h5 id="19634-until-%E5%91%BD%E4%BB%A4">1.9.6.3.4. until 命令</h5>
<p>until命令和while命令工作的方式完全相反。 until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0， bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了</p>
<p>和while命令类似，你可以在until命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的other commands。</p>
<pre class="hljs"><code><div>until <span class="hljs-built_in">test</span> commands
<span class="hljs-keyword">do</span>
    other commands
<span class="hljs-keyword">done</span>
</div></code></pre>
<h5 id="19635-%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF">1.9.6.3.5. 控制循环</h5>
<p>有两个命令能帮我们控制循环内部的情况：</p>
<ul>
<li>break命令</li>
<li>continue命令</li>
</ul>
<h5 id="19636-%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%BE%93%E5%87%BA">1.9.6.3.6. 处理循环的输出</h5>
<pre class="hljs"><code><div>在shell脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在<span class="hljs-keyword">done</span>命令
之后添加一个处理命令来实现。
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*
<span class="hljs-keyword">do</span>
<span class="hljs-keyword">if</span> [ -d <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> ]
<span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$file</span> is a directory"</span>
<span class="hljs-keyword">elif</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$file</span> is a file"</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span> &gt; output.txt

</div></code></pre>
<p>shell会将for命令的结果重定向到文件output.txt中，而不是显示在屏幕上。</p>
<h4 id="1964-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">1.9.6.4. 处理用户输入</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19641-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">1.9.6.4.1. 命令行参数</h5>
<p><strong>命令行参数</strong>
向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。</p>
<pre class="hljs"><code><div>$ ./addem 10 30
</div></code></pre>
<p><strong>读取参数</strong>
bash shell会将一些称为位置参数（ positional parameter）的特殊变量分配给输入到命令行中的所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字： $0是程序名， $1是第一个参数， $2是第二个参数，依次类推，直到第九个参数$9.如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如${10}</p>
<p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开。</p>
<p>但是这里存在一个潜在的问题。如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径。</p>
<p>basename命令会返回不包含路径的脚本名。</p>
<pre class="hljs"><code><div>$(basename <span class="hljs-variable">$0</span>)
</div></code></pre>
<p>当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> Hello <span class="hljs-variable">$1</span>, glad to meet you.
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Sorry, you did not identify yourself. "</span>
<span class="hljs-keyword">fi</span>
</div></code></pre>
<h5 id="19642-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">1.9.6.4.2. 特殊参数变量</h5>
<ul>
<li>特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样.</li>
<li>变量${$#}或者${!#}就代表了最后一个命令行参数变量,当命令行上没有任何参数时， $#的值为0，params变量的值也一样，但${!#}变量会返回命令行用到的脚本名。</li>
<li>$*和$@变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</li>
<li>$*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。</li>
<li>另一方面， $@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过for命令完成</li>
</ul>
<h5 id="19643-%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F">1.9.6.4.3. 移动变量</h5>
<p>bash shell工具箱中另一件工具是shift命令。 bash shell的shift命令能够用来操作命令行参数。跟字面上的意思一样， shift命令会根据它们的相对位置来移动命令行参数。
在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）。
这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>
<p>使用shift命令的时候要小心。如果某个参数被移出，它的值就被丢弃了，无法再恢复.</p>
<pre class="hljs"><code><div>count=1
<span class="hljs-keyword">while</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$1</span>"</span>
count=$[ <span class="hljs-variable">$count</span> + 1 ]
<span class="hljs-built_in">shift</span>
<span class="hljs-keyword">done</span>

</div></code></pre>
<p>也可以一次性移动多个位置，只需要给shift命令提供一个参数，指明要移动的位置数就行了。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">shift</span> 2
</div></code></pre>
<h5 id="19644-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9">1.9.6.4.4. 处理选项</h5>
<p>选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>
<p><strong>处理简单选项</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span>
        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -a option"</span> ;;
        -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -b option"</span> ;;
        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -c option"</span> ;;
        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$1</span> is not an option"</span> ;;
    <span class="hljs-keyword">esac</span>
<span class="hljs-built_in">shift</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>分离参数和选项</strong></p>
<p>想在shell脚本中同时使用选项和参数的情况。 Linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">do</span>
<span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span>
-a) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -a option"</span> ;;
-b) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -b option"</span>;;
-c) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -c option"</span> ;;
--) <span class="hljs-built_in">shift</span>
<span class="hljs-built_in">break</span> ;;
*) <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$1</span> is not an option"</span>;;
<span class="hljs-keyword">esac</span>
<span class="hljs-built_in">shift</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>处理带值的选项</strong>
有些选项会带上一个额外的参数值。在这种情况下，命令行看起来像下面这样。</p>
<pre class="hljs"><code><div>$ ./testing.sh -a test1 -b -c -d test2
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span>
        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -a option"</span>;;
        -b) param=<span class="hljs-string">"<span class="hljs-variable">$2</span>"</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -b option, with parameter value <span class="hljs-variable">$param</span>"</span>
        <span class="hljs-built_in">shift</span> ;;
        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -c option"</span>;;
        --) <span class="hljs-built_in">shift</span>
        <span class="hljs-built_in">break</span> ;;
        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$1</span> is not an option"</span>;;
    <span class="hljs-keyword">esac</span>
<span class="hljs-built_in">shift</span>
<span class="hljs-keyword">done</span>
<span class="hljs-comment">#</span>
</div></code></pre>
<p><strong>使用 getopt 命令</strong></p>
<p>getopt命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便</p>
<p>命令的格式
getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。它的命令格式如下：getopt optstring parameters
optstring是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。</p>
<p>首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。 getopt命令会基于你定义的optstring解析提供的参数。</p>
<pre class="hljs"><code><div>$ getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -<span class="hljs-built_in">cd</span> test2 test3
<span class="hljs-comment">#输出</span>
 -a -b test1 -c -d -- test2 test3

</div></code></pre>
<p>optstring定义了四个有效选项字母： a、 b、 c和d。冒号（ :）被放在了字母b后面，因为b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（ -a -b test1 -cd
test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cd选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数。</p>
<p>如果指定了一个不在optstring中的选项，默认情况下， getopt命令会产生一条错误消息。</p>
<pre class="hljs"><code><div>$ getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -cde test2 test3
getopt: invalid option -- e
-a -b test1 -c -d -- test2 test3
$
</div></code></pre>
<p>如果想忽略这条错误消息，可以在命令后加-q选项。</p>
<pre class="hljs"><code><div>$ getopt -q ab:<span class="hljs-built_in">cd</span> -a -b test1 -cde test2 test3
-a -b <span class="hljs-string">'test1'</span> -c -d -- <span class="hljs-string">'test2'</span> <span class="hljs-string">'test3'</span>
$
</div></code></pre>
<p>注意， getopt命令选项必须出现在optstring之前。现在应该可以在脚本中使用此命令处
理命令行选项了。</p>
<p><strong>在脚本中使用getopt</strong></p>
<p>可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。方法是用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。用set命令能够做到。</p>
<p>set命令的选项之一是双破折线（ --），它会将命令行参数替换成set命令的命令行值。然后，该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，看起来如下所示。
set -- $(getopt -q ab:cd &quot;$@&quot;)
现在原始的命令行参数变量的值会被getopt命令的输出替换，而getopt已经为我们格式化好了命令行参数。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">set</span> -- $(getopt -q ab:<span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>)
<span class="hljs-keyword">while</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> ]
<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span>
        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -a option"</span> ;;
        -b) param=<span class="hljs-string">"<span class="hljs-variable">$2</span>"</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -b option, with parameter value <span class="hljs-variable">$param</span>"</span>
        <span class="hljs-built_in">shift</span> ;;
        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -c option"</span> ;;
        --) <span class="hljs-built_in">shift</span>
        <span class="hljs-built_in">break</span> ;;
        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$1</span> is not an option"</span>;;
    <span class="hljs-keyword">esac</span>
    <span class="hljs-built_in">shift</span>
<span class="hljs-keyword">done</span>

count=1
<span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Parameter #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$param</span>"</span>
count=$[ <span class="hljs-variable">$count</span> + 1 ]
<span class="hljs-keyword">done</span>


</div></code></pre>
<pre class="hljs"><code><div>./test18.sh -a -b test1 -<span class="hljs-built_in">cd</span> <span class="hljs-string">"test2 test3"</span> test4
Found the -a option
Found the -b option, with parameter value <span class="hljs-string">'test1'</span>
Found the -c option
Parameter <span class="hljs-comment">#1: 'test2</span>
Parameter <span class="hljs-comment">#2: test3'</span>
Parameter <span class="hljs-comment">#3: 'test4</span>
</div></code></pre>
<p>getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。幸而还有另外一个办法能解决这个问题。</p>
<p><strong>使用更高级的 getopts</strong></p>
<p>getopts命令（注意是复数）内建于bash shell。它跟近亲getopt看起来很像，但多了一些扩展功能。</p>
<p>与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契。
每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。
getopts命令的格式如下：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">getopts</span> optstring variable
</div></code></pre>
<p>optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在optstring之前加一个冒号。 getopts命令将当前参数保存在命令行中定义的variable中。
getopts命令会用到两个环境变量。如果选项需要跟一个参数值， OPTARG环境变量就会保存这个值。 OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">echo</span>
<span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> :ab:c opt
<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$opt</span>"</span> <span class="hljs-keyword">in</span>
        a) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -a option"</span> ;;
        b) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -b option, with value <span class="hljs-variable">$OPTARG</span>"</span>;;
        c) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Found the -c option"</span> ;;
        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"Unknown option: <span class="hljs-variable">$opt</span>"</span>;;
    <span class="hljs-keyword">esac</span>
<span class="hljs-keyword">done</span>

</div></code></pre>
<pre class="hljs"><code><div>$ ./test19.sh -ab test1 -c
Found the -a option
Found the -b option, with value test1
Found the -c option
</div></code></pre>
<p>getopts命令有几个好用的功能,可以在参数值中包含空格.</p>
<pre class="hljs"><code><div>$ ./test19.sh -b <span class="hljs-string">"test1 test2"</span> -a
Found the -b option, with value test1 test2
Found the -a option
</div></code></pre>
<p>另一个好用的功能是将选项字母和参数值放在一起使用，而不用加空格。</p>
<pre class="hljs"><code><div>$ ./test19.sh -abtest1
Found the -a option
Found the -b option, with value test1
</div></code></pre>
<p>getopts命令能够从-b选项中正确解析出test1值。除此之外， getopts还能够将命令行上
找到的所有未定义的选项统一输出成问号。</p>
<pre class="hljs"><code><div>$ ./test19.sh -d
Unknown option: ?
$
$ ./test19.sh -acde
Found the -a option
Found the -c option
Unknown option: ?
Unknown option: ?
</div></code></pre>
<h5 id="19645-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">1.9.6.4.5. 获得用户输入</h5>
<p><strong>基本的读取</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">echo</span> -n <span class="hljs-string">"Enter your name: "</span>
<span class="hljs-built_in">read</span> name
</div></code></pre>
<p>生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行</p>
<p>实际上， read命令包含了-p选项，允许你直接在read命令行指定提示符。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">read</span> -p <span class="hljs-string">"Please enter your age: "</span> age
</div></code></pre>
<p>read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。</p>
<p><strong>超时</strong></p>
<p>可以用-t选项来指定一个计时器。 -t选项指定了read命令等待输入的秒数。当计时器过期后， read命令会返回一个非零退出状态码。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">read</span> -t 5 name

</div></code></pre>
<p>也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">read</span> -n1 -p <span class="hljs-string">"Do you want to continue [Y/N]? "</span> answer
<span class="hljs-keyword">case</span> <span class="hljs-variable">$answer</span> <span class="hljs-keyword">in</span>
    Y | y) <span class="hljs-built_in">echo</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"fine, continue on…"</span>;;
    N | n) <span class="hljs-built_in">echo</span>
    <span class="hljs-built_in">echo</span> OK, goodbye
    <span class="hljs-built_in">exit</span>;;
<span class="hljs-keyword">esac</span>
</div></code></pre>
<p>本例中将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后， read命令就会接受输入并将它传给变量，无需按回车键。</p>
<p><strong>隐藏方式读取</strong></p>
<p>-s选项可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。</p>
<p><strong>从文件中读取</strong></p>
<p>也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时， read命令会退出并返回非零退出状态码。
其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。</p>
<pre class="hljs"><code><div>cat <span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line
<span class="hljs-keyword">do</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Line <span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>"</span>
count=$[ <span class="hljs-variable">$count</span> + 1]
<span class="hljs-keyword">done</span>
</div></code></pre>
<h4 id="1965-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE">1.9.6.5. 呈现数据</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19651-%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">1.9.6.5.1. 理解输入和输出</h5>
<p><strong>标准文件描述符</strong>
Linux系统将每个对象当作文件处理。这包括输入和输出进程。 Linux用文件描述符（ filedescriptor） 来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的， bash shell保留了前三个文件描述符（ 0、 1和2）</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩 写</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<p>STDIN
STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。 shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（ &lt;）时， Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>
<p>STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。 shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。你可以用输出重定向&gt;来改变.通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。
你也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成.</p>
<p>shell通过特殊的STDERR文件描述符来处理错误消息。 STDERR文件描述符代表shell的标准错误输出。 shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下， STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出， STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，你常常会想改变这种行为，尤其是当你希望将错误消息保存到日志文件中的时候。</p>
<p><strong>重定向错误</strong>
重定向STDERR数据也没太大差别，只要在使用重定向符号时定义STDERR文件描述符就可以了。有几种办法实现方法。</p>
<ul>
<li>只重定向错误
可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。</li>
</ul>
<pre class="hljs"><code><div>lgj@lgj-Lenovo-G470:~/aaa$ ls -al badfile 2&gt; test4
lgj@lgj-Lenovo-G470:~/aaa$ cat test4
ls: cannot access <span class="hljs-string">'badfile'</span>: No such file or directory

</div></code></pre>
<p>现在运行该命令，错误消息不会出现在屏幕上了。该命令生成的任何错误消息都会保存在输出文件中。用这种方法， shell会只重定向错误消息，而非普通数据。</p>
<ul>
<li>重定向错误和数据</li>
</ul>
<p>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>
<pre class="hljs"><code><div>s -al <span class="hljs-built_in">test</span> test2 test3 badtest 2&gt; test6 1&gt; test7
</div></code></pre>
<p>可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息，再不用在成千上万行正常输出数据中翻腾了</p>
<p>另外， 如果愿意， 也可以将STDERR和STDOUT的输出重定向到同一个输出文件。 为此bash shell提供了特殊的重定向符号&amp;&gt;。</p>
<pre class="hljs"><code><div>ls -al <span class="hljs-built_in">test</span> test2 test3 badtest &amp;&gt; test7
</div></code></pre>
<h5 id="19652-%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA">1.9.6.5.2. 脚本中重定向输出</h5>
<p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>
<ul>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有命令</li>
</ul>
<p><strong>临时重定向</strong></p>
<p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个&amp;：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">echo</span> <span class="hljs-string">"This is an error message"</span> &gt;&amp;2
</div></code></pre>
<p>这行会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT。</p>
<p>默认情况下， Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>
<pre class="hljs"><code><div>$ ./test8 2&gt; test9
This is normal output
$ cat test9
This is an error
</div></code></pre>
<p><strong>永久重定向脚本中的所有命令</strong></p>
<p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 1&gt;testout
<span class="hljs-built_in">exec</span> 2&gt;testerror
</div></code></pre>
<h5 id="19653-%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5">1.9.6.5.3. 脚本中重定向输入</h5>
<p>你可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。 exec命令允许你将STDIN重定向到Linux系统上的文件中：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 0&lt; testfile
</div></code></pre>
<p>这个命令会告诉shell它应该从文件testfile中获得输入，而不是STDIN。这个重定向只要在脚本需要输入时就会作用</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 0&lt; testfile
count=1
<span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>"</span>
    count=$[ <span class="hljs-variable">$count</span> + 1 ]
<span class="hljs-keyword">done</span>
</div></code></pre>
<h5 id="19654-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">1.9.6.5.4. 创建自己的重定向</h5>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们</p>
<p><strong>创建输出文件描述符</strong></p>
<p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 3&gt;test13out
<span class="hljs-built_in">echo</span> <span class="hljs-string">"and this should be stored in the file"</span> &gt;&amp;3
</div></code></pre>
<p>也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 3&gt;&gt;test13out
</div></code></pre>
<p><strong>重定向文件描述符</strong></p>
<p>你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。</p>
<pre class="hljs"><code><div><span class="hljs-comment">#将文件描述符3重定向到文件描述符1(标准输出)</span>
<span class="hljs-built_in">exec</span> 3&gt;&amp;1
<span class="hljs-comment">#将文件描述符1重定向到文件</span>
<span class="hljs-built_in">exec</span> 1&gt;test1
<span class="hljs-built_in">echo</span> <span class="hljs-string">"This should store in the output file"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"along with this line."</span>
<span class="hljs-comment">#将文件描述符1恢复到标准输出</span>
<span class="hljs-built_in">exec</span> 1&gt;&amp;3
<span class="hljs-comment">#输出</span>
$ ./test.sh
This should store <span class="hljs-keyword">in</span> the output file
$ cat test1
along with this line.

</div></code></pre>
<p>首先，脚本将文件描述符3重定向到文件描述符1的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。
第二个exec命令将STDOUT重定向到文件， shell现在会将发送给STDOUT的输出直接重定向到输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。
在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器</p>
<p><strong>创建输入文件描述符</strong></p>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 6&lt;&amp;0
<span class="hljs-built_in">exec</span> 0&lt; testfile
<span class="hljs-built_in">exec</span> 0&lt;&amp;6
</div></code></pre>
<p><strong>创建读写文件描述符</strong></p>
<p>可以用同一个文件描述符对同一个文件进行读写。
不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写， shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 3&lt;&gt; testfile
<span class="hljs-built_in">read</span> line &lt;&amp;3
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Read: <span class="hljs-variable">$line</span>"</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"This is a test line"</span> &gt;&amp;3
</div></code></pre>
<p><strong>关闭文件描述符</strong></p>
<p>如果你创建了新的输入或输出文件描述符， shell会在脚本退出时自动关闭它们。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符。
要关闭文件描述符，将它重定向到特殊符号&amp;-。脚本中看起来如下：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 3&gt;&amp;-
</div></code></pre>
<p>一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息</p>
<h5 id="19655-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">1.9.6.5.5. 列出打开的文件描述符</h5>
<p>lsof命令会列出整个Linux系统打开的所有文件描述符。这是个有争议的功能，因为它会向非系统管理员用户提供Linux系统的信息。鉴于此，许多Linux系统隐藏了该命令，这样用户就不
会一不小心就发现了。
在很多Linux系统中（如Fedora）， lsof命令位于/usr/sbin目录。要想以普通用户账户来运行它，必须通过全路径名来引用：$ /usr/sbin/lsof
该命令会产生大量的输出。它会显示当前Linux系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。
有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的有-p和-d，前者允许指定进程ID（ PID），后者允许指定要显示的文件描述符编号。
要想知道进程的当前PID，可以用特殊环境变量$$（ shell会将它设为当前PID）。 -a选项用来对其他两个选项的结果执行布尔AND运算，这会产生如下输出。</p>
<pre class="hljs"><code><div>$ /usr/sbin/lsof -a -p $$ -d 0,1,2
</div></code></pre>
<p>输出</p>
<pre class="hljs"><code><div>COMMAND    PID  TID             USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
systemd      1                  root  cwd   unknown                                         /proc/1/cwd (readlink: Permission denied)
systemd      1                  root  rtd   unknown                                         /proc/1/root (readlink: Permission denied)
systemd      1                  root  txt   unknown                                         /proc/1/exe (readlink: Permission denied)

</div></code></pre>
<ul>
<li>COMMAND 正在运行的命令名的前9个字符</li>
<li>PID 进程的PID</li>
<li>USER 进程属主的登录名</li>
<li>FD 文件描述符号以及访问类型（ r代表读， w代表写， u代表读写）</li>
<li>TYPE 文件的类型（ CHR代表字符型， BLK代表块型， DIR代表目录， REG代表常规文件）</li>
<li>DEVICE 设备的设备号（主设备号和从设备号）</li>
<li>SIZE 如果有的话，表示文件的大小</li>
<li>NODE 本地文件的节点号</li>
<li>NAME 文件名</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">exec</span> 3&gt; test18file1
<span class="hljs-built_in">exec</span> 6&gt; test18file2
<span class="hljs-built_in">exec</span> 7&lt; testfile
/usr/sbin/lsof -a -p $$ -d0,1,2,3,6,7
$ ./test18
COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME
test18 3594 rich 0u CHR 136,0 2 /dev/pts/0
test18 3594 rich 1u CHR 136,0 2 /dev/pts/0
test18 3594 rich 2u CHR 136,0 2 /dev/pts/0
18 3594 rich 3w REG 253,0 0 360712 /home/rich/test18file1
18 3594 rich 6w REG 253,0 0 360715 /home/rich/test18file2
18 3594 rich 7r REG 253,0 73 360717 /home/rich/testfile
</div></code></pre>
<h5 id="19656-%E9%98%BB%E6%AD%A2%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA">1.9.6.5.6. 阻止命令输出</h5>
<p>不想显示脚本的输出,要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。 null文件跟它的名字很像，文件里什么都没有。 shell输出到null文件的任何数据都不会保存，全部都被丢掉了。
在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<pre class="hljs"><code><div> ls -al &gt; /dev/null
 <span class="hljs-comment">#刷掉文件中的数据,文件testfile仍然存在系统上，但现在它是空文件。这是清除日志文件的一个常用方法，因为日志文件必须时刻准备等待应用程序操作。</span>
 cat /dev/null &gt; testfile
</div></code></pre>
<h5 id="19657-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">1.9.6.5.7. 创建临时文件</h5>
<p>Linux系统有特殊的目录，专供临时文件使用。 Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为你提供了一种创建临时文件的简单方法，而且还不用操心清理工作。
有个特殊命令可以用来创建临时文件。 mktemp命令可以在/tmp目录中创建一个唯一的临时文件。 shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然， root用户除外）。</p>
<p><strong>创建本地临时文件</strong></p>
<p>默认情况下， mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就行了。��板可以包含任意文本文件名，在文件名末尾加上6个X就行了。</p>
<pre class="hljs"><code><div>$ mktemp testing.XXXXXX

<span class="hljs-comment">#创建的文件</span>
-rw------- 1 lgj lgj   0 Dec  5 01:23 testing.neAOCU

</div></code></pre>
<p>mktemp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的。你可以创建多个临时文件，它可以保证每个文件都是唯一的。</p>
<p><strong>在/temp目录中创建临时文件</strong></p>
<p>-t选项会强制mktemp命令来在系统的临时目录来创建该文件。在用这个特性时， mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名。</p>
<pre class="hljs"><code><div>lgj@lgj-Lenovo-G470:~/aaa$ mktemp -t test.XXXXXX
/tmp/test.hkfHEK

lgj@lgj-Lenovo-G470:~/aaa$ ls -l /tmp/<span class="hljs-built_in">test</span>.*
-rw------- 1 lgj lgj 0 Dec  5 01:39 /tmp/test.hkfHEK

</div></code></pre>
<p><strong>创建临时目录</strong></p>
<p>-d选项告诉mktemp命令来创建一个临时目录而不是临时文件。</p>
<h5 id="19658-%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF">1.9.6.5.8. 记录消息</h5>
<p>将输出同时发送到显示器和日志文件，这种做法有时候能够派上用场。你不用将输出重定向两次，只要用特殊的tee命令就行。tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是STDOUT，另一处是tee命令行所指定的文件名：</p>
<pre class="hljs"><code><div>tee filename
</div></code></pre>
<h4 id="1966-%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC">1.9.6.6. 控制脚本</h4>
<p><a href="#menu" style="float:right">目录</a></p>
<h5 id="19661-%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7">1.9.6.6.1. 处理信号</h5>
<p><strong>Linux信号</strong></p>
<p>Linux系统和应用程序可以生成超过30个信号</p>
<p>常用Linux信号</p>
<table>
<thead>
<tr>
<th>信 号</th>
<th>值</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程，但不是终止进程</td>
</tr>
<tr>
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody>
</table>
<p>默认情况下， bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。</p>
<p>如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）</p>
<p>通过SIGINT信号，可以中断shell。 Linux内核会停止为shell分配CPU处理时间。这种情况发生时， shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。</p>
<p><strong>生成信号</strong></p>
<ul>
<li>中断进程,Ctrl+C组合键会生成SIGINT信号,并将其发送给当前在shell中运行的所有进程。</li>
<li>暂停进程,Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程.停止（ stopping）进程跟终止（ terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置
继续运行。</li>
</ul>
<p><strong>捕获信号</strong></p>
<p>也可以不忽略信号，在信号出现时捕获它们并执行其他命令。 trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再
由shell处理，而是交由本地处理。
trap命令的格式是：trap commands signals</p>
<pre class="hljs"><code><div><span class="hljs-built_in">trap</span> <span class="hljs-string">"echo ' Sorry! I have trapped Ctrl-C'"</span> SIGINT
</div></code></pre>
<p>以上在脚本中加入,运行状态时收到SIGINT会打印该语句,但是不会终止运行.
<strong>捕获脚本退出</strong></p>
<p>除了在shell脚本中捕获信号，你也可以在shell脚本退出时进行捕获。这是在shell完成任务时执行命令的一种简便方法</p>
<p>要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就行。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">trap</span> <span class="hljs-string">"echo Goodbye..."</span> EXIT
</div></code></pre>
<p>当脚本运行到正常的退出位置时，捕获就被触发了， shell会执行在trap命令行指定的命令。如果提前退出脚本(正常或者异常)，同样能够捕获到EXIT。</p>
<p><strong>修改或移除捕获</strong></p>
<p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令</p>
<p>也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">trap</span> -- SIGINT
</div></code></pre>
<h5 id="19662-%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">1.9.6.6.2. 以后台模式运行脚本</h5>
<p><strong>后台运行脚本</strong></p>
<p>以后台模式运行shell脚本非常简单。只要在命令后加个&amp;符就行了.当&amp;符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。显示的第一行是：[1] 3231</p>
<h5 id="19663-%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">1.9.6.6.3. 在非控制台下运行脚本</h5>
<p>时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退出了终端会话。这可以用nohup命令来实现。
nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。
nohup命令的格式如下：$ nohup ./test1.sh &amp;</p>
<p>和普通后台进程一样， shell会给命令分配一个作业号， Linux系统会为其分配一个PID号。区别在于，当你使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号</p>
<p>由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出， nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为nohup.out的文件中。</p>
<p>如果使用nohup运行了另一个命令，该命令的输出会被追加到已有的nohup.out文件中。当运行位于同一个目录中的多个命令时一定要当心，因为所有的输出都会被发送到同一个nohup.out文件中</p>
<h5 id="19664-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">1.9.6.6.4. 作业控制</h5>
<p><strong>查看作业</strong></p>
<p>作业控制中的关键命令是jobs命令。 jobs命令允许查看shell当前正在处理的作业。</p>
<p>jobs命令参数</p>
<table>
<thead>
<tr>
<th>参 数</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr>
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr>
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr>
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr>
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>$ <span class="hljs-built_in">jobs</span> -l
[1]+  8290 Running                 ./test.sh &amp;

</div></code></pre>
<p>你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。
当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业</p>
<p><strong>重启停止的作业</strong></p>
<p>要以后台模式重启一个作业，可用bg命令加上作业号
要以前台模式重启作业，可用带有作业号的fg命令</p>
<pre class="hljs"><code><div><span class="hljs-built_in">bg</span> 2
<span class="hljs-built_in">fg</span> 2
</div></code></pre>
<h5 id="19665-%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6">1.9.6.6.5. 调整谦让度</h5>
<p>在多任务操作系统中（ Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。 调度优先级（ scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统
中，由shell启动的所有进程的调度优先级默认都是相同的。
调度优先级是个整数值，从20（最高优先级）到+19（最低优先级）。默认情况下， bash shell以优先级0来启动所有进程</p>
<p><strong>nice命令</strong></p>
<p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别。</p>
<pre class="hljs"><code><div>$ nice -n 10 ./test4.sh &gt; test4.out &amp;

<span class="hljs-comment">#查看优先级ni</span>
ps -p 4973 -o pid,ppid,ni,cmd
</div></code></pre>
<p>nice命令阻止普通系统用户来提高命令的优先级。</p>
<p><strong>renice命令</strong></p>
<p>改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定运行进程的PID来改变它的优先级。</p>
<pre class="hljs"><code><div>renice -n 10 -p 5055
</div></code></pre>
<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样， renice命令也有一些限制：</p>
<ul>
<li>只能对属于你的进程执行renice；</li>
<li>只能通过renice降低进程的优先级；</li>
<li>root用户可以通过renice来任意调整进程的优先级。
如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令。</li>
</ul>
<h5 id="19666-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A">1.9.6.6.6. 定时运行作业</h5>
<p><strong>用at命令</strong></p>
<p>at命令允许指定Linux系统何时运行脚本。 at命令会将作业提交到队列中，指定shell何时运行该作业。 at的守护进程atd会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。
atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下， atd守护进程会每60秒检查一下这个目录。有作业时， atd守护进程会检查
作业设置运行的时间。如果时间跟当前时间匹配， atd守护进程就会运行此作业</p>
<p>at命令的基本格式非常简单：at [-f filename] time</p>
<p>默认情况下， at命令会将STDIN的输入放到队列中。你可以用-f参数来指定用于读取命令（脚本文件）的文件名。
time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过， at命令会在第二天的那个时间运行指定的作业。
在如何指定时间这个问题上，你可以非常灵活。 at命令能识别多种不同的时间格式。</p>
<ul>
<li>标准的小时和分钟格式，比如10:15。</li>
<li>AM/PM指示符，比如10:15 PM。</li>
<li>特定可命名时间，比如now、 noon、 midnight或者teatime（ 4 PM）。
除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</li>
<li>标准日期格式，比如MMDDYY、 MM/DD/YY或DD.MM.YY。</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li>
<li>你也可以指定时间增量。</li>
<li>当前时间+25 min</li>
<li>明天10:15 PM</li>
<li>10:15+7天</li>
</ul>
<p>在你使用at命令时，该作业会被提交到作业队列（ job queue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a~z和大写字母A~Z来指代。</p>
<pre class="hljs"><code><div>lgj@lgj-Lenovo-G470:~/aaa$ at -f test.sh now
warning: commands will be executed using /bin/sh
job 8 at Thu Dec  5 04:23:00 2019

</div></code></pre>
<p><strong>安排需要定期执行的脚本</strong></p>
<p>用at命令在预设时间安排脚本执行非常好用，但如果你需要脚本在每天的同一时间运行或是每周一次、每月一次呢？用不着再使用at不断提交作业了，你可以利用Linux系统的另一个功能。Linux系统使用cron程序来安排要定期执行的作业。 cron程序会在后台运行并检查一个特殊的表（被称作cron时间表） ，以获知已安排执行的作业。</p>
<p>cron时间表采用一种特别的格式来指定作业何时运行。其格式如下：
min hour dayofmonth month dayofweek command
cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：15 10 * * * command</p>
<p>可以用三字符的文本值（ mon、 tue、 wed、 thu、 fri、 sat、 sun）或数值（ 0为周日， 6为周六）来指定dayofweek表项。</p>
<p>如何设置一个在每个月的最后一天执行的命令，因为你无法设置dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解决办法。常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：00 12 * * * if [<code>date +%d -d tomorrow</code> = 01 ] ; then ; command
它会在每天中午12点来检查是不是当月的最后一天，如果是， cron将会运行该命令。</p>
<p>命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号。
15 10 * * * /home/rich/test4.sh &gt; test4out</p>
<p><strong>使用新的shell启动脚本</strong></p>
<h3 id="197-%E9%AB%98%E7%BA%A7-shell-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.7. 高级 shell 脚本编程</h3>
<h4 id="1971-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0">1.9.7.1. 创建函数</h4>
<h5 id="19711-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0">1.9.7.1.1. 基本的脚本函数</h5>
<p>第一种格式采用关键字function，后跟分配给该代码块的函数名。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> name {
    commands
}
</div></code></pre>
<p>第二种格式更接近于其他编程语言中定义函数的方式。函数名后的空括号表明正在定义的是一个函数</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-title">name</span></span>() {
    commands
}
</div></code></pre>
<p><strong>使用函数</strong>
使用函数直接调用函数名称即可.函数在调用前必须先声明,否则会抛出错误.</p>
<h5 id="19712-%E8%BF%94%E5%9B%9E%E5%80%BC">1.9.7.1.2. 返回值</h5>
<p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成退出状态码。</p>
<p><strong>默认退出状态码</strong></p>
<p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。</p>
<p><strong>使用 return 命令</strong></p>
<p>bash shell使用return命令来退出函数并返回特定的退出状态码。 return命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> db1 {
    <span class="hljs-built_in">read</span> -p <span class="hljs-string">"Enter a value: "</span> value
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"doubling the value"</span>
    <span class="hljs-built_in">return</span> $[ <span class="hljs-variable">$value</span> * 2 ]
}
db1
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The new value is $?"</span>
$
</div></code></pre>
<p>但当用这种方法从函数中返回值时，要小心了。记住下面两条技巧来避免问题：</p>
<ul>
<li>函数一结束就取返回值；</li>
<li>退出状态码必须是0~255。超过该范围会导致溢出
如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住， $?变量会返回执行的最后一条命令的退出状态码。
第二个问题界定了返回值的取值范围。由于退出状态码必须小于256，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。要返回较大的整数值或者字符串值的话，你就不能用这种返回值的方法了</li>
</ul>
<p><strong>使用函数输出</strong></p>
<p>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：
result='dbl'
这个命令会将dbl函数的输出赋给$result变量。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> dbl {
    <span class="hljs-built_in">read</span> -p <span class="hljs-string">"Enter a value: "</span> value
    <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$value</span> * 2 ]
}
result=$(dbl)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The new value is <span class="hljs-variable">$result</span>"</span>
</div></code></pre>
<p>$result的值是函数中所有echo的输出值</p>
<p>dbl函数实际上输出了两条消息。 read命令输出了一条简短的消息来向用户询问输入值。 bash shell脚本非常聪明， 并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。</p>
<h5 id="19713-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.7.1.3. 在函数中使用变量</h5>
<p><strong>向函数传递参数</strong>
函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在$0变量中定义，函数命令行上的任何参数都会通过$1、 $2等定义。也可以用特殊变量$#来判断传给函数的参数数目。</p>
<p>调用并传参</p>
<pre class="hljs"><code><div>result=$(db1 par1  par2 )
</div></code></pre>
<p><strong>在函数中使用变量</strong></p>
<p>函数使用两种类型的变量：全局变量和局部变量</p>
<p>全局变量是在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚
本的主体部分读取它的值。
默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。</p>
<p>无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这一点，只要在变量声明的前面加上local关键字就可以了。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">local</span> temp
<span class="hljs-built_in">local</span> temp=$[ <span class="hljs-variable">$value</span> + 5 ]
</div></code></pre>
<p>local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。</p>
<h5 id="19714-%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">1.9.7.1.4. 数组变量和函数</h5>
<p><strong>向函数传数组参数</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> testit {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"The parameters are: <span class="hljs-variable">$@</span>"</span>
    thisarray=<span class="hljs-variable">$1</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"The received array is <span class="hljs-variable">${thisarray[*]}</span>"</span>
}
myarray=(1 2 3 4 5)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The original array is: <span class="hljs-variable">${myarray[*]}</span>"</span>
testit <span class="hljs-variable">$myarray</span>
$
$ ./badtest3
The original array is: 1 2 3 4 5
The parameters are: 1
The received array is 1
$
</div></code></pre>
<p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值。
要解决这个问题，你必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。下面是个具体的例子。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> testit {
<span class="hljs-built_in">local</span> newarray
    newarray=(;<span class="hljs-string">'echo "$@"'</span>)
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"The new array value is: <span class="hljs-variable">${newarray[*]}</span>"</span>
}
myarray=(1 2 3 4 5)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The original array is <span class="hljs-variable">${myarray[*]}</span>"</span>
testit <span class="hljs-variable">${myarray[*]}</span>
$
$ ./test10
The original array is 1 2 3 4 5
The new array value is: 1 2 3 4 5
$
</div></code></pre>
<p><strong>从函数返回数组</strong></p>
<p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">function</span> arraydblr {
    <span class="hljs-built_in">local</span> origarray
    <span class="hljs-built_in">local</span> newarray
    <span class="hljs-built_in">local</span> elements
    <span class="hljs-built_in">local</span> i
    origarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>))
    newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>))
    elements=$[ <span class="hljs-variable">$#</span> - 1 ]
    <span class="hljs-keyword">for</span> (( i = 0; i &lt;= <span class="hljs-variable">$elements</span>; i++ ))
    {
        newarray[<span class="hljs-variable">$i</span>]=$[ <span class="hljs-variable">${origarray[$i]}</span> * 2 ]
    }
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">${newarray[*]}</span>
}
myarray=(1 2 3 4 5)
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The original array is: <span class="hljs-variable">${myarray[*]}</span>"</span>
arg1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">${myarray[*]}</span>)
result=($(arraydblr <span class="hljs-variable">$arg1</span>))
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The new array is: <span class="hljs-variable">${result[*]}</span>"</span>
$
$ ./test12
The original array is: 1 2 3 4 5
The new array is: 2 4 6 8 10
</div></code></pre>
<p>该脚本用$arg1变量将数组值传给arraydblr函数。 arraydblr函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。
arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来重新生成一个新的数组变量。</p>
<h5 id="19715-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">1.9.7.1.5. 函数递归</h5>
<p>局部函数变量的一个特性是自成体系。除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。
这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。</p>
<h5 id="19716-%E5%88%9B%E5%BB%BA%E5%BA%93">1.9.7.1.6. 创建库</h5>
<p>使用函数可以在脚本中省去一些输入工作，这一点是显而易见的。但如果你碰巧要在多个脚本中使用同一段代码呢？显然，为了使用一次而在每个脚本中都定义同样的函数太过麻烦</p>
<p>和环境变量一样， shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本， shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。
myfuncs.sh定义公共函数
test.sh中这样使用会出现问题</p>
<pre class="hljs"><code><div>./myfuncs.sh
</div></code></pre>
<p>使用函数库的关键在于source命令。 source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库
中的函数了。source命令有个快捷的别名，称作点操作符（ dot operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行：. ./myfuncs
正确用法</p>
<pre class="hljs"><code><div>. ./myfuncs.sh
</div></code></pre>
<h5 id="19717-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">1.9.7.1.7. 在命令行上使用函数</h5>
<h4 id="1972-%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B">1.9.7.2. 图形化桌面环境中的脚本编程</h4>
<h4 id="1973-%E5%88%9D%E8%AF%86-sed-%E5%92%8C-gawk">1.9.7.3. 初识 sed 和 gawk</h4>
<h5 id="19731-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">1.9.7.3.1. 文本处理</h5>
<h5 id="19732-sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80">1.9.7.3.2. sed编辑器基础</h5>
<h4 id="1974-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4. 正则表达式</h4>
<h5 id="19741-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4.1. 什么是正则表达式</h5>
<h5 id="19742-%E5%AE%9A%E4%B9%89bre%E6%A8%A1%E5%BC%8F">1.9.7.4.2. 定义BRE模式</h5>
<h5 id="19743-%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.9.7.4.3. 扩展正则表达式</h5>
<h5 id="19744-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E6%88%98">1.9.7.4.4. 正则表达式实战</h5>
<h4 id="1975-sed-%E8%BF%9B%E9%98%B6">1.9.7.5. sed 进阶</h4>
<h5 id="19751-%E5%A4%9A%E8%A1%8C%E5%91%BD%E4%BB%A4">1.9.7.5.1. 多行命令</h5>
<h5 id="19752-%E4%BF%9D%E6%8C%81%E7%A9%BA%E9%97%B4">1.9.7.5.2. 保持空间</h5>
<h5 id="19753-%E6%8E%92%E9%99%A4%E5%91%BD%E4%BB%A4">1.9.7.5.3. 排除命令</h5>
<h5 id="19754-%E6%94%B9%E5%8F%98%E6%B5%81">1.9.7.5.4. 改变流</h5>
<h5 id="19755-%E6%A8%A1%E5%BC%8F%E6%9B%BF%E4%BB%A3">1.9.7.5.5. 模式替代</h5>
<h5 id="19756-%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8sed">1.9.7.5.6. 在脚本中使用sed</h5>
<h5 id="19757-%E5%88%9B%E5%BB%BAsed%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7">1.9.7.5.7. 创建sed实用工具</h5>
<h4 id="1976-gawk-%E8%BF%9B%E9%98%B6">1.9.7.6. gawk 进阶</h4>
<h5 id="19761-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F">1.9.7.6.1. 使用变量</h5>
<h5 id="19762-%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">1.9.7.6.2. 处理数组</h5>
<h5 id="19763-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F">1.9.7.6.3. 使用模式</h5>
<h5 id="19764-%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4">1.9.7.6.4. 结构化命令</h5>
<h5 id="19765-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0">1.9.7.6.5. 格式化打印</h5>
<h5 id="19766-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0">1.9.7.6.6. 内建函数</h5>
<h5 id="19767-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">1.9.7.6.7. 自定义函数</h5>

</body>
</html>
